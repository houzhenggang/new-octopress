<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2013-08-17T22:16:43+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux下的虚拟化技术]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/08/17/linuxxia-de-xu-ni-hua-ji-zhu/"/>
    <updated>2013-08-17T20:59:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/08/17/linuxxia-de-xu-ni-hua-ji-zhu</id>
    <content type="html"><![CDATA[<p>因为要在一台Linux系统中虚拟化一个系统，于是这周接触了一下Linux下虚拟机的内容。<br/>
公司以前一直用的redhat的linux，我所知的虚拟技术仅限于xen和kvm，而且根据一些反馈用的并不是很好。主要体现在资源占用过大，硬盘和内存的消耗都很大，当然公司的服务器硬件配置也有点不够平衡。</p>

<p>然而，在接触了ubuntu的虚拟化后，一下子有茅塞顿开的感觉。首先，windows下我常用的virtualbox就可以在ubuntu下使用。xen和kvm当然ubuntu也是支持的。同时这几种虚拟化技术都可以按命令行的方式使用。其次，ubuntu在安装虚拟化套件方面是十分方便的。主要原因在于它的包要比redhat的时新的多。还有一点，ubuntu比起redhat还是很小巧的。这点在虚拟化的时候显得比较重要。毕竟一台主机的时候，只会安装一个os，如果大2GB那也就只是2GB。一旦云化后，一台主机往往就要4+1个操作系统，在磁盘不富裕的情况下，os的臃肿会成比例的放大。这时候小巧的os就显示出了优势。<br/>
所以我倾向于采用ubuntu server作为云化的主力os。至少应该是虚机的主体。</p>

<p>接下来就是选择何种东西虚拟化了。主要下面3种：</p>

<ul>
<li>xen: 国内用的最多，因为历史最长，也有商业化的支持</li>
<li>kvm：半虚拟化技术，做在kernel里面，redhat和ubuntu大力支持</li>
<li>virtualbox: 是的，其实这可能是最好用的linux虚机软件</li>
</ul>


<p>性能方面，根据<a href="http://www.liangsuilong.info/?p=675">kvm vs Virtualbox</a> 和 <a href="http://server.zol.com.cn/257/2575328.html">Ubuntu11.10 Xen Kvm Virtualbox比拼</a>，总体而言kvm的性能最佳，大文件比virtualbox有所不如。而且从未来规划来看，redhat和ubuntu普遍倾向于支持kvm。但是，virtualbox有两大优势：1.使用是图形化的界面，很简单； 2.与kvm和xen都专注于cpu性能不同，virtualbox的图形化性能要比另外两个都强许多。不过vbox实际上是基于qemu改进的，kvm-qemu也是一个组合。所以，普通用用的情况下可以直接上virtualbox。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web and HTML Document]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/07/26/web-and-html-document/"/>
    <updated>2013-07-26T09:07:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/07/26/web-and-html-document</id>
    <content type="html"><![CDATA[<p>DHH在2013年的rails conf上做了关于类37signals web应用发展方向的报告。听了之后，还是解除了很大的迷茫。</p>

<p>工作十余年，开发Web应用也八九年了。期间研究过Flex，也写过不少ajax。但到今天却觉得Web的form提交然后出结果才是真正最有用的。
我们的下单，填填表格，登录等等，讲到底需要的只是一个让人知道怎么填的form，然后简单的提交就足够了。其余的东西再花哨，很多时候对解决问题并没有实质性的帮助。<br/>
然而，富客户端应用也是客观存在的，甚至有js重度客户端应用将取代HTML应用的论调甚嚣尘上。以我的感觉判断，这是不太会发生的。原因在于js的开发很麻烦，工作量其实是很大的，而且也限制死了可以使用的工具。要取得一个简单的页面所达到的效果，完全采用js会产生巨大的工作量。而Web应用至今而且也将继续是大量表单类的应用。只要客户端的开发难度、工作量依然如此同服务端不成比例，那么就很难成为主流，更别提替换HTML了。<br/>
所以，在这一点上毫无疑问我赞同D大神的，重客户端应用不可能取代Web HTML应用。</p>

<p>DHH陈述的突破之处在于提出这种HTML应用为 <strong>document-based</strong> Web ，以同google 地图这种应用区分开来。Web由于其简单或者说简陋，想要丰富它或者取代它的技术一直没中断过。从Java Applet开始，到flash，Siverlight等等，都曾经让Web的效果不堪一击。然而，20年来的现实情况是，不拥抱Document的技术最终都在HTML之前走了下坡路。D大神把从90年代中期至今的挑战HTML技术串联起来说，体现了磅礴的气势和全面的大局观。</p>

<p>与此同时，他也认为Document需要继续发展，这就是他说的再Basecamp，其实也就是Rails4中增加的新技术，其实本质就是caching。具体包括：</p>

<ul>
<li>key-based cache (generational caching)</li>
<li>Russian Doll nested caching, 4 level, touch: true, partial md5</li>
<li>Turbolinks process persistence, (pajx)</li>
<li>Polling for js updates(类似rjs)</li>
</ul>


<p>核心内容就是提高HTML在浏览器上的速度。而Caching能大规模流行的基础是<strong>内存红利</strong>.</p>

<table>
<tr><td>  2003年  </td><td>  512MB </td><td>  $49  </td></tr>
<tr><td>  2013年  </td><td>  8GB   </td><td>  $29  </td></tr>
</table>


<p>不过此次Web面临的挑战和多年来历次遇到的还是有很大不同的。不管是flash还是applet，他们都是想作为整体的HTML+CSS+Javascript发起挑战。而这次却是原来Web整体中的Javascript和HTML谁唱主角之争。区别在于JS和HTML所占比例及所显示页面数量的巨大区别。</p>

<p>但是，只要Web还够简单，只要js的开发工作量还很繁重，那么产生HTML依然还是主要的Web应用模式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CentOS5 Ruby2.0 and Rails4.0]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/07/12/centos5-ruby2-dot-0-and-rails4-dot-0/"/>
    <updated>2013-07-12T12:55:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/07/12/centos5-ruby2-dot-0-and-rails4-dot-0</id>
    <content type="html"><![CDATA[<p>升级了一个很小的rails应用到4.0，原先使用的版本ree1.8.7 + rails3.1 。因为应用很小，也没使用很多插件，所以git checkout一个branch之后，用rails new生成新的目录完全替换掉老的文件。然后用<code>git diff</code>对一个一个目录或者文件进行比对与合并。整个过程下来，发现rails默认生成的文件，3.1和4.0的区别并非很大。</p>

<p>这个过程也就是只有几个小时，半天不到的时间就让应用可以跑起来了。本地测试了一下，写入数据库、查询、写入文件等都没什么问题。随后自然就是部署。</p>

<p>但此时，问题来了. 本地开发的环境是这样的：</p>

<ul>
<li>Ubuntu 12.04</li>
<li>gcc version 4.6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5)</li>
<li>ruby 2.0.0p195 (2013-05-14 revision 40734) [x86_64-linux]</li>
<li>rails 4</li>
</ul>


<p>而部署环境是这样的：</p>

<ul>
<li>CentOS release 5.4</li>
<li>gcc 版本 4.1.2 20080704</li>
<li>ruby 2.0.0p247 (2013-06-27) [i686-linux]</li>
<li>rails 4</li>
</ul>


<p>在本地运作良好的rails4应用，部署到生产环境后发生下面两个异常：</p>

<p>1 <code>rake db:migrate</code>每次只能成功一个migrate，但经反复执行后，能够migrate完整</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SQLite3::SQLException: SQL logic error or missing database: INSERT INTO "schema_migrations" ("version") VALUES (?)</span></code></pre></td></tr></table></div></figure>


<p>2 开发环境下正常，生产环境下会报告<code>nil?</code>在某个object上不存在。</p>

<p>为此，则折腾掉了很多的业余时间。</p>

<p>怀疑过是Gem的版本问题，怀疑过是ruby版本的问题,也怀疑过是ruby编译问题。</p>

<p>针对第一种可能，重新生成了一个rails应用，执行的结果照旧。<br/>
为了第二种可能，使用了ruby2.0.0p195，异常依旧；换成ruby1.9.3，但发现有个atom的gem都不能bundle上去。<br/>
随后，针对第三个可能，不惜<strong>升级的了CentOS到5.9</strong>(<code>yum upgrade</code>),为此下载了600MB的更新包。 <br/>
又重新编译安装了ruby2.0.0p0, 哦?!，世界太平了。虽然第一个异常依然，但第二个异常没了，应用是能够跑的起来了。
之后，再重新编译另外两个ruby版本就都可以正常工作了（第一个问题还是在的）。</p>

<p>由此可见，这是一个和gcc版本、os版本及ruby版本都相关的bug。</p>

<h3>教训</h3>

<p>新版的ruby或Rails同CentOS接触的并不好，如果要少麻烦的话，APP的OS还是应该选择Ubuntu。从生态的情况来看，这个责任只能怨CentOS支持的内核、gcc、lib库都过于老旧了。<br/>
之所以这么说，不单单是因为在ruby上碰到这种要比在ubuntu上麻烦的多的情形。从七周七语言的情况看，CentOS即使是CentOS6，也不支持对Haskell的安装，在安装其他语言时，多多少少都会遇到编译麻烦的问题。<br/>
CentOS是基于Redhat的，以稳定（老旧）为荣。而APP则是迅速发展的，因此二者极其容易脱节。所以，APP服务器首选Ubuntu。</p>

<h3>题外话</h3>

<p>从对OS的依赖少这点来看，Java确实做了件很漂亮的事情。一个编译好的jdk文件，可以在几乎全部的主流linux下解压，然后即可使用。部署时也不用担心底层OS是什么实现。所以，如果是Java的应用，继续用CentOS也是不会有很多坑的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure is really pesky]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/07/09/clojure-is-really-pesky/"/>
    <updated>2013-07-09T22:07:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/07/09/clojure-is-really-pesky</id>
    <content type="html"><![CDATA[<p>最早知道clojure，是在Heroku宣布<a href="https://blog.heroku.com/archives/2011/7/5/clojure_on_heroku">支持</a><a href="http://devcenter.heroku.com/articles/clojure">它</a>，这是Heroku支持的第三种语言。知道彼时这个东西挺火。应该和闭包什么的有关联。</p>

<p>这次看七周七语言，终于得以一睹真容。知道了clojure其实就是Lisp的一个JVM实现。
不过今天试用了一下clojure，感觉这个东西不太灵。
基于JVM的设计思路听上去不错，但仔细想想JVM的lib真有那么大的意义吗？答案是否定的。我不太相信用惯了其他语言的人会喜欢在新语言中继续调用java的内容。在ruby中，我不会有兴趣去调用java。一旦用惯了clojure也不太可能再接受调用java的api。对比起来，scala倒是和java结合的挺紧密。</p>

<p>变成jvm的一部分，一大恶果就是启动变慢，从而作为脚本功能来跑很不美。毕竟一个jvm启动的时间很长，内存消耗也很大，对于处理任务极其简单的情况下，jvm启动的时间和内存开销显然过大了。
其次，融入jvm中，意味着需要ide的配合。无论哪种ide，都是很重的，因此很是麻烦。
叠加起来，就是导致这种基于jvm模式的开发是不令人愉快的。</p>

<p>而Lisp程序员似乎都喜欢用emacs，emacs和ide兼容，呵呵，这是在开什么玩笑。注定这东西的推广在开发层面会存在很大的障碍。</p>

<p>当然，天下英雄用java做clojure scala甚至jruby也不是没原因的。Jvm的性能确实很好，底层的库也很齐全，安装clojure也比较方便，但clojure又引入了leinxxx。不过Java的开发效率毕竟比C高，基于java开发新的语言大概也容易一些。另外就是需要连接数据库等组件都是现成的。这就使得在java上涌现出了很多二次开发的语言。可能，这才是那么多Java实现的根本原因。</p>

<p>但是，个人不太看好就因为用java实现，这些新语言就会被java开发的主流程接纳。道理很简单，混在jvm里面只是有利于复用已有jvm的机器（这点其实也不太重要），好歹部署还算方便，然而对开发而言完全是另学一套，而同时加上的枷锁和限制却更多了。</p>

<p>真的要给java注入活力，最直接了当的办法是让java中调用ruby clojure等，而且是要方便地调用。   伟大语言才会诞生伟大的框架和lib，而现在这种只解决新语言中调用java lib，其实是不利于java王者归来的。只是这条路这些年已经无人深入了。</p>

<p>除了和JVM跳舞令人哭笑不得外，Clojure自身的语法也很难让人爱。基本就是Lisp那套，写啥都已左右括号为主，这样的感觉其实是不太棒的。特别好这口的人除外。这个不是通过教育就能改变的。</p>

<p>所以看了一圈clojure的内容后，觉得这个语言目前还是浅尝辄止为好。</p>

<p>最后，需要提一下的是，这个语言的性能也比较普通。比普通脚本语言快，但比JS V8慢。相较于Scala Haskell，Clojure还是弱了一些。 <br/>
<img src="http://octopresszhangyu.herokuapp.com/images/screen_print/programming_performance.jpg" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prolog]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/06/16/prolog/"/>
    <updated>2013-06-16T22:46:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/06/16/prolog</id>
    <content type="html"><![CDATA[<p>七周七语言看完了Ruby，又继续看了Io，这是一个prototype的语言，确实和js很像，也挺有启发。不过决定还是
好好去学javascript吧。其实<a href="http://www.w3school.com.cn/js/index.asp">w3school</a>的这份js教程很棒，
相当言简意赅。入门是最重要的。入门之后才能走的更远。很多时候究竟有多远看的还是基础，但没有摸起来，那
基本功就无从发挥了。</p>

<p>随后看了<a href="http://www.gprolog.org">Prolog</a>，其实是<strong>gprolog</strong>。
这个语言跟我过去学习的语言都很不一样。完全抛弃了过程语言所拥有的能力，全部都集中在了逻辑判断上。实际上其组成结构是这样的：</p>

<ul>
<li>事实。就是自己先设定一些前提，指定一些事实，比如<code>likes(wallace, cheese).</code></li>
<li>规则。规则就是关于一些事实的推论。比如<code>friend(X, Y) :- \+(X = Y), likes(X, Z), likes(Y, Z).</code>，这个规则由3个条件构成，

<ul>
<li>第一个是X！=Y</li>
<li>第二个和第三个是X和Y都喜欢Z，然后他们就符合friend这条规则</li>
</ul>
</li>
<li>查询。查询就是使用时给出问题，然后让prolog根据规则库（<strong>事实</strong>+<strong>规则</strong>）循环访问得出结果或判断出结果。</li>
</ul>


<p>本质上，应该是用过程语言写了一系列的判断和分析语句（<strong>引擎</strong>）,这样使用时使得编码行为就完全不一样了。</p>

<h3>最大的启发</h3>

<p>最大的启发在于，这一门应该算是我首次学的不是过程式的编程语言。当然，前提是HTML和CSS不能算编程语言。其他的，如C、C++、Java、Ruby、Python、Javascript乃至shell等，虽然有的是纯过程式的，有的是面向对象的，但实际上都<strong>包含了过程式</strong> 的风格。</p>

<h3>试用体验</h3>

<p>还是有点别扭的。它的语法确实很古老，而且很不顺手，这点和<code>erlang</code>有的一拼。
不过确实是只要树立规则，就能输出结果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个App站点的人员组织]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/06/14/the-orgnization-of-an-app-site/"/>
    <updated>2013-06-14T15:08:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/06/14/the-orgnization-of-an-app-site</id>
    <content type="html"><![CDATA[<p>参考了一下残游记的组织与分工，小结如下：</p>

<ul>
<li><p>产品经理，1，老板</p></li>
<li><p>后端开发，1, 技术负责人</p></li>
<li><p>前端，1，解决浏览器兼容等问题, 也可以转app开发，总之就是UI工程师</p></li>
<li><p>视觉设计师，2</p></li>
<li><p>ios开发，1，</p></li>
<li><p>运营，2，应该就是管理员和推销员</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[my first gem]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/06/12/my-first-gem/"/>
    <updated>2013-06-12T17:02:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/06/12/my-first-gem</id>
    <content type="html"><![CDATA[<p>今天终于尝试做了第一个<code>gem</code>，其实挺简单的，至少在有了bundler之后。</p>

<p>先 <code>bundle gem act_as_xxx</code>，随后就可以编辑里面的内容，比如在<code>*.gemspec</code>里面加入描述。编辑好自己的gem后，运行<code>gem build act_as_xxx.gemspec</code>，这样一个新的gem就会编译出来。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  Successfully built RubyGem
</span><span class='line'>  Name: act_as_xxx
</span><span class='line'>  Version: 0.1.1
</span><span class='line'>  File: act_as_xxx-0.1.1.gem</span></code></pre></td></tr></table></div></figure>


<p>最后<code>gem push act_as_xxx-0.1.1.gem</code> 就发布到rubygems.org上面了。</p>

<p>基本的流程是走通了，不过怎么怎么测试怎么调试等还需要进一步摸索。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[7dbs in 7wks]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/06/06/7dbs-in-7wks/"/>
    <updated>2013-06-06T05:59:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/06/06/7dbs-in-7wks</id>
    <content type="html"><![CDATA[<p>花了2个礼拜的时间，看完了七天七数据库。这是又一本在kindle上看完的epub格式的书籍。阅读体验的效果还是很不错的。</p>

<p>书籍受了七天七语言的启发，整本书的胶水语言主要是用了ruby，也伴随使用了一些javascript。作者对redis做了特别多的介绍，HBase等的描述也很精彩。Neo4J对我而言还属新生事物。</p>

<p>这本书区别于其他数据库图书的价值就在于比较与分析，呵呵，话说这个和我的撰文风格挺类似的。</p>

<p>首先，从RDBMS(PostgreSQL)开始，描述了SQL设计时的世界是查询的弹性要求远大于结构的弹性。回想一下，彼时的数据库查询都是由开发人员或者公司信息科的人来完成的，也就是直接使用SQL。而在如今，操作人员全部通过界面，可能是Web也可能是client，SQL都是后台自己拼接而成，于是SQL最强悍的地方其实已经打了折扣。而业务上，甚至统计方面，经常会对schema参数剧烈变化的要求。还有很重要的一点，就是关系型数据库是大家思想统一的东西，沟通方便。<br/>
关系型数据库最大的优势在于acid的操作支持，以及运行多年而证明的稳定可靠。但在大规模访问和灵活性方面确实存在缺陷。</p>

<p>然后，介绍了面向列的数据库。其实面向列就是存放是按照一列一列内容来存放的，有版本和时间戳的自动功能，适合于存放大数据。甚至还有压缩的功能。作者把HBase比喻为钉子气枪（nail gun)。他的每个查询都不快，但最强大之处在于<strong>遍历巨量数据集合</strong>。<br/>
所以常常被大公司用了作为日志和搜索系统。<br/>
column里面存放的是map。<br/>
journaling = write-ahead logging.</p>

<p>Riak是一个key-value数据库，不过更适合存放S3D那样的存放二进制的内容。基于Erlang编写。
N, W, R, N是最终数据需要分发到的节点数量，W是写入多少就可以认为写入成功，R则是读取多少就认为读取成功。</p>

<p>也谈到了这些数据库中实现Map-Reduce的哲学是把算法分发给各个节点，而不是把数据集中起来送给算法。毕竟传输算法肯定比传输数据的开销要少。</p>

<p>MongoDB则是在关系型和扩展性强的数据库中取到了一个黄金百分点。可以存放复杂的对象是文档数据库最大的优势。CouchDB不如MongoDB灵活，采用视图查询法（事先定义map-reduce），</p>

<p>最后，则主要还是介绍redis，及混合的多数据库应用开发。内建的可以让key失效，以及丰富的数据结构数据库，是redis脱颖而出的法宝。使得极其适合作为缓存使用。</p>

<p>小结，过去人们依赖一个数据库来实现多个应用的整合。现在整合的能力更多地交给了中间层模式，往往多种语言都是基于HTTP实现服务层之间的通信的。这样就使得服务程序从db的限制中解脱了出来，变得可以根据需要选用多种数据库组合。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[匆匆半年]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/06/05/cong-cong-ban-nian/"/>
    <updated>2013-06-05T23:10:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/06/05/cong-cong-ban-nian</id>
    <content type="html"><![CDATA[<p>不知不觉，宝宝出生和研究生毕业都已经快半年了。这半年里书是读了不少，事情也做了一些，突破性的的东西还是没有什么。也抽空去做了一个手术。总而言之，辛苦又忙碌的半年吧。</p>

<p>有了宝宝以后，自己的时间少了，晚上好睡的日子也少了，不过看着宝宝健康成长，那么这一切还是很有意义的。</p>

<p>说句实话，这半年过的还不错。只是飙升的体重真的要想办法调整才行了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[前端到底重要不重要]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/06/05/qian-duan-dao-di-zhong-yao-bu-zhong-yao/"/>
    <updated>2013-06-05T21:32:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/06/05/qian-duan-dao-di-zhong-yao-bu-zhong-yao</id>
    <content type="html"><![CDATA[<p>最近发现淘宝的前端大牛似乎想往后端发展，摆脱只做前端的印象；<br/>
另一方面, teahour上的人却认为越来越多的工作从服务器往前端在靠，投入在javascript上面的工作量和时间越来越多。单用围城效应这个不是太能解释的通。</p>

<p>以我个人这段时间的开发经验来看，前端很多事情和很细小，消耗的时间确实很多。比较起来，在这方面花费太多的时间如果能移到后端的话，确实可以完成更多的事情。从Get Things Done的角度而言，前端的意义是不如后端的。毕竟无论界面多么花哨，真正值得关注的还是内容。就像我们去淘宝，不是因为界面有多炫，而是里面的商品价格等吸引着我们。</p>

<p>然而，事情又不那么简单。首先，世上的事情一定要Get Done的讲穿了也不多，如果只盯着最有意义的事情，那么只有长生不老，而这个完成不了的话其实做任何事情最后都是徒劳的。因此，忽视前端的效果是不对的。   其次，前端可以吸引眼球，也和少挨骂有重要相关的作用。虽然吸引我上淘宝的不是其界面，但如果他的界面很傻，那么作为用户还是会骂的。当然，比起完事界面确实是次要的。就像我能忍受12306的界面，只要他能让我订完票能兑现就一切ok。<br/>
还有一点，没有好的前端，服务根本吸引不了人。毕竟大部分人也不会有什么杀手级的内容，这个时候比拼界面反而是能反应团队的水平及做事用心的程度。</p>

<p>所以，我的结论是，如果后端和内容有足够重要的事情，那么还是围绕后端。反之，有余力后可关注前端。毕竟门面功夫也不可小觑。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[折腾记]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/05/25/zhe-teng-ji/"/>
    <updated>2013-05-25T14:35:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/05/25/zhe-teng-ji</id>
    <content type="html"><![CDATA[<p>人总是免不了折腾。用什么虚拟机工具可以折腾，用什么linux发行版本也可以折腾。这些都搞定了，发行墙又来和我们折腾。
Heroku能访问80端口，22端口莫名其妙被封。好歹找了个解决方案，但发现还真是折腾。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软考的名次]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/04/08/ruankao-qian-jiming/"/>
    <updated>2013-04-08T20:36:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/04/08/ruankao-qian-jiming</id>
    <content type="html"><![CDATA[<p>不知为何, 这次软考名次出来的特别晚. 往年2月底3月中旬就都出来了, 这次却直到今天, <a href="http://www.rkb.gov.cn/jsj/cms/s_contents/download/s_dt2013040802.html">4月8日才将将公布</a>. 可能是好事多磨吧.</p>

<p>尽管知道自己的成绩有望排进前50, 甚至前十前五都很正常, 不过最后的名次还是让我激动了一小把.</p>

<p><img src="http://octopresszhangyu.herokuapp.com/images/screen_print/ruankaopaimin.png" alt="image" /></p>

<p>必须得说, 这个名次还真的是挺高的.</p>

<p>这个好名次献给我亲爱的外婆.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim and lampbrother]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/04/05/vim-and-lampbroter/"/>
    <updated>2013-04-05T11:34:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/04/05/vim-and-lampbroter</id>
    <content type="html"><![CDATA[<p>中了vim的毒之后, 开始学起了vim. 这东西在windows下也能用,而且扩展性极佳, 确实值得学学. 添加syntax和
snippet都极其简单, 如果还要写代码的话, 确实值得掌握. 主要是发现这个工具就是给我这类人用的.</p>

<p>台湾人的视频太简单, 很多基础的东西没有讲好, 好处就是他是按照git加载众多挂件之后演示并授课的, 所以
比较吸引人. 但光那些显然也不够, 而且他本身也不算很熟练. 于是开始找其他视频. 找了一圈以后, 发现了
<a href="http://www.lampbrother.net/">lamp兄弟连</a>的视频. 我个人比较喜欢里面李强强的linux课程. 另一位稍早录制
的李阳的linux视频也很不错. 这家培训机构感觉还是很不错的, 培养的确实是业界最急需的一线工人.不过他的培训主要
针对全脱产的、尤其是那些正要找工作的20岁出头的年轻人, 我是挺难报他们的班. 毕竟不太可能有什么时间和精力能够
连续坐在实验机房里一整天. 而且这样的效率其实也不高.</p>

<p>然后顺便看了一下RHCE和RHCA. 发现lampbrother的课程基本是按RHCE的脉络来的, 这门课其实可以直接改为通过RHCE.
RHCE的范围基本如下:</p>

<ul>
<li>Hardware installation and configuration</li>
<li>The boot process</li>
<li>Linux filesystem administration</li>
<li>Package management and Kickstart</li>
<li>User and group administration</li>
<li>System administration tools</li>
<li>Kernel services and configuration</li>
<li>Apache and Squid</li>
<li>Network file sharing services (NFS, FTP, and Samba)</li>
<li>Domain Name System (DNS)</li>
<li>E-mail (servers and clients)</li>
<li>Extended Internet Services Daemon (xinetd), the Secure package, and DHCP</li>
<li>The X Window System</li>
<li>Firewalls, SELinux, and troubleshooting</li>
</ul>


<p>只是这家机构的目的培训直接能工作的学生而不是考证为主的, 猜测因此没有开这门课吧. 课程的那些实验都会做的话,基本也就可以当一个称职的系统管理员了.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oracle的价格]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/03/28/the-price-of-oracle/"/>
    <updated>2013-03-28T14:57:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/03/28/the-price-of-oracle</id>
    <content type="html"><![CDATA[<p>不少人应该对Oracle的报价是好奇的，研究了一番之后，发现Oracle的报价无论在商务上还是使用策略上都可以称之为出奇的<strong>成功</strong>.</p>

<h3>Oracle的数据库种类</h3>

<p>Oracle的数据库讲穿了只有一套，但又分成ee、se等几个版本。而这些都可以提供免费试用。
通过免费可以培养用户群，降低工程师的雇佣成本。通过划分版本，又可以执行价格策略，抢占不同的市场。</p>

<h3>Oracle的单价种类</h3>

<p>Oracle的单价基本可以分为按User和按CPU卖。User的话是一个自然人或者设备。CPU就是按装机卖了。</p>

<p>下面是一些价格举例，单位都是美刀
按用户： {企业版： 950，se: 350, seo: 180}
按cpu: {企业版：47500， se：17500，seo：5800}</p>

<h3>Oracle的起步license概念</h3>

<p>显然，按user大部分情况下应该比较便宜。所以，邪恶的oracle又有了最小license数量的概念。比如，企业版最低的user数就是25，se则是5，以此来保证oracle的收入。</p>

<h3>折扣</h3>

<p>以上只是目录价，一般通过代理买，获得一半的折扣是没有多少问题的。如果是大客户的话，还可以更加优惠。</p>

<p>最后，说一下关于DataGuard的事情。有说是免费的，也有说是付费的。在10g的ee版本中，这个确实已经包含了。</p>

<blockquote><p>Data Guard supports both physical standby and logical standby sites. Oracle Corporation makes Data Guard available only as a bundled feature included within its &#8220;Enterprise Edition&#8221; of the Oracle RDBMS.</p></blockquote>

<p>所以，10g ee里面的ODG肯定是免费的，因为已经买过单了。</p>

<blockquote><p>The &#8220;Oracle Active Data Guard&#8221; option, an extra-cost facility,[4] extends Oracle Data Guard physical standby functionality in Oracle 11g configurations. It allows read-only access on the standby node at the same time as applying archived transactions from the primary node.[5]</p></blockquote>

<p>然后，在11g里面，又推出了Active Data Guard，二者在技术上有什么区别还没研究过，但在付费上这是一个可选包。目录价200/user.</p>

<p>参考资料：</p>

<ol>
<li><p><a href="http://www.oracle.com/us/corporate/pricing/technology-price-list-070617.pdf">oracle price list</a></p></li>
<li><p><a href="http://en.wikipedia.org/wiki/Oracle_Data_Guard">oracle data guard wiki</a></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么ruby不火仍然值得学]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/03/24/wei-shi-yao-rubybu-huo-reng-ran-zhi-de-xue/"/>
    <updated>2013-03-24T16:14:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/03/24/wei-shi-yao-rubybu-huo-reng-ran-zhi-de-xue</id>
    <content type="html"><![CDATA[<p>从某些角度而言，这本不是问题，毕竟因为什么东西火就去学习什么东西的话，那么学与不学什么就无需再计较了。世上总有火的和流行的东西，仅就IT而言，Java火了很多年，这几年安卓 iOS的开发者的需求也很旺盛。如果想学火的东西，那么尽可以去学这些。一旦一样一个东西不怎么火，<strong>反而更可以看出大家为什么要学它。</strong></p>

<p>喜欢ruby可以有多个理由，特别是在rails引进门之后。在我看来，可以有以下几点。</p>

<h3>1. 简单</h3>

<p>换个术语可以叫做用户友好。ruby确实是简单的，相对于C、JavaScript而言。当然，ruby也可以用的很复杂，只是那通常是不需要进入的。</p>

<h3>2. 方便</h3>

<p>这是所有脚本语言的特长，写起来比较方便，不啰嗦。Java也很简单，但是太啰嗦，还需要编译等，所以我还是倾向于在辅助任务中使用ruby而非java。
方便的另一个同义词是表达力强。拥有的表达方式多，而且够简短，即信息量高。</p>

<h3>3.程序员（IT人员）的朋友</h3>

<p>和友好性不同，这是指真的可以用来作为日常工作的工具，用IT技术解决自己工作中的问题。而不仅仅是用IT技术解决客户等其他人的问题。</p>

<h3>4. Rails</h3>

<p>不可忽视，很多人是因为Rails才接触了ruby。至于为什么要学Rails，那可以单独再开一片文章了。大体上是因为Rails的先进和效率。但是，Rails
的引入<strong>大大提高了学习曲线</strong>。Ruby是简单的，不过加进Rails，那就复杂了。
不过如果想用Rails，想通过Rails学习东西，学习一些好的实践和想法，就必须去学习Ruby。</p>

<p>以上是我对ruby不够火的回答。希望学习火的东西人可以去学当前热门的那些东西。Java太平常的话，那就iOS开发、安卓开发，这些都是大面积缺人的。当然，我揣测提问者心里真实的想法是：
现在学ruby是希望今后有一天她能火，然后自己就可以抬高身价。而这东西既然始终不火，那似乎就没有投资学习的必要。</p>

<p>对于这种想法，自然是没有问题的。关键还是在于有没有其他的投资方向。如果有而且看准了，自然可以去新的方向。我们不是Mats也不是DHH，即使是学ruby的人离开也不会有很大的损失，何况本来就持观望态度的人呢？</p>

<p>如果是想靠web技术发财，那么最重要的还是棒个好的创业伙伴，技术此时是次要的，业务和产品才是关键。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sass and Compass]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/03/16/sass-and-compass/"/>
    <updated>2013-03-16T21:29:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/03/16/sass-and-compass</id>
    <content type="html"><![CDATA[<p>Sass 和　Compass闻名已久，也接触过一些，不过始终没有仔细学过。这次因为要做移动互联页面的东西，又开始接触这部分内容。
看了下《Pragmatic Guide to Sass》, 理清了一下脉络。
顺便提一句，这本书是在kindle上看的，出版社和作者提供了epub的版本。  这可以算是第一本在kindle上看完的计算机技术类书籍。虽然效果还可以，
但是看了下原书的pdf版本，发现其版本也深受“小书”，小版面，的影响。这可能是未来计算机书籍的一个趋势吧。不过kindle还是最适合纯文字，
用来阅读计算机技术书籍的体验还是很一般。</p>

<p>Sass是最基础的，类似coffeeScript对Css的改写，当然引入的内容要多的多。毕竟js本身也是一种语言，但css很难算的上是一门编程语言。
Sass有自己的运行命令，由ruby实现，可以把scss文件编译成css文件，也能convert回去。</p>

<p>Compass则是sass的库和扩展，在sass的基础上提供了更丰富的样式、函数和变量以及模式。其本身也有了一套命令，也更适合于建项目。Sass如果是java，
那么compass就是J2EE+Eclipse。</p>

<p>如果不想安装那么多东西，那么可以直接使用scout这个GUI工具，工具本身集成了sass和compass的能力，只是又提供了图形化的集成界面。该界面可能是基于
Adobe的桌面技术编写的。如果要推荐美工使用sass，那么可以从scout入手。</p>

<p>compass是很神奇的，而它的spriting堪称神奇中的神奇。</p>

<p>但我发觉设计也是有天赋和术业专攻的。我们的美工完全不用这些东西，也很快就能搞出一个各种android上面看过去还不错的版本，我用这些东西去写出来的还是感觉很累。但至少比没有要好多了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[notes of matz on Ruby 2.0 at herokus waza]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/03/08/notes-of-matz-on-ruby-2-dot-0-at-herokus-waza/"/>
    <updated>2013-03-08T11:15:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/03/08/notes-of-matz-on-ruby-2-dot-0-at-herokus-waza</id>
    <content type="html"><![CDATA[<p><a href="https://speakerdeck.com/yukihiro_matz/ruby-2-dot-0-en">Mats Ruby 2.0</a>
的笔记。</p>

<p>首先讲了Ruby的历史</p>

<ul>
<li>Dec 1995 0.95</li>
<li>Dec 1996 1.0</li>
<li>Aug 1997 1.1</li>
<li>Dec 1998 1.2</li>
<li>Aug 1999 1.4</li>
<li>Sep 2000 1.6</li>
</ul>


<p>以上是节假日驱动开发，后来改成了周年纪念开发，呵呵。</p>

<p>voccation-driven development<br/>
Anniversary-driven development</p>

<ul>
<li>Aug 2003 1.8</li>
<li>Dec 2007 1.9.0</li>
<li>Aug 2010 1.9.2</li>
<li>Oct 2011 1.9.3</li>
<li>Feb 2013 2.0.0</li>
</ul>


<p>2.0版最早是在Ruby Conf 2001提出，包括</p>

<ul>
<li>new GC</li>
<li>native Thread with GIL</li>
<li>有些特性后来放弃了</li>
</ul>


<p>2.0的发布带来了：</p>

<ul>
<li>New Hash literals</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  {foo: 1, bar: 2} =&gt; {:foo=&gt;1, :bar=&gt;2}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>keyword arguments</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  def log(msg, level: "ERROR", time: Time.now)
</span><span class='line'>    puts "..."
</span><span class='line'>  end
</span><span class='line'>  
</span><span class='line'>  # existing hash passing
</span><span class='line'>  log("Hello!", **hash)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Module#prepend, alias method chain, from CommonLisp</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#prepend put them before to wrap methods
</span><span class='line'>class Foo
</span><span class='line'>  def foo; p :foo; end
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>module Prepend
</span><span class='line'>  def foo
</span><span class='line'>    p :before
</span><span class='line'>    super
</span><span class='line'>    p :after
</span><span class='line'>  end
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>class Foo
</span><span class='line'>  prepend Prepend # just as include Prepend
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>Foo.new.foo
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>refine，to constrain open class, scoped monkey patching</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>module R
</span><span class='line'>  refine String do
</span><span class='line'>    def foo
</span><span class='line'>      puts "aaa"
</span><span class='line'>    end
</span><span class='line'>  end
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>"".foo # =&gt; error!
</span><span class='line'>
</span><span class='line'>using R
</span><span class='line'>"".foo</span></code></pre></td></tr></table></div></figure>


<p>Java 和 Smalltalk有classbox的概念，也与此类似</p>

<ul>
<li>Enumerable#lazy， 受函数式编程影响</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(1..Float::INFINITY).lazy.map {|i|
</span><span class='line'>  i.to_s
</span><span class='line'>}.select {|s|
</span><span class='line'>  /3/ === s
</span><span class='line'>}.first(500000)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Symbol array literals</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>%i(foo bar baz) =&gt; [:foo, :bar, :baz]</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>to_h, to_hash</p></li>
<li><p>UTF-8 by default</p></li>
<li><p>Performance Faster:</p>

<ul>
<li>VM(YARV)</li>
<li>GC</li>
<li>require</li>
</ul>
</li>
</ul>


<p>Ruby 2.1 maybe 25.12.2013</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deploy a Rails 4 app to Heroku]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/03/04/deploy-a-rails-4-app-to-heroku/"/>
    <updated>2013-03-04T20:03:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/03/04/deploy-a-rails-4-app-to-heroku</id>
    <content type="html"><![CDATA[<p>近期从<code>rvm</code>切换到了<code>rbenv</code>, ruby也全面升级到了2.0.0版本， Rails也装了4.0.0.beta，似乎一切欣欣向荣的样子。<br/>
为了方便测试获取一些设备的浏览器信息，写了一个自动获取并分析<code>User-Agent</code>的应用，并确定发布到heroku上。
在发布的过程中，发现还是有一些陷阱，也差不多被折腾了一个来小时,所以决定记录一下。</p>

<h3>0 事先准备</h3>

<p>虽然我用Heroku的时间可以追溯到很久以前，从 scanty 到 octopress，但到这次才发现其实之前我没在heroku上部署过Rails应用。
但这也意味着，第一我很早以前就有了Heroku的帐号，第二我的机器上的ssh-key同heroku都是打通的，第三已经安装了heroku这个gem。</p>

<h3>1 创建应用</h3>

<p>首先执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>heroku apps:create user-agent-show2
</span></code></pre></td></tr></table></div></figure>


<p>这样会在heroku处创建一个stack，目前版本是<code>cedar</code>. 同时，在.git/config里面会增加一个heroku分支</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[remote "heroku"]
</span><span class='line'>        url = git@heroku.com:user-agent-show.git
</span><span class='line'>        fetch = +refs/heads/*:refs/remotes/heroku/*</span></code></pre></td></tr></table></div></figure>


<h3>2 Git push</h3>

<p>随后就可以执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git push heroku</span></code></pre></td></tr></table></div></figure>


<p>部署应用了。
但这里就会碰到陷阱。首先，Heroku是支持pg的应用，所以需要在Gemfile里增加<code>gem 'pg'</code>，同时也要确保这个gem在本机有依赖的Native包。对于ubuntu，
基本需要安装<code>apt-get install libpq-dev</code> 这个包，不过这个包很小，只有900多KB。</p>

<p>其次，对于assets，可以选择预先执行<code>rake assets:precompile</code>，也可也让heroku在部署时执行。但默认情况下生成的js和css文件是访问不到的。
因为rails 4默认生成environments/production.rb中是这样配置的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>config.serve_static_assets = false</span></code></pre></td></tr></table></div></figure>


<p>这个会导致thin或者unicorn不负责对静态文件的处理。如果是基于Nginx或者Apache之类的部署，这点毫无问题，因为代理在收到请求后就处理掉了，但
对于heroku，则在起初时是必须由thin负责这部分内容的，因此需要把上面的配置改成</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>config.serve_static_assets = true</span></code></pre></td></tr></table></div></figure>


<p>这样才能保证静态文件被正常访问。</p>

<h3>3 数据库更新</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>heroku run rake db:migrate</span></code></pre></td></tr></table></div></figure>


<p>push成功后，就可以执行迁移了。也能执行<code>heroku run bash</code> 等命令去查看云服务器的实际运行情况。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Change To Ruby 2 Dot 0 0]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/02/26/change-to-ruby-2-dot-0-0/"/>
    <updated>2013-02-26T00:00:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/02/26/change-to-ruby-2-dot-0-0</id>
    <content type="html"><![CDATA[<p>layout: post
title: &#8220;Change to Ruby 2.0.0&#8221;
date: 2013-02-26 11:30
comments: true
categories:
- ruby
- heroku</p>

<hr />

<p>借着Ruby 2.0.0发布的东风，又加之Rails 也发布了4.0.beta来给献礼，营造了RR24，我也把octopress升级到了ruby 2.0.0.</p>

<p>步骤如下：</p>

<ol>
<li>在Gemfile中加入 <code>ruby "2.0.0"</code></li>
<li>更新Gemfile中其他的一些gem，把octopress最新版的内容加进来即可，否则可能还是不能和2.0兼容的</li>
<li><code>bundle intall</code>, <code>bundle install --binstubs</code></li>
<li><code>git commit -a</code></li>
<li><code>git push heroku</code></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Counting objects: 119, done.
</span><span class='line'>Compressing objects: 100% (59/59), done.
</span><span class='line'>Writing objects: 100% (60/60), 5.46 KiB, done.
</span><span class='line'>Total 60 (delta 32), reused 0 (delta 0)
</span><span class='line'>-----&gt; Deleting 5 files matching .slugignore patterns.
</span><span class='line'>-----&gt; Ruby/Rack app detected
</span><span class='line'>-----&gt; Using Ruby version: ruby-2.0.0
</span><span class='line'>-----&gt; Installing dependencies using Bundler version 1.3.0.pre.5
</span><span class='line'>       Ruby version change detected. Clearing bundler cache.
</span><span class='line'>       Old: ruby 1.9.2p290 (2011-07-09 revision 32553) [x86_64-linux]
</span><span class='line'>       New: ruby 2.0.0p0 (2013-02-24 revision 39474) [x86_64-linux]
</span><span class='line'>       Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin --deployment
</span><span class='line'>       Fetching gem metadata from http://ruby.taobao.org/.
</span><span class='line'>       Fetching full source index from http://ruby.taobao.org/
</span><span class='line'>       Installing daemons (1.1.8)
</span><span class='line'>       Installing eventmachine (0.12.10)
</span><span class='line'>       Installing rack (1.4.1)
</span><span class='line'>       Installing rack-protection (1.3.2)
</span><span class='line'>       Installing tilt (1.3.3)
</span><span class='line'>       Installing sinatra (1.3.5)
</span><span class='line'>       Installing thin (1.4.1)
</span><span class='line'>       Using bundler (1.3.0.pre.5)
</span><span class='line'>       Your bundle is complete! It was installed into ./vendor/bundle
</span><span class='line'>       Cleaning up the bundler cache.
</span><span class='line'>-----&gt; Discovering process types
</span><span class='line'>       Procfile declares types     -&gt; (none)
</span><span class='line'>       Default types for Ruby/Rack -&gt; console, rake, web
</span><span class='line'>
</span><span class='line'>-----&gt; Compiled slug size: 30.5MB
</span><span class='line'>-----&gt; Launching... done, v48</span></code></pre></td></tr></table></div></figure>


<p>但我不太理解slug size为啥变大了。</p>

<p>而且和thin里面的eventmachine配合似乎有问题，可能是版本太老，也可能是别的什么，
于是改用了unicorn，又折腾了Procfile</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>web: bundle exec unicorn -p $PORT</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Total 3 (delta 1), reused 0 (delta 0)
</span><span class='line'>-----&gt; Deleting 5 files matching .slugignore patterns.
</span><span class='line'>-----&gt; Ruby/Rack app detected
</span><span class='line'>-----&gt; Using Ruby version: ruby-2.0.0
</span><span class='line'>-----&gt; Installing dependencies using Bundler version 1.3.0.pre.5
</span><span class='line'>       Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin --deployment
</span><span class='line'>       Using kgio (2.8.0)
</span><span class='line'>       Using rack (1.4.5)
</span><span class='line'>       Using rack-protection (1.3.2)
</span><span class='line'>       Using raindrops (0.10.0)
</span><span class='line'>       Using tilt (1.3.3)
</span><span class='line'>       Using sinatra (1.3.5)
</span><span class='line'>       Using unicorn (4.6.2)
</span><span class='line'>       Using bundler (1.3.0.pre.5)
</span><span class='line'>       Your bundle is complete! It was installed into ./vendor/bundle
</span><span class='line'>       Cleaning up the bundler cache.
</span><span class='line'>       Would have removed thin (1.4.1)
</span><span class='line'>       Would have removed daemons (1.1.9)
</span><span class='line'>       Would have removed daemons (1.1.8)
</span><span class='line'>       Would have removed thin (1.5.0)
</span><span class='line'>       Would have removed rack (1.4.1)
</span><span class='line'>       Would have removed eventmachine (1.0.0)
</span><span class='line'>       Would have removed eventmachine (0.12.10)
</span><span class='line'>-----&gt; Discovering process types
</span><span class='line'>       Procfile declares types     -&gt; web
</span><span class='line'>       Default types for Ruby/Rack -&gt; console, rake
</span><span class='line'>
</span><span class='line'>-----&gt; Compiled slug size: 35.9MB
</span><span class='line'>-----&gt; Launching... done, v53</span></code></pre></td></tr></table></div></figure>


<p>最后重新弄了一下，发现还是很大。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Writing objects: 100% (3/3), 281 bytes, done.
</span><span class='line'>Total 3 (delta 2), reused 0 (delta 0)
</span><span class='line'>-----&gt; Deleting 5 files matching .slugignore patterns.
</span><span class='line'>-----&gt; Ruby/Rack app detected
</span><span class='line'>-----&gt; Using Ruby version: ruby-2.0.0
</span><span class='line'>-----&gt; Installing dependencies using Bundler version 1.3.0.pre.5
</span><span class='line'>       Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin --deployment
</span><span class='line'>       Using kgio (2.8.0)
</span><span class='line'>       Using rack (1.4.5)
</span><span class='line'>       Using rack-protection (1.3.2)
</span><span class='line'>       Using raindrops (0.10.0)
</span><span class='line'>       Using tilt (1.3.3)
</span><span class='line'>       Using sinatra (1.3.5)
</span><span class='line'>       Using unicorn (4.6.2)
</span><span class='line'>       Using bundler (1.3.0.pre.5)
</span><span class='line'>       Your bundle is complete! It was installed into ./vendor/bundle
</span><span class='line'>       Cleaning up the bundler cache.
</span><span class='line'>-----&gt; Discovering process types
</span><span class='line'>       Procfile declares types     -&gt; web
</span><span class='line'>       Default types for Ruby/Rack -&gt; console, rake
</span><span class='line'>
</span><span class='line'>-----&gt; Compiled slug size: 27.3MB
</span><span class='line'>-----&gt; Launching... done, v5
</span><span class='line'>       http://octopresszhangyu.herokuapp.com deployed to Heroku</span></code></pre></td></tr></table></div></figure>


<p>感觉adam不再怎么发文之后，Heroku有点日趋堕落的趋势。另外，在Procfile里面运用unicorn绝对是个好主义。其效果类似一个dyno(ubuntu)上跑了几个unicorn的进程，
明显处理能力会强于只有一个实例的thin。以上灵感来自<a href="http://blog.codeship.io/2012/05/06/Unicorn-on-Heroku.html">unicorn的部署高人</a>。</p>

<p>今日装某个系统，发现有掉到了libyaml这个沟里。试了几次，最后发现是 <code>LD_LIBRARY_PATH=</code>的缘故。
编译好libyaml，在加入到上面这个环境变量中，ruby才能读的出来。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[About AWK]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/02/19/about-awk/"/>
    <updated>2013-02-19T14:52:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/02/19/about-awk</id>
    <content type="html"><![CDATA[<p>受 <a href="http://coolshell.cn/articles/9070.html">AWK简明教程</a> 的影响，学习了一下仰慕已久却始终不得要领的AWK，
甚至还下载了著名的科尔尼汉写的《The AWK programming Language》并看完了第一章和后面的一些内容。</p>

<p>学习之后，发现这个东西其实还是很简洁的，同bash的配合确实很好，在某些应用场合下，处理文本、截取文本、调整文本，的确是利器。
但是，也必须注意到，这个东西确实已经是上古一代的东西了。不是说上古的东西就一定使用价值降低，不过AWK的作用和处理范围
已经大大地被Python和Ruby侵占。在Unix/C之下，他是足够简便的，对bash是很好的补充。如今已经是Ruby Python这些
script流行的年代，而这些脚本语言可以很大程度上替代AWK。AWK保留的优势仅仅是最简单的场合下，比如<code>{print $1}</code>之类时
显得足够简洁的优势。稍微复杂一些，如循环、分支判断一多，就显得不如Ruby Python了。</p>

<p>所以，看AWK的第一章以及简明教程就足够了。因为基本上也只要用到这些最简单的应用，写出优雅的bash命令。是用来写程序<strong>命令</strong>而不是程序<strong>文件</strong>。</p>
]]></content>
  </entry>
  
</feed>
