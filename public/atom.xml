<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2013-07-05T17:12:06+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Prolog]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/06/16/prolog/"/>
    <updated>2013-06-16T22:46:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/06/16/prolog</id>
    <content type="html"><![CDATA[<p>七周七语言看完了Ruby，又继续看了Io，这是一个prototype的语言，确实和js很像，也挺有启发。不过决定还是
好好去学javascript吧。其实<a href="http://www.w3school.com.cn/js/index.asp">w3school</a>的这份js教程很棒，
相当言简意赅。入门是最重要的。入门之后才能走的更远。很多时候究竟有多远看的还是基础，但没有摸起来，那
基本功就无从发挥了。</p>

<p>随后看了<a href="http://www.gprolog.org">Prolog</a>，其实是<strong>gprolog</strong>。
这个语言跟我过去学习的语言都很不一样。完全抛弃了过程语言所拥有的能力，全部都集中在了逻辑判断上。实际上其组成结构是这样的：</p>

<ul>
<li>事实。就是自己先设定一些前提，指定一些事实，比如<code>likes(wallace, cheese).</code></li>
<li>规则。规则就是关于一些事实的推论。比如<code>friend(X, Y) :- \+(X = Y), likes(X, Z), likes(Y, Z).</code>，这个规则由3个条件构成，

<ul>
<li>第一个是X！=Y</li>
<li>第二个和第三个是X和Y都喜欢Z，然后他们就符合friend这条规则</li>
</ul>
</li>
<li>查询。查询就是使用时给出问题，然后让prolog根据规则库（<strong>事实</strong>+<strong>规则</strong>）循环访问得出结果或判断出结果。</li>
</ul>


<p>本质上，应该是用过程语言写了一系列的判断和分析语句（<strong>引擎</strong>）,这样使用时使得编码行为就完全不一样了。</p>

<h3>最大的启发</h3>

<p>最大的启发在于，这一门应该算是我首次学的不是过程式的编程语言。当然，前提是HTML和CSS不能算编程语言。其他的，如C、C++、Java、Ruby、Python、Javascript乃至shell等，虽然有的是纯过程式的，有的是面向对象的，但实际上都<strong>包含了过程式</strong> 的风格。</p>

<h3>试用体验</h3>

<p>还是有点别扭的。它的语法确实很古老，而且很不顺手，这点和<code>erlang</code>有的一拼。
不过确实是只要树立规则，就能输出结果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个App站点的人员组织]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/06/14/the-orgnization-of-an-app-site/"/>
    <updated>2013-06-14T15:08:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/06/14/the-orgnization-of-an-app-site</id>
    <content type="html"><![CDATA[<p>参考了一下残游记的组织与分工，小结如下：</p>

<ul>
<li><p>产品经理，1，老板</p></li>
<li><p>后端开发，1, 技术负责人</p></li>
<li><p>前端，1，解决浏览器兼容等问题, 也可以转app开发，总之就是UI工程师</p></li>
<li><p>视觉设计师，2</p></li>
<li><p>ios开发，1，</p></li>
<li><p>运营，2，应该就是管理员和推销员</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[my first gem]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/06/12/my-first-gem/"/>
    <updated>2013-06-12T17:02:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/06/12/my-first-gem</id>
    <content type="html"><![CDATA[<p>今天终于尝试做了第一个<code>gem</code>，其实挺简单的，至少在有了bundler之后。</p>

<p>先 <code>bundle gem act_as_xxx</code>，随后就可以编辑里面的内容，比如在<code>*.gemspec</code>里面加入描述。编辑好自己的gem后，运行<code>gem build act_as_xxx.gemspec</code>，这样一个新的gem就会编译出来。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  Successfully built RubyGem
</span><span class='line'>  Name: act_as_xxx
</span><span class='line'>  Version: 0.1.1
</span><span class='line'>  File: act_as_xxx-0.1.1.gem</span></code></pre></td></tr></table></div></figure>


<p>最后<code>gem push act_as_xxx-0.1.1.gem</code> 就发布到rubygems.org上面了。</p>

<p>基本的流程是走通了，不过怎么怎么测试怎么调试等还需要进一步摸索。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[7dbs in 7wks]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/06/06/7dbs-in-7wks/"/>
    <updated>2013-06-06T05:59:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/06/06/7dbs-in-7wks</id>
    <content type="html"><![CDATA[<p>花了2个礼拜的时间，看完了七天七数据库。这是又一本在kindle上看完的epub格式的书籍。阅读体验的效果还是很不错的。</p>

<p>书籍受了七天七语言的启发，整本书的胶水语言主要是用了ruby，也伴随使用了一些javascript。作者对redis做了特别多的介绍，HBase等的描述也很精彩。Neo4J对我而言还属新生事物。</p>

<p>这本书区别于其他数据库图书的价值就在于比较与分析，呵呵，话说这个和我的撰文风格挺类似的。</p>

<p>首先，从RDBMS(PostgreSQL)开始，描述了SQL设计时的世界是查询的弹性要求远大于结构的弹性。回想一下，彼时的数据库查询都是由开发人员或者公司信息科的人来完成的，也就是直接使用SQL。而在如今，操作人员全部通过界面，可能是Web也可能是client，SQL都是后台自己拼接而成，于是SQL最强悍的地方其实已经打了折扣。而业务上，甚至统计方面，经常会对schema参数剧烈变化的要求。还有很重要的一点，就是关系型数据库是大家思想统一的东西，沟通方便。<br/>
关系型数据库最大的优势在于acid的操作支持，以及运行多年而证明的稳定可靠。但在大规模访问和灵活性方面确实存在缺陷。</p>

<p>然后，介绍了面向列的数据库。其实面向列就是存放是按照一列一列内容来存放的，有版本和时间戳的自动功能，适合于存放大数据。甚至还有压缩的功能。作者把HBase比喻为钉子气枪（nail gun)。他的每个查询都不快，但最强大之处在于<strong>遍历巨量数据集合</strong>。<br/>
所以常常被大公司用了作为日志和搜索系统。<br/>
column里面存放的是map。<br/>
journaling = write-ahead logging.</p>

<p>Riak是一个key-value数据库，不过更适合存放S3D那样的存放二进制的内容。基于Erlang编写。
N, W, R, N是最终数据需要分发到的节点数量，W是写入多少就可以认为写入成功，R则是读取多少就认为读取成功。</p>

<p>也谈到了这些数据库中实现Map-Reduce的哲学是把算法分发给各个节点，而不是把数据集中起来送给算法。毕竟传输算法肯定比传输数据的开销要少。</p>

<p>MongoDB则是在关系型和扩展性强的数据库中取到了一个黄金百分点。可以存放复杂的对象是文档数据库最大的优势。CouchDB不如MongoDB灵活，采用视图查询法（事先定义map-reduce），</p>

<p>最后，则主要还是介绍redis，及混合的多数据库应用开发。内建的可以让key失效，以及丰富的数据结构数据库，是redis脱颖而出的法宝。使得极其适合作为缓存使用。</p>

<p>小结，过去人们依赖一个数据库来实现多个应用的整合。现在整合的能力更多地交给了中间层模式，往往多种语言都是基于HTTP实现服务层之间的通信的。这样就使得服务程序从db的限制中解脱了出来，变得可以根据需要选用多种数据库组合。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[匆匆半年]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/06/05/cong-cong-ban-nian/"/>
    <updated>2013-06-05T23:10:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/06/05/cong-cong-ban-nian</id>
    <content type="html"><![CDATA[<p>不知不觉，宝宝出生和研究生毕业都已经快半年了。这半年里书是读了不少，事情也做了一些，突破性的的东西还是没有什么。也抽空去做了一个手术。总而言之，辛苦又忙碌的半年吧。</p>

<p>有了宝宝以后，自己的时间少了，晚上好睡的日子也少了，不过看着宝宝健康成长，那么这一切还是很有意义的。</p>

<p>说句实话，这半年过的还不错。只是飙升的体重真的要想办法调整才行了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[前端到底重要不重要]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/06/05/qian-duan-dao-di-zhong-yao-bu-zhong-yao/"/>
    <updated>2013-06-05T21:32:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/06/05/qian-duan-dao-di-zhong-yao-bu-zhong-yao</id>
    <content type="html"><![CDATA[<p>最近发现淘宝的前端大牛似乎想往后端发展，摆脱只做前端的印象；<br/>
另一方面, teahour上的人却认为越来越多的工作从服务器往前端在靠，投入在javascript上面的工作量和时间越来越多。单用围城效应这个不是太能解释的通。</p>

<p>以我个人这段时间的开发经验来看，前端很多事情和很细小，消耗的时间确实很多。比较起来，在这方面花费太多的时间如果能移到后端的话，确实可以完成更多的事情。从Get Things Done的角度而言，前端的意义是不如后端的。毕竟无论界面多么花哨，真正值得关注的还是内容。就像我们去淘宝，不是因为界面有多炫，而是里面的商品价格等吸引着我们。</p>

<p>然而，事情又不那么简单。首先，世上的事情一定要Get Done的讲穿了也不多，如果只盯着最有意义的事情，那么只有长生不老，而这个完成不了的话其实做任何事情最后都是徒劳的。因此，忽视前端的效果是不对的。   其次，前端可以吸引眼球，也和少挨骂有重要相关的作用。虽然吸引我上淘宝的不是其界面，但如果他的界面很傻，那么作为用户还是会骂的。当然，比起完事界面确实是次要的。就像我能忍受12306的界面，只要他能让我订完票能兑现就一切ok。<br/>
还有一点，没有好的前端，服务根本吸引不了人。毕竟大部分人也不会有什么杀手级的内容，这个时候比拼界面反而是能反应团队的水平及做事用心的程度。</p>

<p>所以，我的结论是，如果后端和内容有足够重要的事情，那么还是围绕后端。反之，有余力后可关注前端。毕竟门面功夫也不可小觑。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[折腾记]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/05/25/zhe-teng-ji/"/>
    <updated>2013-05-25T14:35:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/05/25/zhe-teng-ji</id>
    <content type="html"><![CDATA[<p>人总是免不了折腾。用什么虚拟机工具可以折腾，用什么linux发行版本也可以折腾。这些都搞定了，发行墙又来和我们折腾。
Heroku能访问80端口，22端口莫名其妙被封。好歹找了个解决方案，但发现还真是折腾。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软考的名次]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/04/08/ruankao-qian-jiming/"/>
    <updated>2013-04-08T20:36:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/04/08/ruankao-qian-jiming</id>
    <content type="html"><![CDATA[<p>不知为何, 这次软考名次出来的特别晚. 往年2月底3月中旬就都出来了, 这次却直到今天, <a href="http://www.rkb.gov.cn/jsj/cms/s_contents/download/s_dt2013040802.html">4月8日才将将公布</a>. 可能是好事多磨吧.</p>

<p>尽管知道自己的成绩有望排进前50, 甚至前十前五都很正常, 不过最后的名次还是让我激动了一小把.</p>

<p><img src="http://octopresszhangyu.herokuapp.com/images/screen_print/ruankaopaimin.png" alt="image" /></p>

<p>必须得说, 这个名次还真的是挺高的.</p>

<p>这个好名次献给我亲爱的外婆.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim and lampbrother]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/04/05/vim-and-lampbroter/"/>
    <updated>2013-04-05T11:34:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/04/05/vim-and-lampbroter</id>
    <content type="html"><![CDATA[<p>中了vim的毒之后, 开始学起了vim. 这东西在windows下也能用,而且扩展性极佳, 确实值得学学. 添加syntax和
snippet都极其简单, 如果还要写代码的话, 确实值得掌握. 主要是发现这个工具就是给我这类人用的.</p>

<p>台湾人的视频太简单, 很多基础的东西没有讲好, 好处就是他是按照git加载众多挂件之后演示并授课的, 所以
比较吸引人. 但光那些显然也不够, 而且他本身也不算很熟练. 于是开始找其他视频. 找了一圈以后, 发现了
<a href="http://www.lampbrother.net/">lamp兄弟连</a>的视频. 我个人比较喜欢里面李强强的linux课程. 另一位稍早录制
的李阳的linux视频也很不错. 这家培训机构感觉还是很不错的, 培养的确实是业界最急需的一线工人.不过他的培训主要
针对全脱产的、尤其是那些正要找工作的20岁出头的年轻人, 我是挺难报他们的班. 毕竟不太可能有什么时间和精力能够
连续坐在实验机房里一整天. 而且这样的效率其实也不高.</p>

<p>然后顺便看了一下RHCE和RHCA. 发现lampbrother的课程基本是按RHCE的脉络来的, 这门课其实可以直接改为通过RHCE.
RHCE的范围基本如下:</p>

<ul>
<li>Hardware installation and configuration</li>
<li>The boot process</li>
<li>Linux filesystem administration</li>
<li>Package management and Kickstart</li>
<li>User and group administration</li>
<li>System administration tools</li>
<li>Kernel services and configuration</li>
<li>Apache and Squid</li>
<li>Network file sharing services (NFS, FTP, and Samba)</li>
<li>Domain Name System (DNS)</li>
<li>E-mail (servers and clients)</li>
<li>Extended Internet Services Daemon (xinetd), the Secure package, and DHCP</li>
<li>The X Window System</li>
<li>Firewalls, SELinux, and troubleshooting</li>
</ul>


<p>只是这家机构的目的培训直接能工作的学生而不是考证为主的, 猜测因此没有开这门课吧. 课程的那些实验都会做的话,基本也就可以当一个称职的系统管理员了.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oracle的价格]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/03/28/the-price-of-oracle/"/>
    <updated>2013-03-28T14:57:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/03/28/the-price-of-oracle</id>
    <content type="html"><![CDATA[<p>不少人应该对Oracle的报价是好奇的，研究了一番之后，发现Oracle的报价无论在商务上还是使用策略上都可以称之为出奇的<strong>成功</strong>.</p>

<h3>Oracle的数据库种类</h3>

<p>Oracle的数据库讲穿了只有一套，但又分成ee、se等几个版本。而这些都可以提供免费试用。
通过免费可以培养用户群，降低工程师的雇佣成本。通过划分版本，又可以执行价格策略，抢占不同的市场。</p>

<h3>Oracle的单价种类</h3>

<p>Oracle的单价基本可以分为按User和按CPU卖。User的话是一个自然人或者设备。CPU就是按装机卖了。</p>

<p>下面是一些价格举例，单位都是美刀
按用户： {企业版： 950，se: 350, seo: 180}
按cpu: {企业版：47500， se：17500，seo：5800}</p>

<h3>Oracle的起步license概念</h3>

<p>显然，按user大部分情况下应该比较便宜。所以，邪恶的oracle又有了最小license数量的概念。比如，企业版最低的user数就是25，se则是5，以此来保证oracle的收入。</p>

<h3>折扣</h3>

<p>以上只是目录价，一般通过代理买，获得一半的折扣是没有多少问题的。如果是大客户的话，还可以更加优惠。</p>

<p>最后，说一下关于DataGuard的事情。有说是免费的，也有说是付费的。在10g的ee版本中，这个确实已经包含了。</p>

<blockquote><p>Data Guard supports both physical standby and logical standby sites. Oracle Corporation makes Data Guard available only as a bundled feature included within its &#8220;Enterprise Edition&#8221; of the Oracle RDBMS.</p></blockquote>

<p>所以，10g ee里面的ODG肯定是免费的，因为已经买过单了。</p>

<blockquote><p>The &#8220;Oracle Active Data Guard&#8221; option, an extra-cost facility,[4] extends Oracle Data Guard physical standby functionality in Oracle 11g configurations. It allows read-only access on the standby node at the same time as applying archived transactions from the primary node.[5]</p></blockquote>

<p>然后，在11g里面，又推出了Active Data Guard，二者在技术上有什么区别还没研究过，但在付费上这是一个可选包。目录价200/user.</p>

<p>参考资料：</p>

<ol>
<li><p><a href="http://www.oracle.com/us/corporate/pricing/technology-price-list-070617.pdf">oracle price list</a></p></li>
<li><p><a href="http://en.wikipedia.org/wiki/Oracle_Data_Guard">oracle data guard wiki</a></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么ruby不火仍然值得学]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/03/24/wei-shi-yao-rubybu-huo-reng-ran-zhi-de-xue/"/>
    <updated>2013-03-24T16:14:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/03/24/wei-shi-yao-rubybu-huo-reng-ran-zhi-de-xue</id>
    <content type="html"><![CDATA[<p>从某些角度而言，这本不是问题，毕竟因为什么东西火就去学习什么东西的话，那么学与不学什么就无需再计较了。世上总有火的和流行的东西，仅就IT而言，Java火了很多年，这几年安卓 iOS的开发者的需求也很旺盛。如果想学火的东西，那么尽可以去学这些。一旦一样一个东西不怎么火，<strong>反而更可以看出大家为什么要学它。</strong></p>

<p>喜欢ruby可以有多个理由，特别是在rails引进门之后。在我看来，可以有以下几点。</p>

<h3>1. 简单</h3>

<p>换个术语可以叫做用户友好。ruby确实是简单的，相对于C、JavaScript而言。当然，ruby也可以用的很复杂，只是那通常是不需要进入的。</p>

<h3>2. 方便</h3>

<p>这是所有脚本语言的特长，写起来比较方便，不啰嗦。Java也很简单，但是太啰嗦，还需要编译等，所以我还是倾向于在辅助任务中使用ruby而非java。
方便的另一个同义词是表达力强。拥有的表达方式多，而且够简短，即信息量高。</p>

<h3>3.程序员（IT人员）的朋友</h3>

<p>和友好性不同，这是指真的可以用来作为日常工作的工具，用IT技术解决自己工作中的问题。而不仅仅是用IT技术解决客户等其他人的问题。</p>

<h3>4. Rails</h3>

<p>不可忽视，很多人是因为Rails才接触了ruby。至于为什么要学Rails，那可以单独再开一片文章了。大体上是因为Rails的先进和效率。但是，Rails
的引入<strong>大大提高了学习曲线</strong>。Ruby是简单的，不过加进Rails，那就复杂了。
不过如果想用Rails，想通过Rails学习东西，学习一些好的实践和想法，就必须去学习Ruby。</p>

<p>以上是我对ruby不够火的回答。希望学习火的东西人可以去学当前热门的那些东西。Java太平常的话，那就iOS开发、安卓开发，这些都是大面积缺人的。当然，我揣测提问者心里真实的想法是：
现在学ruby是希望今后有一天她能火，然后自己就可以抬高身价。而这东西既然始终不火，那似乎就没有投资学习的必要。</p>

<p>对于这种想法，自然是没有问题的。关键还是在于有没有其他的投资方向。如果有而且看准了，自然可以去新的方向。我们不是Mats也不是DHH，即使是学ruby的人离开也不会有很大的损失，何况本来就持观望态度的人呢？</p>

<p>如果是想靠web技术发财，那么最重要的还是棒个好的创业伙伴，技术此时是次要的，业务和产品才是关键。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sass and Compass]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/03/16/sass-and-compass/"/>
    <updated>2013-03-16T21:29:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/03/16/sass-and-compass</id>
    <content type="html"><![CDATA[<p>Sass 和　Compass闻名已久，也接触过一些，不过始终没有仔细学过。这次因为要做移动互联页面的东西，又开始接触这部分内容。
看了下《Pragmatic Guide to Sass》, 理清了一下脉络。
顺便提一句，这本书是在kindle上看的，出版社和作者提供了epub的版本。  这可以算是第一本在kindle上看完的计算机技术类书籍。虽然效果还可以，
但是看了下原书的pdf版本，发现其版本也深受“小书”，小版面，的影响。这可能是未来计算机书籍的一个趋势吧。不过kindle还是最适合纯文字，
用来阅读计算机技术书籍的体验还是很一般。</p>

<p>Sass是最基础的，类似coffeeScript对Css的改写，当然引入的内容要多的多。毕竟js本身也是一种语言，但css很难算的上是一门编程语言。
Sass有自己的运行命令，由ruby实现，可以把scss文件编译成css文件，也能convert回去。</p>

<p>Compass则是sass的库和扩展，在sass的基础上提供了更丰富的样式、函数和变量以及模式。其本身也有了一套命令，也更适合于建项目。Sass如果是java，
那么compass就是J2EE+Eclipse。</p>

<p>如果不想安装那么多东西，那么可以直接使用scout这个GUI工具，工具本身集成了sass和compass的能力，只是又提供了图形化的集成界面。该界面可能是基于
Adobe的桌面技术编写的。如果要推荐美工使用sass，那么可以从scout入手。</p>

<p>compass是很神奇的，而它的spriting堪称神奇中的神奇。</p>

<p>但我发觉设计也是有天赋和术业专攻的。我们的美工完全不用这些东西，也很快就能搞出一个各种android上面看过去还不错的版本，我用这些东西去写出来的还是感觉很累。但至少比没有要好多了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[notes of matz on Ruby 2.0 at herokus waza]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/03/08/notes-of-matz-on-ruby-2-dot-0-at-herokus-waza/"/>
    <updated>2013-03-08T11:15:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/03/08/notes-of-matz-on-ruby-2-dot-0-at-herokus-waza</id>
    <content type="html"><![CDATA[<p><a href="https://speakerdeck.com/yukihiro_matz/ruby-2-dot-0-en">Mats Ruby 2.0</a>
的笔记。</p>

<p>首先讲了Ruby的历史</p>

<ul>
<li>Dec 1995 0.95</li>
<li>Dec 1996 1.0</li>
<li>Aug 1997 1.1</li>
<li>Dec 1998 1.2</li>
<li>Aug 1999 1.4</li>
<li>Sep 2000 1.6</li>
</ul>


<p>以上是节假日驱动开发，后来改成了周年纪念开发，呵呵。</p>

<p>voccation-driven development<br/>
Anniversary-driven development</p>

<ul>
<li>Aug 2003 1.8</li>
<li>Dec 2007 1.9.0</li>
<li>Aug 2010 1.9.2</li>
<li>Oct 2011 1.9.3</li>
<li>Feb 2013 2.0.0</li>
</ul>


<p>2.0版最早是在Ruby Conf 2001提出，包括</p>

<ul>
<li>new GC</li>
<li>native Thread with GIL</li>
<li>有些特性后来放弃了</li>
</ul>


<p>2.0的发布带来了：</p>

<ul>
<li>New Hash literals</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  {foo: 1, bar: 2} =&gt; {:foo=&gt;1, :bar=&gt;2}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>keyword arguments</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  def log(msg, level: "ERROR", time: Time.now)
</span><span class='line'>    puts "..."
</span><span class='line'>  end
</span><span class='line'>  
</span><span class='line'>  # existing hash passing
</span><span class='line'>  log("Hello!", **hash)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Module#prepend, alias method chain, from CommonLisp</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#prepend put them before to wrap methods
</span><span class='line'>class Foo
</span><span class='line'>  def foo; p :foo; end
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>module Prepend
</span><span class='line'>  def foo
</span><span class='line'>    p :before
</span><span class='line'>    super
</span><span class='line'>    p :after
</span><span class='line'>  end
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>class Foo
</span><span class='line'>  prepend Prepend # just as include Prepend
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>Foo.new.foo
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>refine，to constrain open class, scoped monkey patching</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>module R
</span><span class='line'>  refine String do
</span><span class='line'>    def foo
</span><span class='line'>      puts "aaa"
</span><span class='line'>    end
</span><span class='line'>  end
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>"".foo # =&gt; error!
</span><span class='line'>
</span><span class='line'>using R
</span><span class='line'>"".foo</span></code></pre></td></tr></table></div></figure>


<p>Java 和 Smalltalk有classbox的概念，也与此类似</p>

<ul>
<li>Enumerable#lazy， 受函数式编程影响</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(1..Float::INFINITY).lazy.map {|i|
</span><span class='line'>  i.to_s
</span><span class='line'>}.select {|s|
</span><span class='line'>  /3/ === s
</span><span class='line'>}.first(500000)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Symbol array literals</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>%i(foo bar baz) =&gt; [:foo, :bar, :baz]</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>to_h, to_hash</p></li>
<li><p>UTF-8 by default</p></li>
<li><p>Performance Faster:</p>

<ul>
<li>VM(YARV)</li>
<li>GC</li>
<li>require</li>
</ul>
</li>
</ul>


<p>Ruby 2.1 maybe 25.12.2013</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deploy a Rails 4 app to Heroku]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/03/04/deploy-a-rails-4-app-to-heroku/"/>
    <updated>2013-03-04T20:03:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/03/04/deploy-a-rails-4-app-to-heroku</id>
    <content type="html"><![CDATA[<p>近期从<code>rvm</code>切换到了<code>rbenv</code>, ruby也全面升级到了2.0.0版本， Rails也装了4.0.0.beta，似乎一切欣欣向荣的样子。<br/>
为了方便测试获取一些设备的浏览器信息，写了一个自动获取并分析<code>User-Agent</code>的应用，并确定发布到heroku上。
在发布的过程中，发现还是有一些陷阱，也差不多被折腾了一个来小时,所以决定记录一下。</p>

<h3>0 事先准备</h3>

<p>虽然我用Heroku的时间可以追溯到很久以前，从 scanty 到 octopress，但到这次才发现其实之前我没在heroku上部署过Rails应用。
但这也意味着，第一我很早以前就有了Heroku的帐号，第二我的机器上的ssh-key同heroku都是打通的，第三已经安装了heroku这个gem。</p>

<h3>1 创建应用</h3>

<p>首先执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>heroku apps:create user-agent-show2
</span></code></pre></td></tr></table></div></figure>


<p>这样会在heroku处创建一个stack，目前版本是<code>cedar</code>. 同时，在.git/config里面会增加一个heroku分支</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[remote "heroku"]
</span><span class='line'>        url = git@heroku.com:user-agent-show.git
</span><span class='line'>        fetch = +refs/heads/*:refs/remotes/heroku/*</span></code></pre></td></tr></table></div></figure>


<h3>2 Git push</h3>

<p>随后就可以执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git push heroku</span></code></pre></td></tr></table></div></figure>


<p>部署应用了。
但这里就会碰到陷阱。首先，Heroku是支持pg的应用，所以需要在Gemfile里增加<code>gem 'pg'</code>，同时也要确保这个gem在本机有依赖的Native包。对于ubuntu，
基本需要安装<code>apt-get install libpq-dev</code> 这个包，不过这个包很小，只有900多KB。</p>

<p>其次，对于assets，可以选择预先执行<code>rake assets:precompile</code>，也可也让heroku在部署时执行。但默认情况下生成的js和css文件是访问不到的。
因为rails 4默认生成environments/production.rb中是这样配置的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>config.serve_static_assets = false</span></code></pre></td></tr></table></div></figure>


<p>这个会导致thin或者unicorn不负责对静态文件的处理。如果是基于Nginx或者Apache之类的部署，这点毫无问题，因为代理在收到请求后就处理掉了，但
对于heroku，则在起初时是必须由thin负责这部分内容的，因此需要把上面的配置改成</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>config.serve_static_assets = true</span></code></pre></td></tr></table></div></figure>


<p>这样才能保证静态文件被正常访问。</p>

<h3>3 数据库更新</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>heroku run rake db:migrate</span></code></pre></td></tr></table></div></figure>


<p>push成功后，就可以执行迁移了。也能执行<code>heroku run bash</code> 等命令去查看云服务器的实际运行情况。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Change To Ruby 2 Dot 0 0]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/02/26/change-to-ruby-2-dot-0-0/"/>
    <updated>2013-02-26T00:00:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/02/26/change-to-ruby-2-dot-0-0</id>
    <content type="html"><![CDATA[<p>layout: post
title: &#8220;Change to Ruby 2.0.0&#8221;
date: 2013-02-26 11:30
comments: true
categories:
- ruby
- heroku</p>

<hr />

<p>借着Ruby 2.0.0发布的东风，又加之Rails 也发布了4.0.beta来给献礼，营造了RR24，我也把octopress升级到了ruby 2.0.0.</p>

<p>步骤如下：</p>

<ol>
<li>在Gemfile中加入 <code>ruby "2.0.0"</code></li>
<li>更新Gemfile中其他的一些gem，把octopress最新版的内容加进来即可，否则可能还是不能和2.0兼容的</li>
<li><code>bundle intall</code>, <code>bundle install --binstubs</code></li>
<li><code>git commit -a</code></li>
<li><code>git push heroku</code></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Counting objects: 119, done.
</span><span class='line'>Compressing objects: 100% (59/59), done.
</span><span class='line'>Writing objects: 100% (60/60), 5.46 KiB, done.
</span><span class='line'>Total 60 (delta 32), reused 0 (delta 0)
</span><span class='line'>-----&gt; Deleting 5 files matching .slugignore patterns.
</span><span class='line'>-----&gt; Ruby/Rack app detected
</span><span class='line'>-----&gt; Using Ruby version: ruby-2.0.0
</span><span class='line'>-----&gt; Installing dependencies using Bundler version 1.3.0.pre.5
</span><span class='line'>       Ruby version change detected. Clearing bundler cache.
</span><span class='line'>       Old: ruby 1.9.2p290 (2011-07-09 revision 32553) [x86_64-linux]
</span><span class='line'>       New: ruby 2.0.0p0 (2013-02-24 revision 39474) [x86_64-linux]
</span><span class='line'>       Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin --deployment
</span><span class='line'>       Fetching gem metadata from http://ruby.taobao.org/.
</span><span class='line'>       Fetching full source index from http://ruby.taobao.org/
</span><span class='line'>       Installing daemons (1.1.8)
</span><span class='line'>       Installing eventmachine (0.12.10)
</span><span class='line'>       Installing rack (1.4.1)
</span><span class='line'>       Installing rack-protection (1.3.2)
</span><span class='line'>       Installing tilt (1.3.3)
</span><span class='line'>       Installing sinatra (1.3.5)
</span><span class='line'>       Installing thin (1.4.1)
</span><span class='line'>       Using bundler (1.3.0.pre.5)
</span><span class='line'>       Your bundle is complete! It was installed into ./vendor/bundle
</span><span class='line'>       Cleaning up the bundler cache.
</span><span class='line'>-----&gt; Discovering process types
</span><span class='line'>       Procfile declares types     -&gt; (none)
</span><span class='line'>       Default types for Ruby/Rack -&gt; console, rake, web
</span><span class='line'>
</span><span class='line'>-----&gt; Compiled slug size: 30.5MB
</span><span class='line'>-----&gt; Launching... done, v48</span></code></pre></td></tr></table></div></figure>


<p>但我不太理解slug size为啥变大了。</p>

<p>而且和thin里面的eventmachine配合似乎有问题，可能是版本太老，也可能是别的什么，
于是改用了unicorn，又折腾了Procfile</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>web: bundle exec unicorn -p $PORT</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Total 3 (delta 1), reused 0 (delta 0)
</span><span class='line'>-----&gt; Deleting 5 files matching .slugignore patterns.
</span><span class='line'>-----&gt; Ruby/Rack app detected
</span><span class='line'>-----&gt; Using Ruby version: ruby-2.0.0
</span><span class='line'>-----&gt; Installing dependencies using Bundler version 1.3.0.pre.5
</span><span class='line'>       Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin --deployment
</span><span class='line'>       Using kgio (2.8.0)
</span><span class='line'>       Using rack (1.4.5)
</span><span class='line'>       Using rack-protection (1.3.2)
</span><span class='line'>       Using raindrops (0.10.0)
</span><span class='line'>       Using tilt (1.3.3)
</span><span class='line'>       Using sinatra (1.3.5)
</span><span class='line'>       Using unicorn (4.6.2)
</span><span class='line'>       Using bundler (1.3.0.pre.5)
</span><span class='line'>       Your bundle is complete! It was installed into ./vendor/bundle
</span><span class='line'>       Cleaning up the bundler cache.
</span><span class='line'>       Would have removed thin (1.4.1)
</span><span class='line'>       Would have removed daemons (1.1.9)
</span><span class='line'>       Would have removed daemons (1.1.8)
</span><span class='line'>       Would have removed thin (1.5.0)
</span><span class='line'>       Would have removed rack (1.4.1)
</span><span class='line'>       Would have removed eventmachine (1.0.0)
</span><span class='line'>       Would have removed eventmachine (0.12.10)
</span><span class='line'>-----&gt; Discovering process types
</span><span class='line'>       Procfile declares types     -&gt; web
</span><span class='line'>       Default types for Ruby/Rack -&gt; console, rake
</span><span class='line'>
</span><span class='line'>-----&gt; Compiled slug size: 35.9MB
</span><span class='line'>-----&gt; Launching... done, v53</span></code></pre></td></tr></table></div></figure>


<p>最后重新弄了一下，发现还是很大。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Writing objects: 100% (3/3), 281 bytes, done.
</span><span class='line'>Total 3 (delta 2), reused 0 (delta 0)
</span><span class='line'>-----&gt; Deleting 5 files matching .slugignore patterns.
</span><span class='line'>-----&gt; Ruby/Rack app detected
</span><span class='line'>-----&gt; Using Ruby version: ruby-2.0.0
</span><span class='line'>-----&gt; Installing dependencies using Bundler version 1.3.0.pre.5
</span><span class='line'>       Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin --deployment
</span><span class='line'>       Using kgio (2.8.0)
</span><span class='line'>       Using rack (1.4.5)
</span><span class='line'>       Using rack-protection (1.3.2)
</span><span class='line'>       Using raindrops (0.10.0)
</span><span class='line'>       Using tilt (1.3.3)
</span><span class='line'>       Using sinatra (1.3.5)
</span><span class='line'>       Using unicorn (4.6.2)
</span><span class='line'>       Using bundler (1.3.0.pre.5)
</span><span class='line'>       Your bundle is complete! It was installed into ./vendor/bundle
</span><span class='line'>       Cleaning up the bundler cache.
</span><span class='line'>-----&gt; Discovering process types
</span><span class='line'>       Procfile declares types     -&gt; web
</span><span class='line'>       Default types for Ruby/Rack -&gt; console, rake
</span><span class='line'>
</span><span class='line'>-----&gt; Compiled slug size: 27.3MB
</span><span class='line'>-----&gt; Launching... done, v5
</span><span class='line'>       http://octopresszhangyu.herokuapp.com deployed to Heroku</span></code></pre></td></tr></table></div></figure>


<p>感觉adam不再怎么发文之后，Heroku有点日趋堕落的趋势。另外，在Procfile里面运用unicorn绝对是个好主义。其效果类似一个dyno(ubuntu)上跑了几个unicorn的进程，
明显处理能力会强于只有一个实例的thin。以上灵感来自<a href="http://blog.codeship.io/2012/05/06/Unicorn-on-Heroku.html">unicorn的部署高人</a>。</p>

<p>今日装某个系统，发现有掉到了libyaml这个沟里。试了几次，最后发现是 <code>LD_LIBRARY_PATH=</code>的缘故。
编译好libyaml，在加入到上面这个环境变量中，ruby才能读的出来。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[About AWK]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/02/19/about-awk/"/>
    <updated>2013-02-19T14:52:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/02/19/about-awk</id>
    <content type="html"><![CDATA[<p>受 <a href="http://coolshell.cn/articles/9070.html">AWK简明教程</a> 的影响，学习了一下仰慕已久却始终不得要领的AWK，
甚至还下载了著名的科尔尼汉写的《The AWK programming Language》并看完了第一章和后面的一些内容。</p>

<p>学习之后，发现这个东西其实还是很简洁的，同bash的配合确实很好，在某些应用场合下，处理文本、截取文本、调整文本，的确是利器。
但是，也必须注意到，这个东西确实已经是上古一代的东西了。不是说上古的东西就一定使用价值降低，不过AWK的作用和处理范围
已经大大地被Python和Ruby侵占。在Unix/C之下，他是足够简便的，对bash是很好的补充。如今已经是Ruby Python这些
script流行的年代，而这些脚本语言可以很大程度上替代AWK。AWK保留的优势仅仅是最简单的场合下，比如<code>{print $1}</code>之类时
显得足够简洁的优势。稍微复杂一些，如循环、分支判断一多，就显得不如Ruby Python了。</p>

<p>所以，看AWK的第一章以及简明教程就足够了。因为基本上也只要用到这些最简单的应用，写出优雅的bash命令。是用来写程序<strong>命令</strong>而不是程序<strong>文件</strong>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[期刊读后感]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/02/09/journal-of-computer-application/"/>
    <updated>2013-02-09T16:45:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/02/09/journal-of-computer-application</id>
    <content type="html"><![CDATA[<p>读了去年年底订阅的《计算机应用》，发现还是有一些文章是值得一读的。
订阅这个杂志是因为觉得发文速度还算快，期刊和文章的档次也还不错。看了2013年第2期，里面还是有六七篇很有收获的文章的。
必须承认的是，期刊文章的质量普遍比网上的资料要高。</p>

<p>按钱学森的理论，做研究的一大秘诀是阅读文献，因为大部分问题肯定都有人面对过，从中获取启发再进行突破才能取得更好的效果。
这个理论对计算机也是适用的，实际上信息技术里面阅读文献的效果要超过其他工程专业。毕竟信息行业里思路和实现之间的差距
比其他的要短的多。</p>

<p>虽然已经是互联网时代，但要探索自己未知的还是离不开杂志的。首先搜索的素材的一大来源就是期刊，搜索本身并不制造内容，内容的一大制造者
就是期刊。尽管现在网上的博客、科技文章等素材已经很广阔，但其质量普遍还是不如期刊的。原因在于发表期刊真的是挺难的，你给拿出自己的
拿手好戏才行，没有的点真东西期刊的编辑是不会买账的。质量普遍较高是期刊的第二大优势，毕竟既要自己花钱又有审稿者和编辑把关，质量高于
网上的其他资料是很正常的。最重要的，只有期刊才能让你可能接触自己不熟悉的东西。搜索是目的性很明显的阅读方式。但当你没有明确的方向时
搜索是帮不上忙的。而高质量的期刊可以弥补搜索的这个弱点。虽然你要忍受一堆可能没有用或者自己读不进去的内容，但总的来说，产出投入比
还是很大的，还是很值得这么做的。我阅读了一期，就有了以下几点收获：</p>

<ol>
<li>对基站提供的定位信息的应用有了新的认识。原来还可以用来跟踪用户的行动路径，为换乘乃至规划和其他促销活动提供依据。</li>
<li>均衡服务可以使用HiCuts算法，其实就是一种决策树，在分类时可以使用，丰富自己的分类依据，以前主要也就是有个hash的概念。</li>
<li>小波算法其实和取log差不多，最大的意义在于提高监测值可感知效果。</li>
<li>聚类后对数据特征值的取顶叫做概化，可以是平均值，也可以是区间。</li>
<li>网页防篡改分远程和本地两种，远程的把内容按动态和静态区分应该也算一个思路。话说我的第一个防篡改方案也是看期刊获得灵感。</li>
<li>排班优化原来也是人工智能的一部分。</li>
<li>网管软件的组件可以按主站、代理、代理数据信息、网管协议4个组件来进行组织，对写此类文章有了更好的心得，毕竟描述一个系统要写成期刊是很难的。</li>
</ol>


<p>短短时间，收获已经很多。</p>

<p>不过期刊也有不足之处。最大的问题可能在于计算机期刊的文章刊出时间都太长了。投稿半年内能读到的已经是凤毛麟角，一年以上是常态，
最nb的期刊基本要3年。套用一句俗话，这好像是和一个25岁的2个孩子的妈谈恋爱，不新鲜的东西往往有时候就没使用价值了。从这点上来讲，计算机应用和
计算机系统应用都做的很不错。</p>

<p>还有一点，就是计算机应用里面也包含了大量计算机科学的内容。因为科学两个字，搞得天下计算机从业者往往都喜欢套数学，这个也是阻碍业界接受期刊的一大障碍吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[patch and diff]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/02/05/patch-and-diff/"/>
    <updated>2013-02-05T10:52:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/02/05/patch-and-diff</id>
    <content type="html"><![CDATA[<p>patch和diff确实是个神奇的东西，用来对现有版本的升级是最好不过了。
好处在于一来不用停业务，二来可以明确到底改了多少东西。</p>

<h3>diff</h3>

<p>首先来说说diff，毕竟patch是从此处产生。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>diff -ruNa src dest  &gt; a.patch
</span><span class='line'>
</span><span class='line'>-r 针对整个目录  
</span><span class='line'>-u 以合并的方式来显示文件内容的不同
</span><span class='line'>-N 新文件做空白文件
</span><span class='line'>-a 包含二进制内容，如jar包，class等</span></code></pre></td></tr></table></div></figure>


<p>据说这个东西是perl的发明者创建的工具，主要用于比较源码，通常不带<code>-a</code>。</p>

<h3>patch</h3>

<p>patch就比较强大了。如果是更改一个目录下面，最常见的做法是进入该目录，然后执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>patch -p1 &lt; ../a.patch </span></code></pre></td></tr></table></div></figure>


<p>随后，两个目录就会变得一模一样了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Should we try to pursue a master degree]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/02/03/should-we-try-to-pursue-a-master-degree/"/>
    <updated>2013-02-03T15:23:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/02/03/should-we-try-to-pursue-a-master-degree</id>
    <content type="html"><![CDATA[<p>当我还在高中时，是否需要读一个硕士学位根本不是一个问题。因为我当时很明确地不想。以当时的认知水平，如果进一个名牌大学的热门专业，基本可以解决
毕业后的生计问题。彼时的大学生也根本不怎么考虑找工作或者市场需求的事情。因为总人数也就是如今本科生的七分之一，比如今的研究生总数也多不出多少。
在这样的轻压下，就业不愁，很多人也是没有攻读硕士文凭的想法的。</p>

<p>但是，在我读本科至毕业期间，又是研究生和本科生的待遇差别最大的那几年。那应该是考研竞争最激烈的几年，于是动过考研的念头。然而，在我了解了实验室师兄们的研究生生活后，
我又打消了考研的念头。为什么？</p>

<p>第一，是给导师打工的感觉并不好。被压榨的比较厉害。这一点和现在是有区别的，现在因为研究生大量扩招，很多老师其实也不需要那么多学生干活，或者说
人多了每个人能做的事情和出的力气只能降低。而在那时候，一个研究生的工作压力还是很大的。而同样的压力下，自然是公司给的钱更多。出于经济的考虑，自然
应当选择工作。第二，在专业能力方面，如果是无所事事只是读书，那么进步很慢，个人也只会感觉到自己啥都不会。虽然就业时一般把自己卖的还不错，但自己
的本事自己最清楚。当然，公司老板不是傻瓜，卖的好也有卖的好的道理。如果是干老板的打工的活，那和自己直接去公司中接触现实项目没区别。研究生所带来的
起点高，是以损失两三年时间等换来的。之所以自己感觉研究生的待遇比本科生好许多，一大因素是当时没把年纪和时间的因素权衡好。总之，读研在此时显得
意义不大。</p>

<p>但是，在内心深处，自己又是想拥有研究生的文凭的。毕竟对一个书呆子而言，有没有这样一个东西绝非毫无意义的事情。如前所说，大学几年读完，意志品质
增强，但个人并没有什么创造财富的技能。虽然行情不错，自己知道自己实际上并没有为公司、为社会创造财富的能力，做不出什么社会上需要的东西。中国的
知识分子往往不在意现实世界的问题，更多的是关心自己这个圈子和世界里的问题，自己在这个相对封闭的环境中所取得的成绩和title等。</p>

<p>而到如今，择业的机会也更多了，光凭一个研究生文凭能不能找到好的工作也变得两说。当然，优秀学校的研究生还是很热门的，毕竟这部分资源是难得的。这
也是过去的名牌大学本科生即使啥都不会，但还是很有行情的根本原因&#8212;&#8211;优秀的智力资源当然哪里都是需要的，世界上总有现实的问题需要聪明人才能解决。而
一个好大学的研究生往往还是具备这种能力，毕竟国家替公司先选择过一回了。</p>

<p>所以，读了研究生的同学，其竞争力和未来所能取得的成绩和生活水平应该还是会高于本科生的平均水平。尤其对于想进入体制内的企业的年轻人而言。可能对于
互联网小型公司有没有硕士文凭真的不重要，对体制内的单位，包括银行、石油、电力等，从事这些单位的IT工作，攻读出来的研究生学位还是很有用的。
这些单位的待遇也不错，我国又是公有经济为主的国度，去这些巨头研究生的文凭将很有用处。比如本系的研究生1/4左右会去银行，但本系的本科生去银行的比例
要低得多了，银行又是目前的优势行业，如果定位自己想去做金融业的IT，那么研究生文凭会派上很大的用场。<br/>
即使有些人对体制内的企业不感兴趣，那么只要你是去大公司，是去巨头，那么研究生文凭都将是有用处的。哪怕是淘宝、腾讯和百度，研究生的机会和起点都
仍然比本科生好许多。当然，需要你有一个不错的学校，好学校的招牌也很重要。</p>

<p>前面已经说了，如今的时代也是机会多多的时代。很多需要处理实际问题的地方，对学历确实是无所谓的，如果你有特殊技能或者能力真的特别强。这部分能力当然也不是学校能教会的，
这些能力来自自己的业余项目以及自己的实践。如果有如此能力，又想赚到大钱的话，完全可以本科毕业就找一个认得准的公司开干。如何认准呢？这个就看你积累的
能力了。如果你也认不准，那么就只能碰运气了。抱定这个想法的话，也是可以过得不错的。现实中已经有大量的IT技术小杰是其他专业转过来的，他们的背景和
资质不少也没有特殊之处，但也可以取得很不错的成绩。这就是现实给他们的机会造就了他们。</p>

<p>而对于又想和体制打交道，又想不给导师打很多工就拿到硕士文凭的，那么还是学我吧。</p>

<p>总之，如今的社会还是一个相对开明的，机会也不是没有，除了住房，大部分需求都还能够通过自己的努力获得。没有硕士文凭也可以做出正经事情。虽然硕士文凭
是有用的，但干活和工作也是很正经的事情，而且是来自现实世界的正经事情。硕士文凭在去体制内和大公司的时候特别有用，而且越大就越有用。如果想去大公司
那么可以读的还是去读一个吧。如果想靠自己闯的，那么建议大二大三稍稍有空闲时间即可实际接触现实世界的项目和技术。真的做到的话，竞争力会强于大部分
研究生，当然，现实是大部分本科生是做不到的，所以他们大部分也比不上硕士研究生。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Every language will implement a lisp interpreter in itself]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/02/03/every-language-will-implement-a-lisp-interpreter-in-itself/"/>
    <updated>2013-02-03T12:48:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/02/03/every-language-will-implement-a-lisp-interpreter-in-itself</id>
    <content type="html"><![CDATA[<p>H&amp;P里面这句话起初还有点琢磨不过来，后来看了下jstl等东西，这不就是表达式在java中的一个实现么。</p>

<p>从头开始讲的话，需要从web开发讲起。Web中最耗开发时间的是页面的开发，因为在这个环节一切编程的好东西都是没有引入的。比如C的头文件有include检察，
而css依然一团乱；其他语言有的各类引用机制，到了页面全部木有。而在页面上的代码，主要有下面两种模式：</p>

<ul>
<li><code>&lt;% %&gt;</code> <code>&lt;%= %&gt;</code>这样的代码嵌入</li>
<li>代码标签及各类膜拜，如jstl标签，struts2标签，velocity模板等</li>
</ul>


<p>仔细观察，可以发现第二种代码标签和模板其实就是实现了一套语言解析器。往往Java的就用Java实现，有些语言就用自己的实现。
正好印证了Paul的话。为了应付实际的表达困难，表达力弱一些的语言不得不自建一套<strong>类Lisp的语言表达解释器</strong>。</p>

<p>所以，表达力越差（可以理解成
啰嗦、信息量低）的语言，其搭配的解释器可能越五花八门，因为<code>&lt;% %&gt;</code>是很难适应这类语言嵌入在Html中的需求的。而能力强的语言，则模板就要少许多，
因为语言本身的表达力强大，使得再造一套标签显得很没有必要，自然也就无人发明此类模板。</p>

<p>从表达力而言，Java确实较次些。按Paul的理论那就Ruby更接近Lisp。</p>
]]></content>
  </entry>
  
</feed>
