<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: java | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2014-10-06T21:23:59+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java 和 Javascript的RSA]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/09/19/java-he-javascriptde-rsa/"/>
    <updated>2014-09-19T13:57:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/09/19/java-he-javascriptde-rsa</id>
    <content type="html"><![CDATA[<p>近来安全问题日益被重视，通过HTTP传输的部分数据也有了加密的需求。虽然最到位的办法肯定是HTTPS，但证书的申请是比较麻烦的。所以，还是决定
通过diy的方式，将浏览器中的部分敏感数据加密后再传给服务器。</p>

<p>说到加密算法，主要是对称或不对称，可逆或不可逆。最保险的当然是不可逆的密文传输，但是部分业务获得不可逆的密文后无法处理，只能选择可逆的形式。
而在浏览器中加密，显然用对称加密方式就不合适了。所以最后选择了RSA。既是不对称的也是可解密的。</p>

<p>这件事情里面，最麻烦的就是rsa的算法是java和javascript分别实现的。客户端的加密别无选择，只有js胜任。服务端主要提供给现有服务使用，因此主要就是Java。
而让两者配合，则是需要花费些功夫的。网上尽管资料不少，但讲清楚之间配合的很少。</p>

<h2>Javascript中的RSA</h2>

<p>Java的加密算法之前已经用过多次，了解了一下js的rsa算法，还真的有不少，最后选了一个大家提到的比较多的<a href="http://www.ohdave.com/rsa/">ras in javascript</a>。
在html中使用的代码如下:</p>

<p>```html
<html>
<head></p>

<pre><code>&lt;meta charset="UTF-8"&gt;
&lt;title&gt;JavaScript RSA&lt;/title&gt;
&lt;script type="text/javascript" src="http://www.ohdave.com/rsa/BigInt.js"&gt;&lt;/script&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://www.ohdave.com/rsa/RSA.js"&gt;&lt;/script&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://www.ohdave.com/rsa/Barrett.js"&gt;&lt;/script&gt;&lt;/script&gt;
</code></pre>

<p></head>
<body></p>

<pre><code>&lt;script type="text/javascript"&gt;
    //公钥加密明文
    setMaxDigits(231);
    var modulu = "00aad04454bda226e1";
    var key1 = new RSAKeyPair("010001", "", modulu);
    var password = "jack1234张三";
    var encryPssword = encryptedString(key1, password);
    document.write(encryPssword);
    alert(encryPssword);

    //私钥解密
    var priExp = "078c4c789faca941";
    var key2 = new RSAKeyPair("010001", priExp, modulu);
    var decryptedPssword = decryptedString(key2, encryPssword);
    alert(decryptedPssword);
&lt;/script&gt;
</code></pre>

<p></body>
</html>
<code>``
其中，</code>setMaxDigits<code>我理解下来是给计算留下足够多的空间的，一般选择秘钥位数(key_size)*2/16，每个digit可以放16个bit.  
</code>RSAKeyPair(encryptionExponent, decryptionExponent, modulus)`是构造钥匙的方法，实际上构造公钥（加密）只需要第一个参数和第三个参数，构造私钥（解密）只需要第二个参数和第三个参数。
第三个参数是类似模的一个东西，另外两个参数则是指数，根据模和各自的指数，就能生成相应的公钥和私钥的数字。而这个js的版本，都是返回的hex，即16进制的内容，且不支持中文，如果需要支持中文的话，需要自己先转成某种编码。不过，还剩下一个问题，就是模和指数从哪里获取呢？</p>

<h2>Java中的RSA</h2>

<p>Java的RSA代码有很多，可以参考<a href="http://blog.csdn.net/songxiaobing/article/details/17505237">链接</a>。关键在于如何使用这些API。</p>

<p>```java
  public static void main(String[] argvs) throws Exception {</p>

<pre><code>KeyPair keyPair = RSAUtil.generateKeyPair(null);
RSAPublicKey pubKey = (RSAPublicKey) keyPair.getPublic();
RSAPrivateKey priKey = (RSAPrivateKey) keyPair.getPrivate();

byte[] pubModBytes = pubKey.getModulus().toByteArray();
byte[] pubPubExpBytes = pubKey.getPublicExponent().toByteArray();
byte[] priModBytes = priKey.getModulus().toByteArray();
byte[] priPriExpBytes = priKey.getPrivateExponent().toByteArray();
RSAPublicKey recoveryPubKey = RSAUtil.generateRSAPublicKey(pubModBytes,
    pubPubExpBytes);
RSAPrivateKey recoveryPriKey = RSAUtil.generateRSAPrivateKey(
    priModBytes, priPriExpBytes);

System.out.println("加密指数: "
    + SSOEncrypter.byte2hex(pubPubExpBytes));
System.out.println("解密指数： "
    + SSOEncrypter.byte2hex(priPriExpBytes));
System.out.println("公钥modulus: "+SSOEncrypter.byte2hex(pubModBytes));
</code></pre>

<p>  }</p>

<p>```</p>

<p>生成密钥对可以用<code>generateKeyPair</code>，并且会生成一个RSA文件。随后的重点是要把里面的公钥私钥转换成有<code>RSA</code>前缀的相应类，只有这样才能调出获得Exp和Mod的方法。
两个ModBytes得到的结果是一样的。所以在js里面，modulu就变成只有一个参数了。</p>

<h2>二者的异同</h2>

<p>如同之前预料的一样，两个语言写出来的加密解密在一些细节上是不一样的。</p>

<ul>
<li><p>java</p>

<ul>
<li>默认密文是二进制的，自己主动转成16进制的话是连续的</li>
<li>原生支持中文</li>
</ul>
</li>
<li><p>javascript</p>

<ul>
<li>默认密文就是16进制的，且每个分组之间使用一个空格进行分隔</li>
<li>分组内部的排列是倒序的</li>
<li>不支持中文</li>
</ul>
</li>
</ul>


<p>下面的输出比较说明问题</p>

<p>```java
String s1 = SSOEncrypter.byte2hex(rsa.encrypt(pubKey,str.getBytes()));
System.out.println("加密后==" + s1); //加密后==0c983a3d17e57037456582ce61bc1276
System.out.println("解密后==" + Javanew String(rsa.decrypt(priKey, SSOEncrypter.hexStringToByte(s1)))); //解密后==abcdefghijklmn</p>

<p>js相同内容的输出为：
4831c7394dc3623c 5429366c63908d05 16d4229e4631084a
```
差异还是比较显而易见，具体的实现如下：</p>

<p>```java
/<em>*
   * 解析js的rsa处理过来的密文
   * @param jsHex 的特点是每16个字符中间有空格分割，而且block还原的顺序需要颠倒过来
   *
   * @throws Exception
   </em>/</p>

<p>  public String decryptFromJsRSA(String jsHex, RSAPrivateKey priKey ) throws Exception {</p>

<pre><code>String[] blocks = jsHex.split(" ");
StringBuffer sb = new StringBuffer();
String block = "";
for (int i=blocks.length; i&gt;0; i--) {
  block = blocks[i-1];
  //byte[] en_result = new BigInteger(block, 16).toByteArray();
  byte[] en_result = SSOEncrypter.hexStringToByte(block);

    byte[] de_result = decrypt(priKey, en_result);
    sb.append(new String(de_result));
}
  //返回解密的字符串
  return sb.reverse().toString();
</code></pre>

<p>  }</p>

<p>```</p>

<h2>中文编码的问题</h2>

<p>上面用到的js的rsa库，写的很小巧，运行速度也很快。唯一的缺点就是不支持中文。好在按上面的算法，试了几千条数据后，确保非中文的情况下java和js之间的明文-密文转换是没有问题的。
所以只要给js加上Base64的编码，就可以解决问题了。</p>

<p>```javascript</p>

<pre><code>genRandomNum = function(pwdLen) {
var count = 0; // 生成的密码的长度
var str = [ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
    'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
    'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '/', ';', '\'', ']', '{', '!', '#', '%', '^', '&amp;', '*', '(', ')', '-', '#', '+', '=',
    '我', '爱', '北', '京', '天','安', '门',
    '日', '产', '别', '克', '大', '众', '丰', '田'];
var maxNum = str.length;
var pwd = '';
while (count &lt; pwdLen) {
  // 生成随机数，取绝对值，防止生成负数，
  var i = Math.floor(Math.random()*maxNum); // 生成的数最大为36-1
  if (i &gt;= 0 &amp;&amp; i &lt; maxNum) {
    pwd += str[i]
    count++;
  }
}
//console.log(pwd);
return pwd;

}
</code></pre>

<p>  var pwds = [];
  for (var i=0; i &lt; 100; i++) {</p>

<pre><code>   var pwd = genRandomNum(Math.floor(Math.random()*40));
   pwds.push(pwd);
</code></pre>

<p>  }</p>

<pre><code>    //公钥加密明文
    setMaxDigits(231);
    var modulu = "0085cf15ef6336cb3f";
    var key1 = new RSAKeyPair("010001", "", modulu);
    for (var pwd of pwds) {
      document.write(pwd+"[ ");
    }
    document.write("&lt;br /&gt;");
    for (var pwd of pwds) {
      console.log(pwd);
      var encryPssword = encryptedString(key1, Base64.encode(pwd));
      document.write(encryPssword+", ");
    }
</code></pre>

<p>```</p>

<p>通过上面的程序，可以产生长度不等的多个随机密码，把明文进行base64转码后交给rsa加密成16进制的字符，然后就可以把得到的明文和密文交给java进行比对了。
另外Base64的编码是url不安全的。因为+ = /都是base64的适用字符，而这些在url传输中都会被转义，所以js的base64编码一般还有一个对url-safe的版本。
而在此处，rsa会最终转成16进制，因此并不需要使用url-safe的特性。考虑到Java的base64还是标准版的，所以使用标准版的base64更合适。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web容器中通过Spring添加Job任务]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/09/11/webrong-qi-zhong-tong-guo-springtian-jia-jobren-wu/"/>
    <updated>2014-09-11T21:59:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/09/11/webrong-qi-zhong-tong-guo-springtian-jia-jobren-wu</id>
    <content type="html"><![CDATA[<p>实际投入使用的Web站点总有很多例行任务要做，习惯的做法是利用操作系统的crontab定期执行脚本或者Java程序。
在更早的时候，曾经试过quartz，但后来因为quartz创建的线程属于JVM而不是Web容器，导致停止或
重新部署应用时线程并未终止，因此后来跑java程序例行任务的话，主要就
是单独运行jar文件。</p>

<p>时过境迁，了解到Spring已经接管了定时任务的线程处理，之前在
Web容器里跑多线程任务的最大隐患已经不存在了，所以尝试了一下在
Spring中使用例行更新。</p>

<p>这样做最大的好处当然就是代码集中，容易维护也容易部署。</p>

<h3>功能说明</h3>

<p>整个功能并不复杂，需要对redis中的设备号列表进行遍历，对每一个
号码调用远程接口获取该号码的一些动态变化的信息。取得后，这些信息
的时效时间是6小时，在失效前的10分钟内，需要再次调用远程接口刷新缓存。</p>

<p>因为整个功能的瓶颈在于远程调用，为了提高并发，
调用远程接口采取多线程的方式。而遍历的性能极好，使用单线程就够了。</p>

<h3>使用组件</h3>

<p>采用Java中线程的Executors实现起来最简单直接。Executors实质上就是一个
线程池，每塞给一个号码，就调用派发一个线程进行处理。如果没有线程可派，
则放入队列中，如队列满了则会依据设置再增加线程数量。</p>

<p><code>java
private TaskExecutor taskExecutor
</code></p>

<p>Executor确实是一个比较好的多线程编程方式，融合了Actor模式和队列，
使用起来也比较方便。</p>

<p>Executors可以由spring进行注入，在这个任务里比较合适的是采用ThreadPool*</p>

<p>```xml</p>

<pre><code>&lt;bean id="taskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"&gt;
    &lt;property name="corePoolSize" value="5" /&gt;
    &lt;property name="maxPoolSize" value="10" /&gt;
    &lt;property name="queueCapacity" value="2500" /&gt;
&lt;/bean&gt;
</code></pre>

<p>```
corePoolSize是例行打开的线程数，queueCapacity是在没有core线程处理时的排队数量，
当超过这个数量时，会再启动线程直到maxPoolSize。如果都使用完毕，则可指定溢出时的抛弃处理方式。</p>

<p>派发任务由<code>taskExecutor.execute(new PollItInterfaceTask(mdn))</code>表达，
要同步的数据通过mdn传入。</p>

<p>此外，因为遍历的线程执行速度快，而workers可能需要更长时间才能完成队列中的任务，
为防止重复提交设置了一个多线程会并发访问的集合<code>private Set&lt;String&gt; mdnInQueue = new ConcurrentSkipListSet&lt;String&gt;(); //用于记录已安排执行但还未执行的号码</code>
。整个代码的情况如下:</p>

<p>```java
package com.sanss.toolbar.job;</p>

<p>import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.TimerTask;
import java.util.concurrent.ConcurrentSkipListSet;</p>

<p>import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.junit.Assert;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.task.TaskExecutor;</p>

<p>import com.sanss.toolbar.service.CacheItInterfaceQueryService;</p>

<p>/<em>多线程发起的、向IT抓取用户套餐信息的线程池执行者，由spring中触发，根据接口run()</em>/
public class PollItInterfaceTaskExecutor  implements Runnable {</p>

<pre><code>private static Log logger = LogFactory.getLog(PollItInterfaceTaskExecutor.class);
private Set&lt;String&gt; mdnInQueue = new ConcurrentSkipListSet&lt;String&gt;(); //用于记录已安排执行但还未执行的号码
@Autowired
CacheItInterfaceQueryService cacheItInterfaceQueryService;

/*实际被多线程执行的任务,获取在队列中存放的mdn*/
private class PollItInterfaceTask implements Runnable {
    private String mdn;
    public PollItInterfaceTask(String mdn) {
        this.mdn = mdn;
    }

    public void run() {
        cacheItInterfaceQueryService.setCacheFlux(mdn);
        mdnInQueue.remove(mdn);
        Thread currentThread = Thread.currentThread();  // 获得当前的线程  
        String threadName = currentThread.getName();  
        logger.debug(threadName + ": 刷新下面号码的cache: " + mdn);
    }
}

private TaskExecutor taskExecutor;

public PollItInterfaceTaskExecutor(TaskExecutor taskExecutor) {
    this.taskExecutor = taskExecutor;

}

//任务出发后，被run自动执行的任务。首先获得所有需要提前取得IT流量信息的hashkey集合，随后遍历集合分别取出相关的一系列mdn，
//之后根据mdn检查ttl信息，发现小于500秒就安排Executor执行任务。
public void doit() {
    Set&lt;String&gt; tlbKeys = cacheItInterfaceQueryService.getAllTlbsetQueryList();
    int total = 0; //号码列表总数
    int count = 0; //本轮需要刷新的
    for (String hshkey : tlbKeys) {
        Map&lt;String, String&gt; mdns = cacheItInterfaceQueryService.getAllFieldsByAKey(hshkey);
        for(String mdn : mdns.keySet()) {
            long ttl = cacheItInterfaceQueryService.ttlFlux(mdn);
            if (ttl &lt; 500 ) {
                if (!mdnInQueue.contains(mdn)) {
                    mdnInQueue.add(mdn);
                    taskExecutor.execute(new PollItInterfaceTask(mdn));
                    count++;
               }
            }
            total++;
        }
    }
    logger.info("本轮刷新"+count+"个记录, 共有"+total+"个记录");
}

@Override
public void run() {
    // TODO Auto-generated method stub
 System.out.format("开始执行 %s ...%n", new Date());  
    doit();
}
</code></pre>

<p>}</p>

<p>```</p>

<p>CacheItInterfaceQueryService是项目中的一个服务模块，负责具体设置缓存。</p>

<p>```xml</p>

<!-- 定期去IT接口轮训的部署 -->


<pre><code>&lt;bean id="taskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"&gt;
    &lt;property name="corePoolSize" value="5" /&gt;
    &lt;property name="maxPoolSize" value="10" /&gt;
    &lt;property name="queueCapacity" value="2500" /&gt;
&lt;/bean&gt;

  &lt;bean id="pollItInterfaceTaskExecutor" class="com.sanss.toolbar.job.PollItInterfaceTaskExecutor"&gt;
       &lt;constructor-arg ref="taskExecutor" /&gt;
 &lt;/bean&gt;

&lt;bean id="springScheduleExecutorTask"  
    class="org.springframework.scheduling.concurrent.ScheduledExecutorTask"&gt;  

    &lt;property name="runnable" ref="pollItInterfaceTaskExecutor" /&gt;  

    &lt;property name="delay" value="1000" /&gt;  
    &lt;!-- 每次任务间隔 一分钟--&gt;  
    &lt;property name="period" value="60000" /&gt;  
&lt;/bean&gt;  

 &lt;bean id="springScheduledExecutorFactoryBean"  
    class="org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean"&gt;  
    &lt;property name="scheduledExecutorTasks"&gt;  
        &lt;list&gt;  
            &lt;ref bean="springScheduleExecutorTask" /&gt;  
        &lt;/list&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;  
</code></pre>

<p><code>``
避免不了的配置如上，</code>taskExecutor<code>已经在前面描述过，第二段的</code>pollItInterfaceTaskExecutor<code>就是把线程池执行者
作为参数传给自己编写的任务的构造函数，然后第三段定义一个周期执行的任务，设置好执行的间隔，runnable要提供自己编写的业务类（第二段中的内容），
最后第四步把这个周期任务交给Spring的</code>ScheduledExecutorFactoryBean`工厂来负责管理。
需要注意的是，ScheduledExecutorFactoryBean是spring4中的写法，在spring3中还是另一套描述方式，虽然功能差不多。
但在版本升级时，这是一个不大不小的坑。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tomcat7 采用 redis作为session store]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/07/14/tomcat7-cai-yong-rediszuo-wei-session-store/"/>
    <updated>2014-07-14T15:57:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/07/14/tomcat7-cai-yong-rediszuo-wei-session-store</id>
    <content type="html"><![CDATA[<p>有个项目部署了几套Tomcat，而前置分发又不是按ip映射的，所以无法象往常一样继续使用内存作为session存放的介质。
同时，业务主要由使用移动互联网的手机来访问，ip也存在随时切换的可能，所以按ip进行映射在此场景下并不是一个好的办法。因此，最终决定使用redis来作为公共的session存储空间，实现session的共享。</p>

<p>主要用到的工具包:</p>

<ul>
<li><a href="https://github.com/jcoleman/tomcat-redis-session-manager#readme">tomcat-redis-session-manager</a></li>
<li>jedis</li>
<li>commons-pool</li>
</ul>


<p>需要注意的是，这个session manager已经有挺长时间停止开发了，从issues来看，表现还算基本稳定。目前也已经支持tomcat6和tomcat7，jdk也是6和7均支持。但是，上述几个包却存在着特定的版本依赖。必须为：</p>

<ol>
<li>tomcat-redis-session-manager-1.2-tomcat-7.jar</li>
<li>jedis-2.0.0.jar</li>
<li>commons-pool-1.3.jar<br/>
尤其是最后一个，千万马虎不得。上述三个包必须放入tomcat的lib目录下。</li>
</ol>


<p>然后，再在应用的context.xml,可以是应用的该文件也可以是tomcat/conf目录下的该文件，加入下列配置即可：</p>

<p>```xml
<Valve className="com.radiadesign.catalina.session.RedisSessionHandlerValve" />
&lt;Manager className="com.radiadesign.catalina.session.RedisSessionManager"</p>

<pre><code>     host="192.168.203.198" 
     port="6379" 
     database="1" 
     maxInactiveInterval="600" /&gt; 
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSP中的EL表达式和Helper]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/06/12/jspzhong-de-elbiao-da-shi-he-helper/"/>
    <updated>2014-06-12T19:05:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/06/12/jspzhong-de-elbiao-da-shi-he-helper</id>
    <content type="html"><![CDATA[<h2>JSP中的代码</h2>

<h3>传统的老三样</h3>

<p>长久以来的Java Web开发，在jsp层面进行读取或逻辑控制等行为时主要有<strong>Scriptlet</strong>、<strong>Helper</strong>和<strong>标签</strong>三种方式。</p>

<p>其中，Scriptlet是最不受推荐的方式，最为推荐的是用 <strong>标签</strong> 的方式，而Helper因为免不了会使用Scriptlet，所以流传的也不广。而标签方式中，不单有相对通用的JSTL（JSP Standard Tag Library，JSP标准标签库)，每个框架往往还有自己的标签库。</p>

<p>如struts1的：</p>

<p><code>&lt;bean:write name="spRinglib" property="down_cnt"/&gt;</code></p>

<p>struts2的：</p>

<p><code>&lt;s:property value="r.department" /&gt;</code></p>

<p>jstl的：</p>

<p><code>&lt;c:out value="${user.company}" escapeXml=="false"/&gt;</code></p>

<p>这种方式的一大特点就是冗长和啰嗦。信息的表达力很差。上述还只是用于输出的，一旦碰到条件判断等，标签的表现更是只能用拙劣二字来加以形容。同时，每个框架各搞一套，给程序员也会带来很大的负担，对项目维护也带来更多的成本。</p>

<p>然而，对于程序员而言，输出内容、流程控制等原本有着更直接和通用的描述方式： 编写代码。比如Java程序员自然用Java编写代码，Ruby的则自然用Ruby。
如果这些重新发明的标签，具有比语言更好的表达和组织能力，那么显然大家应该放弃语言本身，比如不使用java，而在MVC的各个部分都
使用标签。但既然这个没有发生，说明标签在大部分时候并不合适。</p>

<h3>新的变化-EL表达式的出现</h3>

<p>好在随着EL表达式的推出，情况逐步有所改观。比如同样是上面的输出，EL的写法可以是 <code>${r.department}</code>，调用数组也可以是<code>${list[0].name}</code> 。不过EL目前还没有支持逻辑控制，所以逻辑控制还是要用jstl的标签。</p>

<p>但至少在老三样之外提供了新的一种方式，并且使得使用<strong>Helper</strong>模式可以不需要必须用Scriptlet。</p>

<h2>EL中使用Helper</h2>

<p>说的简单点，其实就是在jsp页面中，通过EL表达式可以调用Java实现的方法。获得类似<code>${helper.getflow(userInfo.bendiAndNationFlux[2][0])}</code> 。 其中，getflow是一个用Java写的静态方法。</p>

<p>而使用Scriptlet配合helper，则会出现下面的代码：</p>

<p>```java
&lt;%
UserInfo userInfo = (UserInfo) request.getAttribute("userInfo");
long flow = (long[] )(userInfo.getBendiAndNationFlux().get(2))[0];
SheetAttendAction helper = (com.sanss.richtone.web.action.request.SheetAttendAction )request.getAttribute("helper");
%></p>

<p>&lt;%=  helper.cpSelectHelper(requestSheetForm.getManager(), spInfo.getCpCode(), spInfo.getCpName()) %>
```</p>

<p>光写出来的代码方面，不使用EL时已经要长很多了，明明只是一个调用取值显示的操作，却要先声明一系列的东西。同时，这些类型还要在jsp
的头上import进来。而IDE对jsp的import Class支持的并不好。所以确实相当麻烦。</p>

<p>对比一下可以发现，EL能够调用方法的话，可以带来多大的方便。使用Helper方法时，无论是Scriptlet还是EL表达式，在Controller层面，做
的事情都是类似的。</p>

<p>```java
//在controller里定义方法
  public static String getflow(long flow) {</p>

<pre><code>DecimalFormat format = new DecimalFormat("###0.0");
long tmpFlow = flow / 1024;
double df = 0;
if (tmpFlow &lt; 1) {
  return flow + "K";
} else if (tmpFlow &lt; 1024.0) {
  df = flow / 1024.0;

  return format.format(df) + "M";
} else {
  df = flow / 1024.0 / 1024;
  return format.format(df) + "G";
}
</code></pre>

<p>  }</p>

<p>  //在action中，注入属性
  @RequestMapping(value = "myflow", method = RequestMethod.GET)
  public String myflow(Model model, @ModelAttribute("mdn") String mdn, @ModelAttribute("userInfo") UserInfo userInfo) {</p>

<pre><code>model.addAttribute("helper", this);
return "nubia/myflow";
</code></pre>

<p>  }
```</p>

<p>这样一来，定义自己的方法和使用这个方法就极为简便了。需要指出的是，EL表达式里面可以调用方法，即支持el里面带()调用，是<strong>直到
servlet3.0标</strong>准出现才成形的，只有在tomcat7使用，即便是<del>tomcat6也不支持</del>这种调用方式。从中，可以看出EL越来越强大趋势。
但也反过来可以证明过去方法之错误。</p>

<h2>EL难道就不是Scriptlet？</h2>

<p>如果使用过其他Web开发语言的话，可以发现EL表达式和在页面模板里写脚本语言很类似。比如 <code>${r.department}</code> 和 <code>&lt;%= r.department%&gt;</code>
除了把${}换成了&lt;%=%>实在没有其他区别， <code>${helper.getflow(userInfo.bendiAndNationFlux[2][0])}</code> 可能是写成了 <code>&lt;%= getflow(userInfo.bendiAndNationFlux[2][0])%&gt;</code> 。</p>

<p>实际上，目前的EL，除了没有逻辑判断的能力之外，已经具备了很多Scriptlet的特性。那么区别在哪里呢？</p>

<p>我觉得最关键的区别在于语言本身。所谓Scriptlet其实是Java Scriptlet，需要一系列的声明才能使用。强类型编译语言有很多的好处，但在页面
显示方面，并非其所长。所以，不得不发明一套新语言来走Scriptlet的路子。 而对于另外一些本身就是脚本的语言，重新发明一套EL就显得没有必要了。</p>

<p>EL的Scriptlet和Java的Scriptlet完全是两码事情，倒是和ruby的Scriptlet几乎没有区别。
EL的支持来的有点慢，但好歹还是来了！</p>

<h3>对EL未来的期盼</h3>

<p>作为一个开发者，十分期望未来的EL能够再走一步，增加对 <code>if</code> <code>for</code>的原生支持，而不再需要使用麻烦的标签。能否发生这样的变化，就只有
再看发展了。</p>

<h3>标签适用的情况</h3>

<p>标签其实也有其存在的价值，至少包括：</p>

<ol>
<li>分页等相对组件化的元素；</li>
<li>风格一致的表单。</li>
</ol>


<p>对于那些有组件化特征的东西，标签还是很适用的。</p>

<p>而在EL有了调用method的能力后，helper模式可以做的更多，很多页面逻辑可以放到helper中去完成，即把<code>if</code> <code>for</code>封装在helper里面。
这应该是目前最值得推崇的一种页面代码模式了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[士别三日 Jave Web非复昔日阿蒙]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/05/31/shi-bie-san-ri-jave-webfei-fu-xi-ri-a-meng/"/>
    <updated>2014-05-31T10:16:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/05/31/shi-bie-san-ri-jave-webfei-fu-xi-ri-a-meng</id>
    <content type="html"><![CDATA[<p>六七年来，小组的Java Web开发是用SSH（Struts2+Spring+Hibernate）的框架。
Struts2充当胶水层，完成request参数的封装、controller的映射以及视图和控制层之间的参数传递。
Spring在其中充当了注入的角色。Hibernate负责数据持久化。
这个架构稳定使用了五年以上。</p>

<p>之所以一直使用，一方面在于对Webwork(Struts2)的感情，
毕竟曾经这个东西在替换struts1时让人映像深刻。其次，
一个开发架构的迁移牵涉到整个小组，引入、推广和维护都有成本的，
一成不变固然不行，一直切换也难免开销过大。同时，SSH招收熟手也相对容易些。</p>

<p>然而，Struts2毕竟多年已经没什么发展，
同时它的安全漏洞始终没能很好地解决，加上老架构也确实使用的时间有点长了。
因此开始尝试新的方案。主要目标就是替换掉Struts2，也就是选用其他的Controller组件。
而考察的对象就是Spring，确切地说是Spring MVC。</p>

<p>而在了解的过程中，又仔细学习了一下Spring JPA。当MVC+JPA结合在一起后，
发现Java Web的进步已然很大。而Spring MVC可以说是Rails的山寨版，
或者可以称之为 Java on Rails with Java Style。Spring MVC的设计者
可以说从Rails中借鉴了很多东西，但又最终使用Java的方式实现了出来。</p>

<p>在初学Rails的时候，彼时的版本是1.2.6，一直有个疑问，就是Java能否也有一个
像Ruby on Rails那样好的Web开发框架？当时有的牛人给出的答案是不依赖Ruby，
DHH变不出那么多魔术。但是，如今的Spring MVC至少已经赶上了Rails 2的开发便利程度，
虽然还逊于最新的Rails版本。所以，确切地说，Java至少也可以拥有和Rails 2 <strong>一样方便</strong>的Web框架，
只是需要投入<strong>更多</strong>的人力，也需要等待长的多的时间。而最后出来的东西肯定还是充满Java味道的。
现在的Rails已经走的更远了，但Java Web提高的程度这几年却更加显著了。</p>

<p>看一下Controller：</p>

<p>```java</p>

<pre><code>@RequestMapping(value = "update/{id}", method = RequestMethod.GET)
public String updateForm(@PathVariable("id") Long id, Model model) {
    model.addAttribute("user", userService.getUser(id));
    model.addAttribute("action", "update");
    return "user/userForm";
}

@RequestMapping(value = "update/{id}", method = RequestMethod.POST)
public String update(@Valid @ModelAttribute("user") User user, RedirectAttributes redirectAttributes) {
    userService.updateUser(user, user.getNumber2(), user.getCurrentshownumber());
    redirectAttributes.addFlashAttribute("message", "更新任务成功");
    return "redirect:/simuser/";
}
</code></pre>

<p>```</p>

<p>Restful风格的Url，通过声明<code>@ModelAttribute</code>可以注入参数到模型中，
<code>@PathVariable</code>可以实现从url路径中获取参数，
<code>userService</code>是注入的服务组件，<code>model.addAttribute</code>则将controller的内容注入给页面模板。
整个风格已经十分简洁。如果需要其他组件，如<code>session</code>或者<code>request</code>，
只要在类或者方法的参数中声明即可。<code>return "user/userForm"</code>则通知渲染user目录下的userForm.jsp模板</p>

<p>Spring JPA则是最方便的Java ORM描述工具。寻找多年的Java版ActiveRecord终于有了着落。
需要定义两个文件：1：model本身，2：一个dao文件（reposity）</p>

<ul>
<li>model：</li>
</ul>


<p>```java</p>

<p>//JPA标识
@Entity
@Table(name = "users")
public class User extends IdEntity {</p>

<pre><code>private String login;
</code></pre>

<p>  ...</p>

<pre><code>private Set&lt;Phonenumber&gt; phonenumbers;
private List&lt;Useroperlog&gt; useroperlogs;

@NotBlank
public String getNumber1() {
    return number1;
}

public void setNumber1(String number1) {
    this.number1 = number1;
}

@Transient
public String getNumber2() {
    return number2;
}

public void setNumber2(String number2) {
    this.number2 = number2;
}

@Transient
public String getCurrentshownumber() {
    return currentshownumber;
}

public void setCurrentshownumber(String currentshownumber) {
    this.currentshownumber = currentshownumber;
}
// join column is in table for Phonenumber
@OneToMany(fetch=FetchType.LAZY,orphanRemoval=true,cascade=CascadeType.ALL)
@JoinColumn(name = "userid")
public Set&lt;Phonenumber&gt; getPhonenumbers() {
    return phonenumbers;
}

public void setPhonenumbers(Set&lt;Phonenumber&gt; phonenumbers) {
    this.phonenumbers = phonenumbers;
}

@OneToMany(fetch=FetchType.LAZY)
@JoinColumn(name = "userid")
public List&lt;Useroperlog&gt; getUseroperlogs() {
    return useroperlogs;
}

public void setUseroperlogs(List&lt;Useroperlog&gt; useroperlogs) {
    this.useroperlogs = useroperlogs;
}
@Override
public String toString() {
    return ToStringBuilder.reflectionToString(this);
}
</code></pre>

<p>}</p>

<p>```</p>

<p>啰嗦是还是有点啰嗦，这个毕竟是java。DAO相对代码少一些。</p>

<ul>
<li>DAO文件：</li>
</ul>


<p>```java
public interface UserDao extends PagingAndSortingRepository&lt;User, Long>, JpaSpecificationExecutor<User> {</p>

<pre><code>//Page&lt;User&gt; findByUserId(Long id, Pageable pageRequest);

User findByNumber1(String number1);
</code></pre>

<p>}
<code>``
这个dao提供了很多默认的方法，包括</code>findAll<code>,</code>findOne<code>,</code>save`，底层的
实现还有很多内容，但使用的话确实只需要声明这些就行了。</p>

<ul>
<li>在Service文件中可这样使用:</li>
</ul>


<p>```java</p>

<pre><code>public void updateUser(User entity, String number2, String showNumber) {
    loadNumber2(entity);
    resetCurrentshownumber(entity, showNumber);
    resetNumber2(entity, number2);
    userDao.save(entity);
}

public void deleteUser(Long id) {
    userDao.delete(id);
}
</code></pre>

<p>```</p>

<p>而在页面处理上，几年前的Servlet 2.5开始，EL表达式取得了首要被支持的地位。</p>

<p><code>java
${user.name}
</code>
对比ruby在erb里常用的</p>

<p><code>&lt;%=user.name%&gt;</code></p>

<p>EL表达式其实就是代码了。Java不具备动态语言的特性，所以需要另外造一套表达式。
ruby的话，直接使用scriptlet其实效果更好也更直白。个人其实认为，逻辑判断、
取值等都应该使用语言本身，而不是要借助标签。EL表达式是对Java语言的一种很好的补充。
对Java Web的开发状况改善许多。但在迭代、逻辑判断方面，
标签使用的机会还是满多的，这个只能再等发展的变化了。</p>

<p>以上是已经进步显著的几个方面。但在布局、分页以及整合上，Spring并没有提供
一步到位的东西。所以需要进一步参考<a href="https://github.com/springside/springside4">SpringSide</a>。
这是一个中国人主推的Java Web开发实践整合的开源项目。里面提供了整合的样例，
其实本身也可以当做一个开发模板来对待。</p>

<p>从<a href="https://github.com/springside/springside4">SpringSide</a>上也可以追踪
Java Web开发历史的变迁，看了几年前的版本也是主要基于SSH的，最近一两年切换到了Spring MVC。
同时它也是使用的JPA来做ORM的描述。在各方面都很贴合我的需求和口味。考虑到这个项目维护多年，
且始终保持着很不错的实践，在此推荐一下。</p>

<p>花费多年时间，Jave Web非复昔日阿蒙。开发中的痛苦状况已经得到了极大的改善。
值得刮目相待。Spring确实极大地改变了Java Web开发，而Rails则影响了十年来的Web开发。</p>
]]></content>
  </entry>
  
</feed>
