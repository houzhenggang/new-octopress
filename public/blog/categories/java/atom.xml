<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: java | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2016-06-29T16:54:17+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[禁用http的一些方法]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2016/06/03/jin-yong-httpde-%5B%3F%5D-xie-fang-fa/"/>
    <updated>2016-06-03T14:24:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2016/06/03/jin-yong-httpde-[?]-xie-fang-fa</id>
    <content type="html"><![CDATA[<p>本来是挺正常的HTTP方法，现在变成了安全隐患。当然，也不能说不合理，毕竟基于能关的都关掉的思路，不使用的东西是可以禁掉。</p>

<p>Nginx的配法</p>

<p>```
if ($request_method !~* GET|HEAD|POST) {</p>

<pre><code>        return 403;
</code></pre>

<p>}
```
对于请求方法不是GET HEAD和POST的都返回403.</p>

<p>Tomcat的配法</p>

<p>```
&lt;security-constraint></p>

<pre><code>    &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;fortune&lt;/web-resource-name&gt;
            &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
            &lt;http-method&gt;PUT&lt;/http-method&gt;
            &lt;http-method&gt;DELETE&lt;/http-method&gt;
            &lt;http-method&gt;OPTIONS&lt;/http-method&gt;
            &lt;http-method&gt;TRACE&lt;/http-method&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;&lt;/auth-constraint&gt;
</code></pre>

<p>&lt;/security-constraint>
&lt;login-config></p>

<pre><code>    &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
</code></pre>

<p>&lt;/login-config>
```</p>

<p>这里面login-config可以不配，也不会影响效果。auth-constraint一定要配，如果不出现（即值为null），则全部的限制将不起作用。
元素出现而值不填，则所有的这种请求都会被拒绝。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[StringHttpMessageConverter的头属性]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2016/05/19/stringhttpmessageconverterde-tou-shu-xing/"/>
    <updated>2016-05-19T17:22:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2016/05/19/stringhttpmessageconverterde-tou-shu-xing</id>
    <content type="html"><![CDATA[<p>使用Spring MVC中的<code>@ResponseBody</code>或者<code>@RestController</code>产生的json消息格式会产生一个很大的响应头。
其主要内容就是<code>Accept-Charset</code>会罗列几乎所有的charset变量，从utf到gbk再到iso等等。而这很大程度上是无谓的开销。</p>

<p>要解决可以在xml的配置中设置</p>

<p>```xml</p>

<p>  &lt;mvc:annotation-driven></p>

<pre><code>&lt;mvc:message-converters register-defaults="true"&gt;
  &lt;!-- 将StringHttpMessageConverter的默认编码设为UTF-8 --&gt;
  &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt;
    &lt;constructor-arg value="UTF-8" /&gt;
    &lt;property name="writeAcceptCharset" value="false" /&gt;
  &lt;/bean&gt;
&lt;/mvc:message-converters&gt;
</code></pre>

<p>  &lt;/mvc:annotation-driven>
```</p>

<p>注意给<code>StringHttpMessageConverter</code>的属性<code>writeAcceptCharset</code>设置成<code>false</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maven的Dependency和打包]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2016/04/21/mavende-dependencyhe-da-bao/"/>
    <updated>2016-04-21T11:32:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2016/04/21/mavende-dependencyhe-da-bao</id>
    <content type="html"><![CDATA[<p>使用Maven一大便捷之处就是管理依赖变得方便了，另一个好处就是打包更加灵活。</p>

<p>以前全部用jar包加入到工程里面，如果实际部署的时候需要剔除个别包，就需要自己手工在war包里删除。
而实际上需要这么干的情况还是有一些的，比如一些公共的包像ojdbc.jar，都已经放到容器里面了，如果war包里再有，则容易引发冲突。
删除公共的包，另一个好处就是可以给war包瘦身，这样在传递、部署时都会更加便捷。</p>

<p>6种范围依赖：</p>

<ul>
<li>compile: 默认的选项，会在export的时候加入全部依赖</li>
<li>provided: 由其他环境提供，如容器或jdk，但在编译和测试的时候还是会导入，对于容器公共的包，可以使用这个选项</li>
<li>runtime</li>
<li>test</li>
<li>system: 和provided很类似，但需要自己指名jar所处的位置，类似于以前直接把jar包加到工程里面的做法</li>
<li>import</li>
</ul>


<p>个人用的比较多的还是compile和provided两种。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JPA的naming strategy]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2016/04/08/jpade-naming-strate/"/>
    <updated>2016-04-08T17:08:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2016/04/08/jpade-naming-strate</id>
    <content type="html"><![CDATA[<p>JPA的配置通常如下即可：</p>

<p>```
  <!-- Jpa Entity Manager 配置 -->
  &lt;bean id="entityManagerFactory"</p>

<pre><code>class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
&lt;property name="dataSource" ref="dataSource" /&gt;
&lt;property name="jpaVendorAdapter" ref="hibernateJpaVendorAdapter" /&gt;
&lt;property name="packagesToScan" value="com.sanss." /&gt;
&lt;property name="jpaProperties"&gt;
  &lt;props&gt;
    &lt;!-- 命名规则 My_NAME-&gt;MyName --&gt;
    &lt;prop key="hibernate.ejb.naming_strategy"&gt;org.hibernate.cfg.DefaultComponentSafeNamingStrategy&lt;/prop&gt;
    &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt;
  &lt;/props&gt;
&lt;/property&gt;
</code></pre>

<p>  </bean>
```</p>

<p>其中值得注意的是Resposity的生成其实依赖于里面的<code>packagesToScan</code>，而表名、表字段和对象之间的映射转换则依赖于<code>hibernate.ejb.naming_strategy</code></p>

<p>此属性共有四个选项：</p>

<p><code>
org.hibernate.cfg.DefaultComponentSafeNamingStrategy
org.hibernate.cfg.DefaultNamingStrategy
org.hibernate.cfg.EJB3NamingStrategy
org.hibernate.cfg.ImprovedNamingStrategy
</code></p>

<p>首两个选项基本就是不做命名的转换，后面两个会把大小写的骆驼写法转换成带下划线的小写字符。同时，这个类可以自己继承并进行扩展定制，如果命名要求实在特殊，可以自行编写。
甚至表名后带日期等均可以自行定制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文艺的HashMap初始化]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/11/23/wen-yi-de-hashmapchu-shi-hua/"/>
    <updated>2015-11-23T20:33:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/11/23/wen-yi-de-hashmapchu-shi-hua</id>
    <content type="html"><![CDATA[<p>多年以来，受制于java没有初始设置<code>hash</code>对-值的方法，例如js有：</p>

<p><code>javascript
var obj = {
  a: 1, b: 2
};
</code></p>

<p>ruby在借鉴js的文法之前，有著名的rocket标注</p>

<p><code>ruby
obj = {:a=&gt;1, :b=:2}
</code></p>

<p>而java则只能继续使用过程定义来描述</p>

<p><code>java
Map&lt;String, integer&gt; map = new HashMap&lt;String, integer&gt;();
map.put("a", 1);
map.put("b", 2);
</code></p>

<p>而最近发现了一种文艺一些的写法：</p>

<p>```java
Map&lt;String, integer> map = new HashMap&lt;String, integer>(){
  {</p>

<pre><code>put("a", 1);
put("b", 2);
</code></pre>

<p>  }
}</p>

<p>```</p>

<p>此种写法是利用了创建一个匿名类的文法，该匿名类直接继承自HashMap，而第二套花括弧则是实例初始化。</p>

<p>实例初始化是对应于静态初始化，后者属于整个类，而前者属于某个对象初始化时进行。</p>

<p>```java
public class demo {
  static {</p>

<pre><code>do sth of class
</code></pre>

<p>  }</p>

<p>  {</p>

<pre><code>do sth of instance
</code></pre>

<p>  }
}
```</p>

<p>其实这种写法的代码行数并不少，但是语意，主要是段落的分割清楚了许多。</p>
]]></content>
  </entry>
  
</feed>
