<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: java | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2016-04-08T17:13:11+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JPA的naming strate]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2016/04/08/jpade-naming-strate/"/>
    <updated>2016-04-08T17:08:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2016/04/08/jpade-naming-strate</id>
    <content type="html"><![CDATA[<p>JPA的配置通常如下即可：</p>

<p>```
  <!-- Jpa Entity Manager 配置 -->
  &lt;bean id="entityManagerFactory"</p>

<pre><code>class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
&lt;property name="dataSource" ref="dataSource" /&gt;
&lt;property name="jpaVendorAdapter" ref="hibernateJpaVendorAdapter" /&gt;
&lt;property name="packagesToScan" value="com.sanss." /&gt;
&lt;property name="jpaProperties"&gt;
  &lt;props&gt;
    &lt;!-- 命名规则 My_NAME-&gt;MyName --&gt;
    &lt;prop key="hibernate.ejb.naming_strategy"&gt;org.hibernate.cfg.DefaultComponentSafeNamingStrategy&lt;/prop&gt;
    &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt;
  &lt;/props&gt;
&lt;/property&gt;
</code></pre>

<p>  </bean>
```</p>

<p>其中值得注意的是Resposity的生成其实依赖于里面的<code>packagesToScan</code>，而表名、表字段和对象之间的映射转换则依赖于<code>hibernate.ejb.naming_strategy</code></p>

<p>此属性共有四个选项：</p>

<p><code>
org.hibernate.cfg.DefaultComponentSafeNamingStrategy
org.hibernate.cfg.DefaultNamingStrategy
org.hibernate.cfg.EJB3NamingStrategy
org.hibernate.cfg.ImprovedNamingStrategy
</code></p>

<p>首两个选项基本就是不做命名的转换，后面两个会把大小写的骆驼写法转换成带下划线的小写字符。同时，这个类可以自己继承并进行扩展定制，如果命名要求实在特殊，可以自行编写。
甚至表名后带日期等均可以自行定制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文艺的HashMap初始化]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/11/23/wen-yi-de-hashmapchu-shi-hua/"/>
    <updated>2015-11-23T20:33:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/11/23/wen-yi-de-hashmapchu-shi-hua</id>
    <content type="html"><![CDATA[<p>多年以来，受制于java没有初始设置<code>hash</code>对-值的方法，例如js有：</p>

<p><code>javascript
var obj = {
  a: 1, b: 2
};
</code></p>

<p>ruby在借鉴js的文法之前，有著名的rocket标注</p>

<p><code>ruby
obj = {:a=&gt;1, :b=:2}
</code></p>

<p>而java则只能继续使用过程定义来描述</p>

<p><code>java
Map&lt;String, integer&gt; map = new HashMap&lt;String, integer&gt;();
map.put("a", 1);
map.put("b", 2);
</code></p>

<p>而最近发现了一种文艺一些的写法：</p>

<p>```java
Map&lt;String, integer> map = new HashMap&lt;String, integer>(){
  {</p>

<pre><code>put("a", 1);
put("b", 2);
</code></pre>

<p>  }
}</p>

<p>```</p>

<p>此种写法是利用了创建一个匿名类的文法，该匿名类直接继承自HashMap，而第二套花括弧则是实例初始化。</p>

<p>实例初始化是对应于静态初始化，后者属于整个类，而前者属于某个对象初始化时进行。</p>

<p>```java
public class demo {
  static {</p>

<pre><code>do sth of class
</code></pre>

<p>  }</p>

<p>  {</p>

<pre><code>do sth of instance
</code></pre>

<p>  }
}
```</p>

<p>其实这种写法的代码行数并不少，但是语意，主要是段落的分割清楚了许多。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring的@SessionAttributes和@ModelAttribute在Redirect时的特殊表现]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/11/14/springde-at-sessionattributeshe-at-modelattribute/"/>
    <updated>2015-11-14T22:50:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/11/14/springde-at-sessionattributeshe-at-modelattribute</id>
    <content type="html"><![CDATA[<p><code>@ModelAttribute</code> 在Spring中有两个地方可以填写：</p>

<ul>
<li><p>Controller的Action method的参数前标注，提示需要设置该值<br/>
```java
@ModelAttribute
public void getUser(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {</p>

<p>...
model.addAttribute("mdn", mdn);
model.addAttribute("userInfo", userInfo);
model.addAttribute("helper", new HomeHelper(userInfo));</p></li>
</ul>


<p>}
```</p>

<ul>
<li>Controller中单独的方法前标注，该方法通常不是action，但加注<code>@ModelAttribute</code>后会在Action method执行前被调用<br/>
<code>java
@RequestMapping(value = "/addDiy", method = RequestMethod.GET)
public ModelAndView addDiy(@ModelAttribute("operator") String operator) {
...
}
</code></li>
</ul>


<p>使用效果来讲就是确保第一种情况下，action method的参数会被设置，而设置的根据主要是以下4种：</p>

<ol>
<li>来自<code>@SessionAttributes</code>使用中被设置在session中的<code>ModelAttribute</code></li>
<li>上面提到的第二个使用的方法中产生的对象</li>
<li>基于URI的模板变量+type converter</li>
<li>直接new的，即默认的构建方法</li>
</ol>


<p>```java
@Controller
@RequestMapping(value = "/home")
@SessionAttributes({"operator" })
public class HomeController {</p>

<pre><code>...
/*登陆验证，成功后转至home action，验证失败则继续显示login页面*/
@RequestMapping(value="login", method = RequestMethod.POST)
public String loginPost(HttpSession session, Model model, String username, String password, String yzm, RedirectAttributes redirectAttributes) {
    redirectAttributes.addFlashAttribute("username", username);
    redirectAttributes.addFlashAttribute("password", password);

    /*检测验证码是否正确*/
    if (!StringUtils.equals((String) session.getAttribute("rand"), yzm)) {
        redirectAttributes.addFlashAttribute("errorMessage", "验证码不正确，请输入正确的验证码");
        return "redirect:/home/login";
    }

    CInterfaceOper ciop = null;
    String status = null;
    try {
        ciop = new CInterfaceOper(username, password);
        status = ciop.getUserStatus();
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

    if (StringUtils.equals(status, ConstVar.Status.Normal)) { //用户业务状体正常


        //由modelattribute获取operator时使用
        // redirect的情况下，加在model里面不会被sessionAttributes处理到session中
        //model.addAttribute("operator", operator);
        redirectAttributes.addFlashAttribute("operator", username);

        String lastUri = (String)session.getAttribute(ConstVar.REQUEST_URI);
        if (StringUtils.isEmpty(lastUri)) {
            return "redirect:/home";
        } else {
            return "redirect:"+lastUri;
        }

    } else {
        redirectAttributes.addFlashAttribute("errorMessage", "登录失败，请检查用户名和密码");
        return "redirect:/home/login";
    }
}
</code></pre>

<p>}</p>

<p>```</p>

<p>在<code>Controller</code>类前标注的<code>@sessionAttributes</code>就可以把action中的model包含的同名属性固化在session中。
但是，因为整个action的返回不是直接渲染jsp，而是使用了<code>redirect:/home</code>这样的重定向语句，所以起初并没有奏效。
而是要把<code>operator</code>放在<code>redirectAttributes</code>中，才会被固化。这说明spring选择固化属性是当且仅当
在渲染页面前。</p>

<p>在需要使用该session的属性action处，直接使用下面代码即可。</p>

<p>```java
@RequestMapping(value = "/addDiy", method = RequestMethod.GET)
public ModelAndView addDiy(@ModelAttribute("operator") String operator) {
  ModelAndView mav = new ModelAndView();</p>

<pre><code>List&lt;RingRequest&gt; ringrequest=ConstVar.DIV_LIST;
RingRequest ringrequest1=null;
if(ringrequest!=null&amp;&amp;ringrequest.size()&gt;0){
   ringrequest1=lingyingdiyService.add(ringrequest.get(0), operator);
}
</code></pre>

<p>  mav.setViewName("webapp/ringDiy/lingyindiy4");
  mav.addObject("ringrequest", ringrequest1);
  return mav;
}
```</p>

<p>在Session范围内使用注入的逻辑还是很清晰的，只是需要注意一下redirect带来的坑。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring In Action 4]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/06/01/spring-in-action-4/"/>
    <updated>2015-06-01T10:31:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/06/01/spring-in-action-4</id>
    <content type="html"><![CDATA[<p>大约两年前，又读了In action的第三版，感觉离实际的开发已经有点远了，里面讲的内容反应不了当时Spring主要的用法。于是换了
《Spring In Practice》学习，比当时的in action贴近实际反应现状多了。<br/>
好在，In action在14年年末又出了新的版本。
经典的Spring系列又出了第4版，这一版是完全跟上了Spring发展的脚步，呈现的也是最新的Spring开发内容，而且聚焦于Spring Web。</p>

<p>内容比较新颖，作者的文章也总喜欢和读者拉拉家常，所以整个书读起来也比较有意思。不过，这本书不适合完全没Java Web开发基础的读者，
其整个书还是写给已经使用Spring进行开发或者至少已经略懂什么是Java Web开发的人，所以，学这本书前必须要有一点基础。</p>

<h2>Spring的基础介绍</h2>

<p>这部分也是整个系列一直的拿手好戏，现在总结的是越来越精彩，在Xml配置和Java Config中也完全倒向后者了，不过更多的也是通过这两个配置结合了自动扫描的配置方法，即Annotation。</p>

<h3>Spring 的四大法宝：</h3>

<ol>
<li>PoJo</li>
<li>DI（依赖注入，取代各个类之间的内部new）</li>
<li>Aspect（Feature），给每个method加上chain，主要用于Transaction、logging、security、cacching这些领域</li>
<li>Template（JDBCTemplate等等)，即模板方法，用于减少冗长代码的写入。</li>
</ol>


<p>而这一切的基础是Java的动态编程，除了Java自带的反射，其实大量使用了CGLib库。</p>

<h3>Profile</h3>

<p>通过<code>@Profile("dev")</code>来表明在什么情况下使用下面的标注或配置，即激活哪一种配置属性。有两个变量可以指定值</p>

<p><code>
spring.profiles.active
spring.profiles.default
</code></p>

<p>其中，<code>default</code>可以在web.xml中定义，而<code>active</code>可以在系统属性、环境变量、JNDI或者@ActiveProfiles中定义，因为<code>active</code>的优先级更高。</p>

<h3>其他一些标注</h3>

<p>@Primary 用于消除bean的歧义性（比如有多个同名或同类型、同接口），在声明是可以使用表明这个为主。<br/>
@Qualifier，用于一步一步的Narrow指定匹配，不过似乎耦合了点，个人觉得不推荐使用<br/>
@Scope，这个很关键，指定了生成bean使用的容器, Prototype是每次new一个，大部分默认是单例，还有基于Session和Scope的bean注入，解决了web开发时的有些信息注入的难题。具体可参看<a href="/blog/2015/05/19/httpsessionzai-springzhong-de-pei-fa-he-wen-ti/">HttpSession在Spring中的配法和问题</a>。</p>

<h2>Aop</h2>

<p>Aop 提供了在method的前后增加功能（Feature）的能力，而这些功能往往是针对业务某些统一的能力的，所以称之为切面，意在把日志、事物、安全等功能提取出来，并且Spring配套了一系列术语称呼AOP中的各个角色。
但本质上还是一种定义Hook的模式。</p>

<ul>
<li>Advice ， 功能本身</li>
<li>PointCut，实际需要使用的Join Points</li>
<li>Joinpoints，在哪些点（方法中插入）</li>
</ul>


<p>插入的时机有：
1. Before: method调用前
2. After all: method调用后
3. After returning success: method调用成功
4. After throwing: method调用出现例外
5. Around: 写法最复杂，需要把调用的chain写在Advice里面</p>

<p>具体用分为:<br/>
1. Introductions: 给现有的class <strong>加</strong>(新增)方法或属性, 类似加入一个模块
2. weaving（编织、插入）：代理插入，可以在编译时、加载class时以及运行时混入</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HttpSession在Spring中的配法和问题]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/05/19/httpsessionzai-springzhong-de-pei-fa-he-wen-ti/"/>
    <updated>2015-05-19T17:22:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/05/19/httpsessionzai-springzhong-de-pei-fa-he-wen-ti</id>
    <content type="html"><![CDATA[<p>最早出于使用struts2的习惯，在Spring中如果需要使用<code>HttpSession</code>，做法是把这个对象作为整个类的一个实例对象。</p>

<p>1</p>

<p>```java
public class TestController {</p>

<p>  private static final Log logger = LogFactory.getLog(TestController.class);</p>

<p>  @Autowired
  HttpSession session;</p>

<p>  ...
}
```</p>

<p>后来因为担心Controller在Spring中是单例的（在struts2中是多例的），怕引出线程安全问题，于是把<code>session</code>放入了method中进行注入。</p>

<p>2</p>

<p>```java
@ResponseBody
  @RequestMapping(method = RequestMethod.GET,  produces = MediaTypes.TEXT_HTML_UTF_8)
  public String testSession(HttpServletRequest request, HttpServletResponse response, Model model, HttpSession session) {</p>

<pre><code>int hashCode = session.hashCode();

int i = 0  ;
if (session.getAttribute("val")!=null) {
  i = (int)session.getAttribute("val");
  i++;
} 

session.setAttribute("val", i%3);

logger.info("hashCode: " + hashCode);

return ""+hashCode + ": " + i;
</code></pre>

<p>  }
```</p>

<p>近日在学习Spring in Action的过程中，发现其实第一种方式下使用了<code>proxy 模式</code>, 实际被注入的类是<code>session  $Proxy38</code>这样的代理类，
类似于避免反复调用<code>createEntityManager</code>的做法，该代理类会寻找实际对应的session并进行操作,只是给controller注入了一个壳。</p>

<p>而第2种方法中，注入的则是标准的容器session: <code>org.apache.catalina.session.StandardSessionFacade</code></p>

<p>3</p>

<p>此外，受到推崇的是第三种写法，</p>

<p><code>java
@Component
@Scope(proxyMode=ScopedProxyMode.TARGET_CLASS, value="session")
public class ShoppingCart implements Serializable{
}
</code></p>

<p>这种写法将整个购物车变成一个scope属于session的bean，由spring注入并负责保存。</p>

<p>但这种写法我个人感觉有点过于抛离了web开发。尽管Spring的一大好处是取消对容器的依赖，从而做到测试的方便。但完全和Web容器隔离，变得不像Web开发也不是什么好的策略。
毕竟Session的概念几乎每个Web开发者都有，而scope=session则反而会增加沟通的难度。</p>
]]></content>
  </entry>
  
</feed>
