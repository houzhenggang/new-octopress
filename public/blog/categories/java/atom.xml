<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: java | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2016-06-01T22:09:00+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[StringHttpMessageConverter的头属性]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2016/05/19/stringhttpmessageconverterde-tou-shu-xing/"/>
    <updated>2016-05-19T17:22:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2016/05/19/stringhttpmessageconverterde-tou-shu-xing</id>
    <content type="html"><![CDATA[<p>使用Spring MVC中的<code>@ResponseBody</code>或者<code>@RestController</code>产生的json消息格式会产生一个很大的响应头。
其主要内容就是<code>Accept-Charset</code>会罗列几乎所有的charset变量，从utf到gbk再到iso等等。而这很大程度上是无谓的开销。</p>

<p>要解决可以在xml的配置中设置</p>

<p>```xml</p>

<p>  &lt;mvc:annotation-driven></p>

<pre><code>&lt;mvc:message-converters register-defaults="true"&gt;
  &lt;!-- 将StringHttpMessageConverter的默认编码设为UTF-8 --&gt;
  &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt;
    &lt;constructor-arg value="UTF-8" /&gt;
    &lt;property name="writeAcceptCharset" value="false" /&gt;
  &lt;/bean&gt;
&lt;/mvc:message-converters&gt;
</code></pre>

<p>  &lt;/mvc:annotation-driven>
```</p>

<p>注意给<code>StringHttpMessageConverter</code>的属性<code>writeAcceptCharset</code>设置成<code>false</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maven的Dependency和打包]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2016/04/21/mavende-dependencyhe-da-bao/"/>
    <updated>2016-04-21T11:32:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2016/04/21/mavende-dependencyhe-da-bao</id>
    <content type="html"><![CDATA[<p>使用Maven一大便捷之处就是管理依赖变得方便了，另一个好处就是打包更加灵活。</p>

<p>以前全部用jar包加入到工程里面，如果实际部署的时候需要剔除个别包，就需要自己手工在war包里删除。
而实际上需要这么干的情况还是有一些的，比如一些公共的包像ojdbc.jar，都已经放到容器里面了，如果war包里再有，则容易引发冲突。
删除公共的包，另一个好处就是可以给war包瘦身，这样在传递、部署时都会更加便捷。</p>

<p>6种范围依赖：</p>

<ul>
<li>compile: 默认的选项，会在export的时候加入全部依赖</li>
<li>provided: 由其他环境提供，如容器或jdk，但在编译和测试的时候还是会导入，对于容器公共的包，可以使用这个选项</li>
<li>runtime</li>
<li>test</li>
<li>system: 和provided很类似，但需要自己指名jar所处的位置，类似于以前直接把jar包加到工程里面的做法</li>
<li>import</li>
</ul>


<p>个人用的比较多的还是compile和provided两种。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JPA的naming strategy]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2016/04/08/jpade-naming-strate/"/>
    <updated>2016-04-08T17:08:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2016/04/08/jpade-naming-strate</id>
    <content type="html"><![CDATA[<p>JPA的配置通常如下即可：</p>

<p>```
  <!-- Jpa Entity Manager 配置 -->
  &lt;bean id="entityManagerFactory"</p>

<pre><code>class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
&lt;property name="dataSource" ref="dataSource" /&gt;
&lt;property name="jpaVendorAdapter" ref="hibernateJpaVendorAdapter" /&gt;
&lt;property name="packagesToScan" value="com.sanss." /&gt;
&lt;property name="jpaProperties"&gt;
  &lt;props&gt;
    &lt;!-- 命名规则 My_NAME-&gt;MyName --&gt;
    &lt;prop key="hibernate.ejb.naming_strategy"&gt;org.hibernate.cfg.DefaultComponentSafeNamingStrategy&lt;/prop&gt;
    &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt;
  &lt;/props&gt;
&lt;/property&gt;
</code></pre>

<p>  </bean>
```</p>

<p>其中值得注意的是Resposity的生成其实依赖于里面的<code>packagesToScan</code>，而表名、表字段和对象之间的映射转换则依赖于<code>hibernate.ejb.naming_strategy</code></p>

<p>此属性共有四个选项：</p>

<p><code>
org.hibernate.cfg.DefaultComponentSafeNamingStrategy
org.hibernate.cfg.DefaultNamingStrategy
org.hibernate.cfg.EJB3NamingStrategy
org.hibernate.cfg.ImprovedNamingStrategy
</code></p>

<p>首两个选项基本就是不做命名的转换，后面两个会把大小写的骆驼写法转换成带下划线的小写字符。同时，这个类可以自己继承并进行扩展定制，如果命名要求实在特殊，可以自行编写。
甚至表名后带日期等均可以自行定制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文艺的HashMap初始化]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/11/23/wen-yi-de-hashmapchu-shi-hua/"/>
    <updated>2015-11-23T20:33:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/11/23/wen-yi-de-hashmapchu-shi-hua</id>
    <content type="html"><![CDATA[<p>多年以来，受制于java没有初始设置<code>hash</code>对-值的方法，例如js有：</p>

<p><code>javascript
var obj = {
  a: 1, b: 2
};
</code></p>

<p>ruby在借鉴js的文法之前，有著名的rocket标注</p>

<p><code>ruby
obj = {:a=&gt;1, :b=:2}
</code></p>

<p>而java则只能继续使用过程定义来描述</p>

<p><code>java
Map&lt;String, integer&gt; map = new HashMap&lt;String, integer&gt;();
map.put("a", 1);
map.put("b", 2);
</code></p>

<p>而最近发现了一种文艺一些的写法：</p>

<p>```java
Map&lt;String, integer> map = new HashMap&lt;String, integer>(){
  {</p>

<pre><code>put("a", 1);
put("b", 2);
</code></pre>

<p>  }
}</p>

<p>```</p>

<p>此种写法是利用了创建一个匿名类的文法，该匿名类直接继承自HashMap，而第二套花括弧则是实例初始化。</p>

<p>实例初始化是对应于静态初始化，后者属于整个类，而前者属于某个对象初始化时进行。</p>

<p>```java
public class demo {
  static {</p>

<pre><code>do sth of class
</code></pre>

<p>  }</p>

<p>  {</p>

<pre><code>do sth of instance
</code></pre>

<p>  }
}
```</p>

<p>其实这种写法的代码行数并不少，但是语意，主要是段落的分割清楚了许多。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring的@SessionAttributes和@ModelAttribute在Redirect时的特殊表现]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/11/14/springde-at-sessionattributeshe-at-modelattribute/"/>
    <updated>2015-11-14T22:50:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/11/14/springde-at-sessionattributeshe-at-modelattribute</id>
    <content type="html"><![CDATA[<p><code>@ModelAttribute</code> 在Spring中有两个地方可以填写：</p>

<ul>
<li><p>Controller的Action method的参数前标注，提示需要设置该值<br/>
```java
@ModelAttribute
public void getUser(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {</p>

<p>...
model.addAttribute("mdn", mdn);
model.addAttribute("userInfo", userInfo);
model.addAttribute("helper", new HomeHelper(userInfo));</p></li>
</ul>


<p>}
```</p>

<ul>
<li>Controller中单独的方法前标注，该方法通常不是action，但加注<code>@ModelAttribute</code>后会在Action method执行前被调用<br/>
<code>java
@RequestMapping(value = "/addDiy", method = RequestMethod.GET)
public ModelAndView addDiy(@ModelAttribute("operator") String operator) {
...
}
</code></li>
</ul>


<p>使用效果来讲就是确保第一种情况下，action method的参数会被设置，而设置的根据主要是以下4种：</p>

<ol>
<li>来自<code>@SessionAttributes</code>使用中被设置在session中的<code>ModelAttribute</code></li>
<li>上面提到的第二个使用的方法中产生的对象</li>
<li>基于URI的模板变量+type converter</li>
<li>直接new的，即默认的构建方法</li>
</ol>


<p>```java
@Controller
@RequestMapping(value = "/home")
@SessionAttributes({"operator" })
public class HomeController {</p>

<pre><code>...
/*登陆验证，成功后转至home action，验证失败则继续显示login页面*/
@RequestMapping(value="login", method = RequestMethod.POST)
public String loginPost(HttpSession session, Model model, String username, String password, String yzm, RedirectAttributes redirectAttributes) {
    redirectAttributes.addFlashAttribute("username", username);
    redirectAttributes.addFlashAttribute("password", password);

    /*检测验证码是否正确*/
    if (!StringUtils.equals((String) session.getAttribute("rand"), yzm)) {
        redirectAttributes.addFlashAttribute("errorMessage", "验证码不正确，请输入正确的验证码");
        return "redirect:/home/login";
    }

    CInterfaceOper ciop = null;
    String status = null;
    try {
        ciop = new CInterfaceOper(username, password);
        status = ciop.getUserStatus();
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

    if (StringUtils.equals(status, ConstVar.Status.Normal)) { //用户业务状体正常


        //由modelattribute获取operator时使用
        // redirect的情况下，加在model里面不会被sessionAttributes处理到session中
        //model.addAttribute("operator", operator);
        redirectAttributes.addFlashAttribute("operator", username);

        String lastUri = (String)session.getAttribute(ConstVar.REQUEST_URI);
        if (StringUtils.isEmpty(lastUri)) {
            return "redirect:/home";
        } else {
            return "redirect:"+lastUri;
        }

    } else {
        redirectAttributes.addFlashAttribute("errorMessage", "登录失败，请检查用户名和密码");
        return "redirect:/home/login";
    }
}
</code></pre>

<p>}</p>

<p>```</p>

<p>在<code>Controller</code>类前标注的<code>@sessionAttributes</code>就可以把action中的model包含的同名属性固化在session中。
但是，因为整个action的返回不是直接渲染jsp，而是使用了<code>redirect:/home</code>这样的重定向语句，所以起初并没有奏效。
而是要把<code>operator</code>放在<code>redirectAttributes</code>中，才会被固化。这说明spring选择固化属性是当且仅当
在渲染页面前。</p>

<p>在需要使用该session的属性action处，直接使用下面代码即可。</p>

<p>```java
@RequestMapping(value = "/addDiy", method = RequestMethod.GET)
public ModelAndView addDiy(@ModelAttribute("operator") String operator) {
  ModelAndView mav = new ModelAndView();</p>

<pre><code>List&lt;RingRequest&gt; ringrequest=ConstVar.DIV_LIST;
RingRequest ringrequest1=null;
if(ringrequest!=null&amp;&amp;ringrequest.size()&gt;0){
   ringrequest1=lingyingdiyService.add(ringrequest.get(0), operator);
}
</code></pre>

<p>  mav.setViewName("webapp/ringDiy/lingyindiy4");
  mav.addObject("ringrequest", ringrequest1);
  return mav;
}
```</p>

<p>在Session范围内使用注入的逻辑还是很清晰的，只是需要注意一下redirect带来的坑。</p>
]]></content>
  </entry>
  
</feed>
