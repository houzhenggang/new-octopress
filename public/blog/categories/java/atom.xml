<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: java | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2016-09-20T15:00:13+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[spring boot in action]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2016/09/19/spring-boot-in-action/"/>
    <updated>2016-09-19T14:47:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2016/09/19/spring-boot-in-action</id>
    <content type="html"><![CDATA[<ul>
<li>Auto-Config</li>
<li>用starter处理依赖</li>
<li>CLI 命令行处理启动等</li>
<li>Actuator 监控组件 , 通过web或者shell</li>
</ul>


<p><code>
spring version
spring --version
spring shell # windows下打开可以自动补全的功能
</code></p>

<h3>工程初始化</h3>

<p><code>
spring init -dweb,jpa,security --build gradle -p jar -x //-x表示生成到当前目录
spring init -dweb,jpa,security --build gradle -p war myapp //表示生成工程到myapp目录
</code></p>

<p>```
@SpringBootApplication
public class DemoddfApplication {</p>

<p>public static void main(String[] args) {
SpringApplication.run(DemoddfApplication.class, args);
}
}
```</p>

<p>@SpringBootApplication 起到了过去3个标注的作用，打开了自动配置和自动扫描。如果有新的配置要求，@Configuration用在其他配置类中进行配置的扩充。而主class可以不必修改</p>

<p>用starter定义可实现更高度的抽象，也不必给出每个组件的版本号。通过<code>mvn dependency:tree</code>可查看实际的包依赖关系.
starter就是普通的maven或gradle依赖，所以可以exclude也可以指定更直接的版本。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[禁用http的一些方法]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2016/06/03/jin-yong-httpde-%5B%3F%5D-xie-fang-fa/"/>
    <updated>2016-06-03T14:24:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2016/06/03/jin-yong-httpde-[?]-xie-fang-fa</id>
    <content type="html"><![CDATA[<p>本来是挺正常的HTTP方法，现在变成了安全隐患。当然，也不能说不合理，毕竟基于能关的都关掉的思路，不使用的东西是可以禁掉。</p>

<p>Nginx的配法</p>

<p>```
if ($request_method !~* GET|HEAD|POST) {</p>

<pre><code>        return 403;
</code></pre>

<p>}
```
对于请求方法不是GET HEAD和POST的都返回403.</p>

<p>Tomcat的配法</p>

<p>```
&lt;security-constraint></p>

<pre><code>    &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;fortune&lt;/web-resource-name&gt;
            &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
            &lt;http-method&gt;PUT&lt;/http-method&gt;
            &lt;http-method&gt;DELETE&lt;/http-method&gt;
            &lt;http-method&gt;OPTIONS&lt;/http-method&gt;
            &lt;http-method&gt;TRACE&lt;/http-method&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;&lt;/auth-constraint&gt;
</code></pre>

<p>&lt;/security-constraint>
&lt;login-config></p>

<pre><code>    &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
</code></pre>

<p>&lt;/login-config>
```</p>

<p>这里面login-config可以不配，也不会影响效果。auth-constraint一定要配，如果不出现（即值为null），则全部的限制将不起作用。
元素出现而值不填，则所有的这种请求都会被拒绝。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[StringHttpMessageConverter的头属性]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2016/05/19/stringhttpmessageconverterde-tou-shu-xing/"/>
    <updated>2016-05-19T17:22:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2016/05/19/stringhttpmessageconverterde-tou-shu-xing</id>
    <content type="html"><![CDATA[<p>使用Spring MVC中的<code>@ResponseBody</code>或者<code>@RestController</code>产生的json消息格式会产生一个很大的响应头。
其主要内容就是<code>Accept-Charset</code>会罗列几乎所有的charset变量，从utf到gbk再到iso等等。而这很大程度上是无谓的开销。</p>

<p>要解决可以在xml的配置中设置</p>

<p>```xml</p>

<p>  &lt;mvc:annotation-driven></p>

<pre><code>&lt;mvc:message-converters register-defaults="true"&gt;
  &lt;!-- 将StringHttpMessageConverter的默认编码设为UTF-8 --&gt;
  &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt;
    &lt;constructor-arg value="UTF-8" /&gt;
    &lt;property name="writeAcceptCharset" value="false" /&gt;
  &lt;/bean&gt;
&lt;/mvc:message-converters&gt;
</code></pre>

<p>  &lt;/mvc:annotation-driven>
```</p>

<p>注意给<code>StringHttpMessageConverter</code>的属性<code>writeAcceptCharset</code>设置成<code>false</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maven的Dependency和打包]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2016/04/21/mavende-dependencyhe-da-bao/"/>
    <updated>2016-04-21T11:32:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2016/04/21/mavende-dependencyhe-da-bao</id>
    <content type="html"><![CDATA[<p>使用Maven一大便捷之处就是管理依赖变得方便了，另一个好处就是打包更加灵活。</p>

<p>以前全部用jar包加入到工程里面，如果实际部署的时候需要剔除个别包，就需要自己手工在war包里删除。
而实际上需要这么干的情况还是有一些的，比如一些公共的包像ojdbc.jar，都已经放到容器里面了，如果war包里再有，则容易引发冲突。
删除公共的包，另一个好处就是可以给war包瘦身，这样在传递、部署时都会更加便捷。</p>

<p>6种范围依赖：</p>

<ul>
<li>compile: 默认的选项，会在export的时候加入全部依赖</li>
<li>provided: 由其他环境提供，如容器或jdk，但在编译和测试的时候还是会导入，对于容器公共的包，可以使用这个选项</li>
<li>runtime</li>
<li>test</li>
<li>system: 和provided很类似，但需要自己指名jar所处的位置，类似于以前直接把jar包加到工程里面的做法</li>
<li>import</li>
</ul>


<p>个人用的比较多的还是compile和provided两种。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JPA的naming strategy]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2016/04/08/jpade-naming-strate/"/>
    <updated>2016-04-08T17:08:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2016/04/08/jpade-naming-strate</id>
    <content type="html"><![CDATA[<p>JPA的配置通常如下即可：</p>

<p>```
  <!-- Jpa Entity Manager 配置 -->
  &lt;bean id="entityManagerFactory"</p>

<pre><code>class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
&lt;property name="dataSource" ref="dataSource" /&gt;
&lt;property name="jpaVendorAdapter" ref="hibernateJpaVendorAdapter" /&gt;
&lt;property name="packagesToScan" value="com.sanss." /&gt;
&lt;property name="jpaProperties"&gt;
  &lt;props&gt;
    &lt;!-- 命名规则 My_NAME-&gt;MyName --&gt;
    &lt;prop key="hibernate.ejb.naming_strategy"&gt;org.hibernate.cfg.DefaultComponentSafeNamingStrategy&lt;/prop&gt;
    &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt;
  &lt;/props&gt;
&lt;/property&gt;
</code></pre>

<p>  </bean>
```</p>

<p>其中值得注意的是Resposity的生成其实依赖于里面的<code>packagesToScan</code>，而表名、表字段和对象之间的映射转换则依赖于<code>hibernate.ejb.naming_strategy</code></p>

<p>此属性共有四个选项：</p>

<p><code>
org.hibernate.cfg.DefaultComponentSafeNamingStrategy
org.hibernate.cfg.DefaultNamingStrategy
org.hibernate.cfg.EJB3NamingStrategy
org.hibernate.cfg.ImprovedNamingStrategy
</code></p>

<p>首两个选项基本就是不做命名的转换，后面两个会把大小写的骆驼写法转换成带下划线的小写字符。同时，这个类可以自己继承并进行扩展定制，如果命名要求实在特殊，可以自行编写。
甚至表名后带日期等均可以自行定制。</p>
]]></content>
  </entry>
  
</feed>
