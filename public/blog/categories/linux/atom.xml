<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: linux | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2013-07-12T14:30:02+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CentOS5 Ruby2.0 and Rails4.0]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/07/12/centos5-ruby2-dot-0-and-rails4-dot-0/"/>
    <updated>2013-07-12T12:55:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/07/12/centos5-ruby2-dot-0-and-rails4-dot-0</id>
    <content type="html"><![CDATA[<p>升级了一个很小的rails应用到4.0，原先使用的版本ree1.8.7 + rails3.1 。因为应用很小，也没使用很多插件，所以git checkout一个branch之后，用rails new生成新的目录完全替换掉老的文件。然后用<code>git diff</code>对一个一个目录或者文件进行比对与合并。整个过程下来，发现rails默认生成的文件，3.1和4.0的区别并非很大。</p>

<p>这个过程也就是只有几个小时，半天不到的时间就让应用可以跑起来了。本地测试了一下，写入数据库、查询、写入文件等都没什么问题。随后自然就是部署。</p>

<p>但此时，问题来了. 本地开发的环境是这样的：</p>

<ul>
<li>Ubuntu 12.04</li>
<li>gcc version 4.6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5)</li>
<li>ruby 2.0.0p195 (2013-05-14 revision 40734) [x86_64-linux]</li>
<li>rails 4</li>
</ul>


<p>而部署环境是这样的：</p>

<ul>
<li>CentOS release 5.4</li>
<li>gcc 版本 4.1.2 20080704</li>
<li>ruby 2.0.0p247 (2013-06-27) [i686-linux]</li>
<li>rails 4</li>
</ul>


<p>在本地运作良好的rails4应用，部署到生产环境后发生下面两个异常：</p>

<p>1 <code>rake db:migrate</code>每次只能成功一个migrate，但经反复执行后，能够migrate完整
<code>
SQLite3::SQLException: SQL logic error or missing database: INSERT INTO "schema_migrations" ("version") VALUES (?)
</code>
2 开发环境下正常，生产环境下会报告<code>nil?</code>在某个object上不存在。</p>

<p>为此，则折腾掉了很多的业余时间。</p>

<p>怀疑过是Gem的版本问题，怀疑过是ruby版本的问题,也怀疑过是ruby编译问题。</p>

<p>针对第一种可能，重新生成了一个rails应用，执行的结果照旧。<br/>
为了第二种可能，使用了ruby2.0.0p195，异常依旧；换成ruby1.9.3，但发现有个atom的gem都不能bundle上去。<br/>
随后，针对第三个可能，不惜<strong>升级的了CentOS到5.9</strong>(<code>yum upgrade</code>),为此下载了600MB的更新包。 <br/>
又重新编译安装了ruby2.0.0p0, 哦?!，世界太平了。虽然第一个异常依然，但第二个异常没了，应用是能够跑的起来了。
之后，再重新编译另外两个ruby版本就都可以正常工作了（第一个问题还是在的）。</p>

<p>由此可见，这是一个和gcc版本、os版本及ruby版本都相关的bug。</p>

<h3>教训</h3>

<p>新版的ruby或Rails同CentOS接触的并不好，如果要少麻烦的话，APP的OS还是应该选择Ubuntu。从生态的情况来看，这个责任只能怨CentOS支持的内核、gcc、lib库都过于老旧了。<br/>
之所以这么说，不单单是因为在ruby上碰到这种要比在ubuntu上麻烦的多的情形。从七周七语言的情况看，CentOS即使是CentOS6，也不支持对Haskell的安装，在安装其他语言时，多多少少都会遇到编译麻烦的问题。<br/>
CentOS是基于Redhat的，以稳定（老旧）为荣。而APP则是迅速发展的，因此二者极其容易脱节。所以，APP服务器首选Ubuntu。</p>

<h3>题外话</h3>

<p>从对OS的依赖少这点来看，Java确实做了件很漂亮的事情。一个编译好的jdk文件，可以在几乎全部的主流linux下解压，然后即可使用。部署时也不用担心底层OS是什么实现。所以，如果是Java的应用，继续用CentOS也是不会有很多坑的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim and lampbrother]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/04/05/vim-and-lampbroter/"/>
    <updated>2013-04-05T11:34:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/04/05/vim-and-lampbroter</id>
    <content type="html"><![CDATA[<p>中了vim的毒之后, 开始学起了vim. 这东西在windows下也能用,而且扩展性极佳, 确实值得学学. 添加syntax和
snippet都极其简单, 如果还要写代码的话, 确实值得掌握. 主要是发现这个工具就是给我这类人用的.</p>

<p>台湾人的视频太简单, 很多基础的东西没有讲好, 好处就是他是按照git加载众多挂件之后演示并授课的, 所以
比较吸引人. 但光那些显然也不够, 而且他本身也不算很熟练. 于是开始找其他视频. 找了一圈以后, 发现了
<a href="http://www.lampbrother.net/">lamp兄弟连</a>的视频. 我个人比较喜欢里面李强强的linux课程. 另一位稍早录制
的李阳的linux视频也很不错. 这家培训机构感觉还是很不错的, 培养的确实是业界最急需的一线工人.不过他的培训主要
针对全脱产的、尤其是那些正要找工作的20岁出头的年轻人, 我是挺难报他们的班. 毕竟不太可能有什么时间和精力能够
连续坐在实验机房里一整天. 而且这样的效率其实也不高.</p>

<p>然后顺便看了一下RHCE和RHCA. 发现lampbrother的课程基本是按RHCE的脉络来的, 这门课其实可以直接改为通过RHCE.
RHCE的范围基本如下:</p>

<ul>
<li>Hardware installation and configuration</li>
<li>The boot process</li>
<li>Linux filesystem administration</li>
<li>Package management and Kickstart</li>
<li>User and group administration</li>
<li>System administration tools</li>
<li>Kernel services and configuration</li>
<li>Apache and Squid</li>
<li>Network file sharing services (NFS, FTP, and Samba)</li>
<li>Domain Name System (DNS)</li>
<li>E-mail (servers and clients)</li>
<li>Extended Internet Services Daemon (xinetd), the Secure package, and DHCP</li>
<li>The X Window System</li>
<li>Firewalls, SELinux, and troubleshooting</li>
</ul>


<p>只是这家机构的目的培训直接能工作的学生而不是考证为主的, 猜测因此没有开这门课吧. 课程的那些实验都会做的话,基本也就可以当一个称职的系统管理员了.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[About AWK]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/02/19/about-awk/"/>
    <updated>2013-02-19T14:52:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/02/19/about-awk</id>
    <content type="html"><![CDATA[<p>受 <a href="http://coolshell.cn/articles/9070.html">AWK简明教程</a> 的影响，学习了一下仰慕已久却始终不得要领的AWK，
甚至还下载了著名的科尔尼汉写的《The AWK programming Language》并看完了第一章和后面的一些内容。</p>

<p>学习之后，发现这个东西其实还是很简洁的，同bash的配合确实很好，在某些应用场合下，处理文本、截取文本、调整文本，的确是利器。
但是，也必须注意到，这个东西确实已经是上古一代的东西了。不是说上古的东西就一定使用价值降低，不过AWK的作用和处理范围
已经大大地被Python和Ruby侵占。在Unix/C之下，他是足够简便的，对bash是很好的补充。如今已经是Ruby Python这些
script流行的年代，而这些脚本语言可以很大程度上替代AWK。AWK保留的优势仅仅是最简单的场合下，比如<code>{print $1}</code>之类时
显得足够简洁的优势。稍微复杂一些，如循环、分支判断一多，就显得不如Ruby Python了。</p>

<p>所以，看AWK的第一章以及简明教程就足够了。因为基本上也只要用到这些最简单的应用，写出优雅的bash命令。是用来写程序<strong>命令</strong>而不是程序<strong>文件</strong>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[patch and diff]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/02/05/patch-and-diff/"/>
    <updated>2013-02-05T10:52:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/02/05/patch-and-diff</id>
    <content type="html"><![CDATA[<p>patch和diff确实是个神奇的东西，用来对现有版本的升级是最好不过了。
好处在于一来不用停业务，二来可以明确到底改了多少东西。</p>

<h3>diff</h3>

<p>首先来说说diff，毕竟patch是从此处产生。</p>

<p>```
diff -ruNa src dest  > a.patch</p>

<p>-r 针对整个目录<br/>
-u 以合并的方式来显示文件内容的不同
-N 新文件做空白文件
-a 包含二进制内容，如jar包，class等
```</p>

<p>据说这个东西是perl的发明者创建的工具，主要用于比较源码，通常不带<code>-a</code>。</p>

<h3>patch</h3>

<p>patch就比较强大了。如果是更改一个目录下面，最常见的做法是进入该目录，然后执行</p>

<p><code>
patch -p1 &lt; ../a.patch
</code></p>

<p>随后，两个目录就会变得一模一样了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ssh-key]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/06/29/ssh-key/"/>
    <updated>2012-06-29T16:18:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/06/29/ssh-key</id>
    <content type="html"><![CDATA[<p>有些东西没用只是因为你的不习惯。一旦你开始用了，可能就会觉得之前的不采用是多么的傻。<strong>ssh-key</strong>登录就是这样一类东西。</p>

<p>一直以来没搞懂每次输入一个密码有那么麻烦的吗？去哪个站点不要登录啊。但用了几次之后，发现加了key后才能彻底发挥出
console快速敏捷的威力。这个比每次输入密码的体验好多了。更重要的，当机器很多很多，比如几十台上百台的时候，那省下的功夫
和能做的事情可就不是一点点了。当然，我并不理解为什么不用保存登录密码的方式，而是兜圈子采用这么一种办法。细想下来可能
和linux系统是多用户的系统这个特性相关。因为实质上的ssh-key登录是另外一个东西。可参见<a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">这篇</a>入门的文章。</p>

<p>要想使用公钥登录方式，可以分为两步：</p>

<ol>
<li>生成公钥私钥对，会存放在<code>.ssh/id_rsa,  .ssh/id_rsa.pub</code>中，这是通过命令 <code>$ssh-keygen</code>来操作的</li>
<li>如果已经生成过了，那以后增加其他机器就可以直接执行这步，无需每次都生成公钥私钥。将公钥上传到远程服务器，远程主机会
把他们存放在<code>.ssh/authorized_keys</code>中。其实就是每个client增加一条记录。执行的命令是<code>$ ssh-copy-id user@host</code></li>
</ol>


<p>弄好以后，发现做起事情来确实快多了。</p>

<p>Update: 有些机器上需要给出额外的参数<code>ssh-copy-id -i ~/.ssh/id_rsa.pub git@host</code></p>
]]></content>
  </entry>
  
</feed>
