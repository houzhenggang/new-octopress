<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: nodejs | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/nodejs/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2013-04-08T21:04:45+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[hubot and socket.io]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/06/26/hubot-and-socket-dot-io/"/>
    <updated>2012-06-26T22:05:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/06/26/hubot-and-socket-dot-io</id>
    <content type="html"><![CDATA[<p>这几天搭了hubot, 跑起了gtalk,也选了一些script的.这玩意确实挺有趣.本质上是一种命令行,但又增加了新的特色.
最大的突破在于实现了通过IM工具来提交交互命令.与此同时,IM上的命令行不在只有一个人可见,想想console,而是变得一群人可以一起参与,很多乐趣
也就来自其中.而命令行的好处大家都知道,就是快.而结合在im里的命令行比普通的更快,因为不需要登录,不需要启动命令.试想下面的步骤哪个响应更快:</p>

<p>```sh
telnet xxx
coffee</p>

<blockquote><p>3+2=?
```</p></blockquote>

<p>vs</p>

<p><code>
eval 3+2
</code></p>

<p>后者显然便捷许多.</p>

<p>在研究redis的时候,顺手看了一个chat room的例子, 尽管例子本身有很大的问题,却也由此接触了<a href="http://socket.io">socket.io</a>.
Socket.io确实让人找回了socket编程的感觉, 而且应该说这玩意是通过浏览器进行监控、日志浏览的必备工具.相当有意义的技术.<br/>
而且<code>socket.io-client</code>也很有意思.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript: The Good Parts]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/06/23/javascript-the-good-parts/"/>
    <updated>2012-06-23T00:08:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/06/23/javascript-the-good-parts</id>
    <content type="html"><![CDATA[<p>大约去年的这个时候,在复旦图书馆看见了&lt;JavaScript精粹>的中文版,就借来看了一下.会看这本书应该是我读了墨菲博客的推荐.
中文版花了不长的时间就看完了,因为这本书确实短小精悍,或者说相当的<strong>concise</strong> . 读完之后很是喜欢, 于是买了英文版.
再后来, 也就淡淡忘了. 尽管读过一遍, 内容却忘的差不多了, 当时只是明白了不少js的强大的能力, 解除了我对这门语言的一点迷思.
但是缺乏练习的后果必然是无法掌握的.</p>

<p>最近在看CoffeeScript 和 NodeJS, 进一步领略了JS的威力, 有些地方也不甚明白, 于是又翻出这本书看了一下.这次出奇的顺利, 从翻开
到看完也就2天的功夫, 而且2天时间内看的比例并不高.下面是看完后对这本书的书评.</p>

<p>这本书确实是一本需要反复阅读的书.作者的话语极其精炼, 招招都是要害, 所以必须要仔细看才能看的明白.而且从书中可以看出作者的造诣
确实很深, 对js的认识以及语言的评价都是高度与深度相结合, 而且很多反应了使用者的感受, 不是大家是写不出这么有深度的文章的.</p>

<p>书中最有价值的是 3.Objects, 4.Functions, 5.Inheritance 这3章. 如果是用coffeeScript的话, 3和4的价值就更加突出.通过学习,可以掌握
js的object array的文法, 也可以明白js function的4种调用方式(obj.method, func.func, Obj.construtor(new), func.apply(this, argv)),
Closure(outer inner函数之间的scope关系). 我甚至还第一次明白了汉诺塔.</p>

<p>Js的另一部分即prototype继承的特性目前还不甚了了, 可能还需呀补充一点其他读物. 做点练习才能领会.</p>

<p>JavaScript确实是门很强悍的语言, 尤其是那句它只关系对象能做什么,而不关心对象的出生是什么.
一个设计的很有问题的语言,最终统治了web浏览器,是不是有点命中注定的意思?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NodeJS]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/06/04/nodejs/"/>
    <updated>2012-06-04T17:12:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/06/04/nodejs</id>
    <content type="html"><![CDATA[<p>最近迷上了NodeJS和CoffeeScript.毫不夸张的说,这是我比较了解的语言中,C/CPP/Java/Ruby(可能还有Python),到目前为止最吸引我的.
特别是搭配CS的语法后, 相当的让人感觉良好.</p>

<p>而越看NodeJS越有UNIX系统编程和网络编程的味道, 仿佛Stevens的C的Lib库再生一般.这种感觉很难描述清楚,基本模式就是原来使用现在变得那么简单了.
而且NodeJS依我看来够精简,功能又够强大,但从语言和基本的平台来讲,搭配上CoffeeScript后,已经是主流语言中最强悍的一种了吧.</p>

<p>http://howtonode.org/understanding-process-next-tick</p>

<p>tick其实就是计算机系统的时隙.</p>

<h2>util</h2>

<p>util.format() 等于printf, 但是末尾跟随的参数如果过少或过多都会做处理, 过多则inspect,过少则打placeholder.
两点是多了<code>%j</code>支持json格式的输出.</p>

<p>util.debug() 用于调试的,输出到<code>stderr</code><br/>
util.log() <code>stdout</code><br/>
util.inspect(object) 展开对象信息<br/>
util.isArray, isRegExp, isDate</p>

<h2>Events</h2>

<p>All objects which emit events are instances of <code>require('events').EventEmitter</code><br/>
All EventEmitters emit the event <code>newListener</code> when new listeners are added</p>

<p>```js</p>

<h1>前一个参数是camel-cased string, 后一个是是函数,也就做listener</h1>

<p>server.on('connection', function (stream) {
  console.log('someone connected!');
});</p>

<h1>一次性事件,发生后自动消失</h1>

<p>server.once('connection', function (stream) {
  console.log('Ah, we have our first user!');
});</p>

<p>server.removeListener('connection', callback);
emitter.removeAllListeners([event])
emitter.setMaxListeners(n)</p>

<h1>返回一系列函数</h1>

<p>emitter.listeners(event)</p>

<h1>触发事件</h1>

<p>emitter.emit(event, [arg1], [arg2], [...])
```</p>

<h2>Buffer</h2>

<p>这个东西和C里面的 <code>bytes c[8192];</code> 很类似. 是在V8 heap之外对基础memory的分配,因而效率很高.但是也不能
自动增长. 是一个全局变量, 通常不需要require. 纯js对二进制支持的效率不好.对Unicode支持尚可.</p>

<ul>
<li>encodings:

<ul>
<li>ascii</li>
<li>utf8</li>
<li>ucs2</li>
<li>base64</li>
<li>binary 通常不用,而是直接用Buffer</li>
<li>hex 十六进制</li>
</ul>
</li>
</ul>


<p>```js
new Buffer(size)
new Buffer(array)
new Buffer(str, [encoding])</p>

<p>buf.write(string, [offset], [length], [encoding]) # 把string的内容写到buffer里,和c很像,但是offset默认是0,length默认是buffer的长度 - offset
buf.toString([encoding], [start], [end])
buf[index]
buf.slice([start], [end])
Buffer.byteLength(str, 'utf8')
buf.length 返回的是整个buffer的size</p>

<p>buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])
buf.fill(value, [offset], [end])
此外还有一堆读写各种类型的函数
```</p>

<h2>Stream</h2>

<p>stream是一个抽象接口, HTTP stdout都是对stream的实现.<br/>
所有的stream, 都是<code>EventEmitter</code>的实现.</p>

<h3>Readable Stream</h3>

<ul>
<li><p>Event</p>

<ul>
<li>data</li>
<li>end 可能可以继续写</li>
<li>error</li>
<li>close 不是所有的流都有关闭,比如进来的http request</li>
</ul>
</li>
<li><p>method</p>

<ul>
<li>readable</li>
<li>setEncoding(encoding) , 设置后,data返回的就不是buffer而是string</li>
<li>pause 停止<code>data</code>事件</li>
<li>resume 恢复<code>data</code>事件</li>
<li>destroy</li>
<li><p>pipe
```js
process.stdin.resume();</p>

<p>process.stdin.pipe(process.stdout, { end: false }); #截断source 的 end事件发给destination</p>

<p>process.stdin.on("end", function() {
  process.stdout.write("Goodbye\n");
});
```</p></li>
</ul>
</li>
</ul>


<h3>Writable Stream</h3>

<ul>
<li><p>Event</p>

<ul>
<li>drain 表明可以再写了</li>
<li>error</li>
<li>close</li>
<li>pipe</li>
</ul>
</li>
<li><p>method</p>

<ul>
<li>writable</li>
<li>write(string, [encoding], [fd])</li>
<li>write(buffer)</li>
<li>end()</li>
<li>end(string, encoding)</li>
<li>end(buffer)</li>
<li>destroy()</li>
</ul>
</li>
</ul>


<h2>Crypto</h2>

<p>加密解密的系类</p>

<p>```js
var filename = process.argv[2];
var crypto = require('crypto');
var fs = require('fs');</p>

<p>var shasum = crypto.createHash('sha1');</p>

<p>var s = fs.ReadStream(filename);
s.on('data', function(d) {
  shasum.update(d);
});</p>

<p>s.on('end', function() {
  var d = shasum.digest('hex');
  console.log(d + '  ' + filename);
});
```</p>

<h2>File System</h2>

<p>异步同步并举，异步时不保证执行顺序，高压环境下使用异步接口可提高效率。因为异步的本质是non-block</p>

<ul>
<li>fs.watch

<ul>
<li>Linux下用 <code>inotify</code>实现</li>
<li>返回'rename' or 'change' 事件
```js
fs.watch('somedir', function (event, filename) {
  console.log('event is: ' + event);
  if (filename) {

<pre><code>console.log('filename provided: ' + filename);
</code></pre>

  } else {

<pre><code>console.log('filename not provided');
</code></pre>

<p>  }
});
```</p></li>
</ul>
</li>
<li>fs.ReadStream</li>
<li>fs.WriteStream</li>
<li>fs.open(path, flags, [mode], [callback])
<code>(err, fd)</code></li>
</ul>


<h2>Path</h2>

<h2>Net</h2>

<ul>
<li><p>net.createServer([options], [connectionListener])<br/>
<code>js
var net = require('net');
var server = net.createServer(function(c) { //'connection' listener
console.log('server connected');
c.on('end', function() {
  console.log('server disconnected');
});
c.write('hello\r\n');
c.pipe(c);
});
server.listen(8124, function() { //'listening' listener
console.log('server bound');
});
</code></p></li>
<li><p>net.connect,net.createConnection</p>

<ul>
<li>也是一样触发<code>connect</code>事件</li>
<li>net.connect(port, [host], [connectListener])</li>
<li>net.connect(path, [connectListener])</li>
</ul>
</li>
</ul>


<h3>net.Server</h3>

<ul>
<li>server.listen(port, [host], [listeningListener])

<ul>
<li><code>listening</code> event</li>
</ul>
</li>
<li>server.close()

<ul>
<li>也是异步关闭，最终 emit <code>close</code>事件</li>
</ul>
</li>
<li>server.address() <code>{"port":43239,"family":2,"address":"0.0.0.0"}</code></li>
<li>server.maxConnections</li>
<li><p>server.connections</p></li>
<li><p>Event</p>

<ul>
<li>listening</li>
<li>connection</li>
<li>close</li>
<li>error</li>
</ul>
</li>
</ul>


<h3>net.Socket</h3>

<ul>
<li>new net.Socket([options])

<ul>
<li>fd, type, allowHalfOpen</li>
</ul>
</li>
<li>socket.connect 一般用net.connect来新建</li>
<li>bufferSize() 当前准备发的缓存长度</li>
<li>setEncoding() 指定接收data的编码</li>
<li>write(data, [encoding], [callback])</li>
<li>end([data]) half-close</li>
<li>destroy() 仅在处理error是需要使用</li>
<li>pause(), resume() 和<code>data</code>事件相关</li>
<li>setTimeout(timeout, [callback])

<ul>
<li>超时，通常没有超时</li>
<li>0则表示同步操作，而且要求即刻发掉</li>
</ul>
</li>
<li>setNoDelay() 默认就是true</li>
<li>keepAlive()</li>
<li>address(), remoteAddress(), remotePort()</li>
<li><p>bytesRead() 已收到的bytes数量， bytesWritten()</p></li>
<li><p>Event</p>

<ul>
<li>connect</li>
<li>data</li>
<li>end</li>
<li>timeout</li>
<li>drain</li>
<li>error</li>
<li>close</li>
</ul>
</li>
</ul>


<h2>UDP / Datagram Sockets</h2>

<p>  <code>require 'dgram'</code></p>

<h2>DNS</h2>

<ul>
<li>lookup()</li>
<li>resolve()</li>
</ul>


<h2>HTTP</h2>

<p>核心思想： The user is able to <strong>stream data</strong>.</p>

<h3>http</h3>

<ul>
<li>http.createServer([requestListener])</li>
</ul>


<h4>Event</h4>

<ul>
<li>'request'

<ul>
<li>(request, response) -></li>
<li>一个connection可能有多个request</li>
</ul>
</li>
<li>'connection'

<ul>
<li>(socket) -></li>
<li>一般不会直接处理，也可以通过<code>request.connection</code>获得<code>socket</code></li>
</ul>
</li>
<li>'close'</li>
<li>'checkContinue'

<ul>
<li>(request, response) -></li>
<li><a href="http://benramsey.com/blog/2009/02/http-status-100-continue-corrections/">关于100-continue</a>  ,用处就是试探，在发起实际的body前把条件等发给server预审</li>
<li><code>request</code> event will <strong>not</strong> be emitted.</li>
</ul>
</li>
<li>'upgrade'

<ul>
<li>不知何意</li>
<li>(request, socket, head) -></li>
</ul>
</li>
<li>'clientError'

<ul>
<li>(exception) -></li>
</ul>
</li>
</ul>


<h4>method</h4>

<ul>
<li>listen(port, [hostname], [callback])</li>
<li>close() = net.Server.close()</li>
</ul>


<h3>http.ServerRequest</h3>

<h4>Event</h4>

<ul>
<li>data</li>
<li>(chunk) -></li>
<li>end</li>
<li>close</li>
</ul>


<h4>method</h4>

<ul>
<li>method 'GET', 'DELETE'</li>
<li>url

<ul>
<li><code>require('url').parse(request.url, true)</code></li>
<li><code>require('querystring').parse</code></li>
</ul>
</li>
<li>request.headers</li>
<li>request.trailers

<ul>
<li>Only populated after the 'end' event.</li>
</ul>
</li>
<li>request.setEncoding([encoding])</li>
<li>pause()</li>
<li>resume()</li>
<li>connection</li>
</ul>


<h3>http.ServerResponse</h3>

<p>实现了<code>Writable Stream</code></p>

<h4>Event</h4>

<ul>
<li>'close'</li>
</ul>


<h4>Method</h4>

<ul>
<li>writeContinue()</li>
<li>writeHead(statusCode, [reasonPhrase], [headers])

<ul>
<li>必须在<code>response.end()</code>被调用之前</li>
<li><code>response.writeHead(200, {Content-Type: 'text/plain'})</code></li>
</ul>
</li>
<li>statusCode</li>
<li>setHeader(name, value)

<ul>
<li><code>response.setHeader("Content-Type", "text/html")</code></li>
</ul>
</li>
<li>getHeader(name)</li>
<li>removeHeader(name)</li>
<li>write(chunk, [encoding])

<ul>
<li>stream式的写法</li>
<li>raw</li>
<li>implicit header mode</li>
</ul>
</li>
<li>addTrailers(headers)
```js
response.writeHead(200, { 'Content-Type': 'text/plain',

<pre><code>                    'Trailer': 'Content-MD5' });
</code></pre>

<p>response.write(fileData);
response.addTrailers({'Content-MD5': "7895bf4b8828b55ceaf47747b4bca667"});
response.end();
```</p></li>
<li>end([data], [encoding])</li>
</ul>


<h3>http.request</h3>

<p>Node保持有几个可以发起http请求的连接</p>

<ul>
<li>http.request(options, callback)
```js
var options = {
host: 'www.google.com',
port: 80,
path: '/upload',
method: 'POST'
};</li>
</ul>


<p>var req = http.request(options, function(res) {
  console.log('STATUS: ' + res.statusCode);
  console.log('HEADERS: ' + JSON.stringify(res.headers));
  res.setEncoding('utf8');
  res.on('data', function (chunk) {</p>

<pre><code>console.log('BODY: ' + chunk);
</code></pre>

<p>  });
});</p>

<p>req.on('error', function(e) {
  console.log('problem with request: ' + e.message);
});</p>

<p>// write data to request body
req.write('data\n');
req.write('data\n');
req.end();
```</p>

<ul>
<li>http.get(options, callback)</li>
</ul>


<h4>http.Agent</h4>

<p>node里面客户端的socket是存放在一个pool里面的，这个pool就叫做Agent</p>

<h3>http.ClientRequest</h3>

<p>```js
request.on('response', function (response) {
  response.on('data', function (chunk) {</p>

<pre><code>console.log('BODY: ' + chunk);
</code></pre>

<p>  });
});
```</p>

<h4>Event</h4>

<ul>
<li>response

<ul>
<li>(response) -></li>
</ul>
</li>
<li>socket

<ul>
<li>(socket) -></li>
<li>给该request分配socket后触发</li>
</ul>
</li>
<li>upgrade

<ul>
<li>(response, socket, head) -></li>
<li>似乎是用来升级到websocket的</li>
</ul>
</li>
<li>continue</li>
</ul>


<h4>Method</h4>

<ul>
<li>write(chunk, [encoding])</li>
<li>end()</li>
<li>abort()</li>
<li>setTimeout(timeout, [callback])</li>
<li>setNoDelay(true/false)</li>
<li>setSocketKeepAlive([enable], [initialDelay])</li>
</ul>


<h3>http.ClientResponse</h3>

<p>a <code>Readable Stream</code></p>

<ul>
<li>data</li>
<li>end</li>
<li><p>close</p></li>
<li><p>statusCode</p></li>
<li>headers</li>
<li>trailers</li>
<li>setEncoding([encoding])</li>
<li>pause()</li>
<li>resume()</li>
</ul>


<h2>HTTPS</h2>

<h2>URL</h2>

<ul>
<li>href - <code>http://user:pass@host.com:8080/p/a/t/h?query=string#hash</code></li>
<li>protocol</li>
<li>host</li>
<li>auth</li>
<li>hostname</li>
<li>port</li>
<li>pathname</li>
<li>search</li>
<li>path</li>
<li>query</li>
<li><p>hash</p></li>
<li><p>url.parse(urlStr)</p></li>
</ul>


<p><code>js
coffee&gt; url.parse("http://192.168.2.2/?q=1&amp;q=2#sss", true)
{ protocol: 'http:',
  slashes: true,
  host: '192.168.2.2',
  hostname: '192.168.2.2',
  href: 'http://192.168.2.2/?q=1&amp;q=2#sss',
  hash: '#sss',
  search: '?q=1&amp;q=2',
  query: { q: [ '1', '2' ] },
  pathname: '/',
  path: '/?q=1&amp;q=2' }
</code></p>

<h2>Readline</h2>

<p>加入这个模块后，创建interface之后（书上仅仅说调用这个模块，没说创建）程序不会退出直至你关闭这个interface。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Note on CoffeeScript]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/06/01/note-on-coffeescript/"/>
    <updated>2012-06-01T11:06:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/06/01/note-on-coffeescript</id>
    <content type="html"><![CDATA[<p>这是阅读'The little Book on CoffeeScript'的笔记。全书只有60页。和CoffeeScript还是相符合的。毕竟它也是一个清简的工具。
不需要太大的部头。</p>

<h1>安装步骤</h1>

<p>coffee可以直接运行在浏览器中，只要浏览器引入了一个js文件。</p>

<p>```html</p>

<script src="http://jashkenas.github.com/coffee-script/extras/coffee-script.js"
type="text/javascript" charset="utf-8"></script>


<script type="text/coffeescript">
# Some CoffeeScript
</script>


<p>```</p>

<p>但这种是需要运行的时候解析的，所以还是应该运用服务端编译的方法，compile成js。下面是执行步骤，注意这里是基于node.js的，
但实际上只要有引擎即可。只不过是因为node安装方便，而且已经自带了引擎。</p>

<p><code>
wget http://nodejs.org/dist/v0.6.18/node-v0.6.18.tar.gz
tar -zxvf node-v0.6.18.tar.gz
cd node-v0.6.18.tar.gz
./configure
make &amp;&amp; make install
npm install -g coffee-script # -g 才能确保不是安装在当前目录
</code></p>

<p><strong>编译</strong> <code>coffee --compile my-script.coffee</code> , 按目录编译 <code>coffee --output lib --compile src</code>
<strong>运行</strong> <code>coffee my-script.coffee</code>
<strong>命令行</strong> <code>coffee</code> , 值得注意的是，这时候的if等语句换行需要跟随 <code>\</code></p>

<h1>1. Syntax</h1>

<p>CoffeeScript并不是Js的超集合，所以有些句法是<strong>不能</strong>使用的。<br/>
和ruby一样，没有分号；if可以尾随的与语法糖；  单行的if需要用than</p>

<p>和python一样，空白是重要的，所以程序必须保持sane manner；if的缩进</p>

<p>支持多行注释<br/>
```js
  ###</p>

<pre><code>A multiline comment,
</code></pre>

<p>  ###
```</p>

<h3>变量和范围</h3>

<p>CS让所有的变量全部变成局部变量，避免了js这方面的混乱。<br/>
需要声明全局变量时，可以直接在浏览器的js代码里面生成，也可以使用<code>this</code>关键字，它代表
<strong>global object</strong><br/>
<code>js
exports = this
exports.MyVariable = "foo-bar"
</code></p>

<h3>Functions</h3>

<p>cs去掉了js冗长的函数定义语句，改用arrow <code>-&gt;</code>  ，这个替换js的function关键字
单行函数 <code>func = -&gt; "bar"</code><br/>
多行函数，必须注意<strong>缩进</strong>（indent）<br/>
<code>js
func = -&gt;
  # An extra line
  "bar"
</code></p>

<p>在 <code>-&gt;</code>前配置<strong>arguments</strong> <code>times = (a = 1, b = 2) -&gt; a * b</code><br/>
接受多个参数 <code>sum = (nums...) -&gt;</code></p>

<p><strong>调用</strong>时，可以跟<code>()</code>或者不跟。当跟上一个或多个参数的时候表现的像ruby，是当函数来调用；但是当
没有参数时，会死死的被当做变量，此时表现的更像python。与ruby不同，ruby永远把应用当函数来调用。</p>

<p>Function <strong>Context</strong> 待进一步了解<br/>
<code>=&gt;</code></p>

<h3>一些表达式</h3>

<p>花括号是可选的，hash和array可以利用缩进完成。
```js
object2 = one: 1, two: 2</p>

<p>object3 =
  one: 1
  two: 2</p>

<p>array1 = [1, 2, 3]</p>

<p>array2 = [
  1
  2
  3
]
```</p>

<p>Flow Control<br/>
像python，像ruby</p>

<p>String的解析，和ruby类似</p>

<h3>循环和综合（类似python)</h3>

<p><code>in</code> ---- <code>for name in ["A", "B", "C"]</code><br/>
需要index ---- <code>for name, i in ["A", "B", "C"]</code>， 只需要加一个参数<br/>
把操作也写成一行 ---- <code>release prisoner for prisoner in []</code><br/>
comprehensions: ---- <code>release p for p in prisoners when prisoners[0] == "R"</code>
内置的仅支持while</p>

<h3>几个替换和操作符</h3>

<p><code>@</code> serve as <code>this</code>, <code>@saviour = true</code><br/>
<code>::</code> serve as <code>prototype</code>, <code>User::first = -&gt; @records[0]</code></p>

<p><code>?</code> similiar to Ruby's nil?, <code>praise if brian?</code> , it's also a <code>||</code>， <code>velocity = southern ? 40</code></p>

<h1>2. CoffeeScript Classes</h1>

<p>CS使用<code>class</code>做关键字来定义类 <code>class Animal</code>  ，
使用new 来新建对象 <code>animal = new Animal</code>,<br/>
<code>contructor</code> 类似ruby的initialize，
```js
class Animal
  constructor: (name) -></p>

<pre><code>@name = name
</code></pre>

<p><code>  
其中，构造函数的参数如果带@则会自动被当成实例变量进行设置  
</code>js
class Animal
  constuctor: (@name) -></p>

<p>animal = new Animal("Parrot")
```</p>

<h3>instance 属性</h3>

<p>给实例加属性如同给object加属性</p>

<p>```js
class Animal
  price: 5</p>

<p>  sell: (customer) =></p>

<p>animal = new Animal
animal.sell(new Customer)
```</p>

<p>为了确保将<code>this</code>锁定在它被定义的context中，需要用fat arrow <code>=&gt;</code>，这样this就不会随着event callbacks
环境的变化而变化。</p>

<h3>Static 属性</h3>

<p>这就是class变量，需要用到this 或者 @<br/>
```js
class Animal
  this.find = (name) -></p>

<p>Animal.find("Parrot")</p>

<p>Class Animal
  @find: (name) -></p>

<p>Animal.find("Parrot")
```</p>

<h3>继承与Super</h3>

<p>和ruby python的继承类似，使用<code>extends</code>关键字，内部实现是用prototype完成的。</p>

<p>```js
class Animal
  constructor: (@name) -></p>

<p>  alive: -></p>

<pre><code>false
</code></pre>

<p>class Parrot extends Animal
  constructor: -></p>

<pre><code>super("Parrot")
</code></pre>

<p>  dead: -></p>

<pre><code>not @alive()
</code></pre>

<p>Animal::rip = true</p>

<p>parrot = new Parrot("Macaw")
console.log("aaa") if parrot.rip
```</p>

<h1>3. 惯用法</h1>

<p>```js</p>

<h3>each</h3>

<p>fun(n) for n, i in array</p>

<h3>map</h3>

<p>for item in array
  item.name</p>

<h3>select</h3>

<p>passed = []
failed = []
for score in [49, 48, 90]
  (if score > 60 then passed else failed).push score</p>

<h3>includes</h3>

<p>included = "test" in array #但不能用于单个字符串的内部模式匹配</p>

<h3>属性遍历</h3>

<p>object = {one: 1, two: 2}
for key, value of object
  "#{key} = #{value}"</p>

<h3>or</h3>

<p>hash ?= {}</p>

<h3>支持多值返回</h3>

<h3>外部扩展库</h3>

<h1>Use local alias</h1>

<p>$ = jQuery</p>

<p>$ ->
  #COMContentLoaded
  $(".js-el").click -></p>

<pre><code>alert("clicked!")
</code></pre>

<p>```</p>

<h1>4. 编译</h1>

<p>提到了<a href="http://jashkenas.github.com/coffee-script/#cake">Cake</a>这个工具。
跟rake差不多，可以watch，可以自动编译。</p>

<h1>5.优良部分</h1>

<p>孙子说，知己知彼百战不殆。</p>

<p>CS也只是修复了部分js的缺陷。</p>

<p><code>-&gt;</code> 是从input <em>points to</em> output。这个创意真棒。 <code>(input) -&gt; output</code></p>
]]></content>
  </entry>
  
</feed>
