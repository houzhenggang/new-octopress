<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: nodejs | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/nodejs/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2014-06-23T09:31:26+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[hubot and socket.io]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/06/26/hubot-and-socket-dot-io/"/>
    <updated>2012-06-26T22:05:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/06/26/hubot-and-socket-dot-io</id>
    <content type="html"><![CDATA[<p>这几天搭了hubot, 跑起了gtalk,也选了一些script的.这玩意确实挺有趣.本质上是一种命令行,但又增加了新的特色.
最大的突破在于实现了通过IM工具来提交交互命令.与此同时,IM上的命令行不在只有一个人可见,想想console,而是变得一群人可以一起参与,很多乐趣
也就来自其中.而命令行的好处大家都知道,就是快.而结合在im里的命令行比普通的更快,因为不需要登录,不需要启动命令.试想下面的步骤哪个响应更快:</p>

<p>vs </p>

<p>后者显然便捷许多. </p>

<p>在研究redis的时候,顺手看了一个chat room的例子, 尽管例子本身有很大的问题,却也由此接触了<a href="http://socket.io">socket.io</a>.
Socket.io确实让人找回了socket编程的感觉, 而且应该说这玩意是通过浏览器进行监控、日志浏览的必备工具.相当有意义的技术.<br>
而且<code>socket.io-client</code>也很有意思. </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript: The Good Parts]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/06/23/javascript-the-good-parts/"/>
    <updated>2012-06-23T00:08:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/06/23/javascript-the-good-parts</id>
    <content type="html"><![CDATA[<p>大约去年的这个时候,在复旦图书馆看见了<JavaScript精粹>的中文版,就借来看了一下.会看这本书应该是我读了墨菲博客的推荐.
中文版花了不长的时间就看完了,因为这本书确实短小精悍,或者说相当的<strong>concise</strong> . 读完之后很是喜欢, 于是买了英文版.
再后来, 也就淡淡忘了. 尽管读过一遍, 内容却忘的差不多了, 当时只是明白了不少js的强大的能力, 解除了我对这门语言的一点迷思.
但是缺乏练习的后果必然是无法掌握的.</p>

<p>最近在看CoffeeScript 和 NodeJS, 进一步领略了JS的威力, 有些地方也不甚明白, 于是又翻出这本书看了一下.这次出奇的顺利, 从翻开
到看完也就2天的功夫, 而且2天时间内看的比例并不高.下面是看完后对这本书的书评.</p>

<p>这本书确实是一本需要反复阅读的书.作者的话语极其精炼, 招招都是要害, 所以必须要仔细看才能看的明白.而且从书中可以看出作者的造诣
确实很深, 对js的认识以及语言的评价都是高度与深度相结合, 而且很多反应了使用者的感受, 不是大家是写不出这么有深度的文章的.</p>

<p>书中最有价值的是 3.Objects, 4.Functions, 5.Inheritance 这3章. 如果是用coffeeScript的话, 3和4的价值就更加突出.通过学习,可以掌握
js的object array的文法, 也可以明白js function的4种调用方式(obj.method, func.func, Obj.construtor(new), func.apply(this, argv)), 
Closure(outer inner函数之间的scope关系). 我甚至还第一次明白了汉诺塔.</p>

<p>Js的另一部分即prototype继承的特性目前还不甚了了, 可能还需呀补充一点其他读物. 做点练习才能领会.</p>

<p>JavaScript确实是门很强悍的语言, 尤其是那句它只关系对象能做什么,而不关心对象的出生是什么.
一个设计的很有问题的语言,最终统治了web浏览器,是不是有点命中注定的意思?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NodeJS]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/06/04/nodejs/"/>
    <updated>2012-06-04T17:12:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/06/04/nodejs</id>
    <content type="html"><![CDATA[<p>最近迷上了NodeJS和CoffeeScript.毫不夸张的说,这是我比较了解的语言中,C/CPP/Java/Ruby(可能还有Python),到目前为止最吸引我的.
特别是搭配CS的语法后, 相当的让人感觉良好.</p>

<p>而越看NodeJS越有UNIX系统编程和网络编程的味道, 仿佛Stevens的C的Lib库再生一般.这种感觉很难描述清楚,基本模式就是原来使用现在变得那么简单了.
而且NodeJS依我看来够精简,功能又够强大,但从语言和基本的平台来讲,搭配上CoffeeScript后,已经是主流语言中最强悍的一种了吧.</p>

<p><a href="http://howtonode.org/understanding-process-next-tick">http://howtonode.org/understanding-process-next-tick</a></p>

<p>tick其实就是计算机系统的时隙.</p>

<h2 id="toc_163">util</h2>

<p>util.format() 等于printf, 但是末尾跟随的参数如果过少或过多都会做处理, 过多则inspect,过少则打placeholder.
两点是多了<code>%j</code>支持json格式的输出.</p>

<p>util.debug() 用于调试的,输出到<code>stderr</code><br>
util.log() <code>stdout</code><br>
util.inspect(object) 展开对象信息<br>
util.isArray, isRegExp, isDate  </p>

<h2 id="toc_164">Events</h2>

<p>All objects which emit events are instances of <code>require(&#39;events&#39;).EventEmitter</code><br>
All EventEmitters emit the event <code>newListener</code> when new listeners are added  </p>

<h2 id="toc_165">Buffer</h2>

<p>这个东西和C里面的 <code>bytes c[8192];</code> 很类似. 是在V8 heap之外对基础memory的分配,因而效率很高.但是也不能
自动增长. 是一个全局变量, 通常不需要require. 纯js对二进制支持的效率不好.对Unicode支持尚可. </p>

<ul>
<li>encodings:

<ul>
<li>ascii</li>
<li>utf8</li>
<li>ucs2</li>
<li>base64</li>
<li>binary 通常不用,而是直接用Buffer</li>
<li>hex 十六进制 </li>
</ul></li>
</ul>

<h2 id="toc_166">Stream</h2>

<p>stream是一个抽象接口, HTTP stdout都是对stream的实现.<br>
所有的stream, 都是<code>EventEmitter</code>的实现. </p>

<h3 id="toc_167">Readable Stream</h3>

<ul>
<li><p>Event  </p>

<ul>
<li>data</li>
<li>end 可能可以继续写</li>
<li>error</li>
<li>close 不是所有的流都有关闭,比如进来的http request</li>
</ul></li>
<li><p>method</p>

<ul>
<li>readable</li>
<li>setEncoding(encoding) , 设置后,data返回的就不是buffer而是string</li>
<li>pause 停止<code>data</code>事件</li>
<li>resume 恢复<code>data</code>事件</li>
<li>destroy</li>
<li>pipe 
```js
process.stdin.resume();</li>
</ul>

<p>process.stdin.pipe(process.stdout, { end: false }); #截断source 的 end事件发给destination</p>

<p>process.stdin.on(&quot;end&quot;, function() {
  process.stdout.write(&quot;Goodbye\n&quot;);
});
```</p></li>
</ul>

<h3 id="toc_168">Writable Stream</h3>

<ul>
<li><p>Event</p>

<ul>
<li>drain 表明可以再写了</li>
<li>error</li>
<li>close</li>
<li>pipe</li>
</ul></li>
<li><p>method  </p>

<ul>
<li>writable</li>
<li>write(string, [encoding], [fd])</li>
<li>write(buffer)</li>
<li>end()</li>
<li>end(string, encoding)</li>
<li>end(buffer)</li>
<li>destroy()</li>
</ul></li>
</ul>

<h2 id="toc_169">Crypto</h2>

<p>加密解密的系类</p>

<h2 id="toc_170">File System</h2>

<p>异步同步并举，异步时不保证执行顺序，高压环境下使用异步接口可提高效率。因为异步的本质是non-block</p>

<ul>
<li>fs.watch<br>

<ul>
<li>Linux下用 <code>inotify</code>实现</li>
<li>返回&#39;rename&#39; or &#39;change&#39; 事件
<code>js
fs.watch(&#39;somedir&#39;, function (event, filename) {
console.log(&#39;event is: &#39; + event);
if (filename) {
console.log(&#39;filename provided: &#39; + filename);
} else {
console.log(&#39;filename not provided&#39;);
}
});
</code></li>
</ul></li>
<li>fs.ReadStream<br></li>
<li>fs.WriteStream </li>
<li>fs.open(path, flags, [mode], [callback]) 
<code>(err, fd)</code></li>
</ul>

<h2 id="toc_171">Path</h2>

<h2 id="toc_172">Net</h2>

<ul>
<li><p>net.createServer([options], [connectionListener])<br>
<code>js
var net = require(&#39;net&#39;);
var server = net.createServer(function(c) { //&#39;connection&#39; listener
console.log(&#39;server connected&#39;);
c.on(&#39;end&#39;, function() {
console.log(&#39;server disconnected&#39;);
});
c.write(&#39;hello\r\n&#39;);
c.pipe(c);
});
server.listen(8124, function() { //&#39;listening&#39; listener
console.log(&#39;server bound&#39;);
});
</code></p></li>
<li><p>net.connect,net.createConnection  </p>

<ul>
<li>也是一样触发<code>connect</code>事件</li>
<li>net.connect(port, [host], [connectListener])</li>
<li>net.connect(path, [connectListener])<br></li>
</ul></li>
</ul>

<h3 id="toc_173">net.Server</h3>

<ul>
<li>server.listen(port, [host], [listeningListener])

<ul>
<li><code>listening</code> event</li>
</ul></li>
<li>server.close()<br>

<ul>
<li>也是异步关闭，最终 emit <code>close</code>事件</li>
</ul></li>
<li>server.address() <code>{&quot;port&quot;:43239,&quot;family&quot;:2,&quot;address&quot;:&quot;0.0.0.0&quot;}</code></li>
<li>server.maxConnections</li>
<li><p>server.connections</p></li>
<li><p>Event  </p>

<ul>
<li>listening</li>
<li>connection</li>
<li>close</li>
<li>error</li>
</ul></li>
</ul>

<h3 id="toc_174">net.Socket</h3>

<ul>
<li>new net.Socket([options])

<ul>
<li>fd, type, allowHalfOpen</li>
</ul></li>
<li>socket.connect 一般用net.connect来新建</li>
<li>bufferSize() 当前准备发的缓存长度</li>
<li>setEncoding() 指定接收data的编码</li>
<li>write(data, [encoding], [callback])</li>
<li>end([data]) half-close</li>
<li>destroy() 仅在处理error是需要使用</li>
<li>pause(), resume() 和<code>data</code>事件相关</li>
<li>setTimeout(timeout, [callback])

<ul>
<li>超时，通常没有超时</li>
<li>0则表示同步操作，而且要求即刻发掉</li>
</ul></li>
<li>setNoDelay() 默认就是true</li>
<li>keepAlive()</li>
<li>address(), remoteAddress(), remotePort()</li>
<li><p>bytesRead() 已收到的bytes数量， bytesWritten()</p></li>
<li><p>Event</p>

<ul>
<li>connect</li>
<li>data</li>
<li>end</li>
<li>timeout</li>
<li>drain</li>
<li>error</li>
<li>close</li>
</ul></li>
</ul>

<h2 id="toc_175">UDP / Datagram Sockets</h2>

<p><code>require &#39;dgram&#39;</code>  </p>

<h2 id="toc_176">DNS</h2>

<ul>
<li>lookup()<br></li>
<li>resolve()</li>
</ul>

<h2 id="toc_177">HTTP</h2>

<p>核心思想： The user is able to <strong>stream data</strong>.</p>

<h3 id="toc_178">http</h3>

<ul>
<li>http.createServer([requestListener])</li>
</ul>

<h4 id="toc_179">Event</h4>

<ul>
<li>&#39;request&#39;

<ul>
<li>(request, response) -&gt; </li>
<li>一个connection可能有多个request</li>
</ul></li>
<li>&#39;connection&#39;

<ul>
<li>(socket) -&gt;</li>
<li>一般不会直接处理，也可以通过<code>request.connection</code>获得<code>socket</code></li>
</ul></li>
<li>&#39;close&#39;</li>
<li>&#39;checkContinue&#39;

<ul>
<li>(request, response) -&gt;</li>
<li><a href="http://benramsey.com/blog/2009/02/http-status-100-continue-corrections/">关于100-continue</a>  ,用处就是试探，在发起实际的body前把条件等发给server预审</li>
<li><code>request</code> event will <strong>not</strong> be emitted.</li>
</ul></li>
<li>&#39;upgrade&#39;

<ul>
<li>不知何意</li>
<li>(request, socket, head) -&gt; </li>
</ul></li>
<li>&#39;clientError&#39;

<ul>
<li>(exception) -&gt;</li>
</ul></li>
</ul>

<h4 id="toc_180">method</h4>

<ul>
<li>listen(port, [hostname], [callback])</li>
<li>close() = net.Server.close()</li>
</ul>

<h3 id="toc_181">http.ServerRequest</h3>

<h4 id="toc_182">Event</h4>

<ul>
<li>data

<ul>
<li>(chunk) -&gt;</li>
</ul></li>
<li>end</li>
<li>close</li>
</ul>

<h4 id="toc_183">method</h4>

<ul>
<li>method &#39;GET&#39;, &#39;DELETE&#39;</li>
<li>url

<ul>
<li><code>require(&#39;url&#39;).parse(request.url, true)</code></li>
<li><code>require(&#39;querystring&#39;).parse</code></li>
</ul></li>
<li>request.headers</li>
<li>request.trailers 

<ul>
<li>Only populated after the &#39;end&#39; event.</li>
</ul></li>
<li>request.setEncoding([encoding])</li>
<li>pause()</li>
<li>resume()</li>
<li>connection</li>
</ul>

<h3 id="toc_184">http.ServerResponse</h3>

<p>实现了<code>Writable Stream</code></p>

<h4 id="toc_185">Event</h4>

<ul>
<li>&#39;close&#39;</li>
</ul>

<h4 id="toc_186">Method</h4>

<ul>
<li>writeContinue()</li>
<li>writeHead(statusCode, [reasonPhrase], [headers])

<ul>
<li>必须在<code>response.end()</code>被调用之前</li>
<li><code>response.writeHead(200, {Content-Type: &#39;text/plain&#39;})</code></li>
</ul></li>
<li>statusCode<br></li>
<li>setHeader(name, value)

<ul>
<li><code>response.setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;)</code></li>
</ul></li>
<li>getHeader(name)</li>
<li>removeHeader(name)</li>
<li>write(chunk, [encoding])

<ul>
<li>stream式的写法</li>
<li>raw</li>
<li>implicit header mode</li>
</ul></li>
<li>addTrailers(headers)
<code>js
response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/plain&#39;,
                      &#39;Trailer&#39;: &#39;Content-MD5&#39; });
response.write(fileData);
response.addTrailers({&#39;Content-MD5&#39;: &quot;7895bf4b8828b55ceaf47747b4bca667&quot;});
response.end();
</code></li>
<li>end([data], [encoding])</li>
</ul>

<h3 id="toc_187">http.request</h3>

<p>Node保持有几个可以发起http请求的连接</p>

<ul>
<li>http.request(options, callback)
```js
var options = {
host: &#39;<a href="http://www.google.com">www.google.com</a>&#39;,
port: 80,
path: &#39;/upload&#39;,
method: &#39;POST&#39;
};</li>
</ul>

<p>var req = http.request(options, function(res) {
  console.log(&#39;STATUS: &#39; + res.statusCode);
  console.log(&#39;HEADERS: &#39; + JSON.stringify(res.headers));
  res.setEncoding(&#39;utf8&#39;);
  res.on(&#39;data&#39;, function (chunk) {
    console.log(&#39;BODY: &#39; + chunk);
  });
});</p>

<p>req.on(&#39;error&#39;, function(e) {
  console.log(&#39;problem with request: &#39; + e.message);
});</p>

<p>// write data to request body
req.write(&#39;data\n&#39;);
req.write(&#39;data\n&#39;);
req.end(); 
```</p>

<ul>
<li>http.get(options, callback)</li>
</ul>

<h4 id="toc_188">http.Agent</h4>

<p>node里面客户端的socket是存放在一个pool里面的，这个pool就叫做Agent</p>

<h3 id="toc_189">http.ClientRequest</h3>

<h4 id="toc_190">Event</h4>

<ul>
<li>response

<ul>
<li>(response) -&gt;</li>
</ul></li>
<li>socket

<ul>
<li>(socket) -&gt; </li>
<li>给该request分配socket后触发</li>
</ul></li>
<li>upgrade

<ul>
<li>(response, socket, head) -&gt; </li>
<li>似乎是用来升级到websocket的</li>
</ul></li>
<li>continue<br></li>
</ul>

<h4 id="toc_191">Method</h4>

<ul>
<li>write(chunk, [encoding])</li>
<li>end()</li>
<li>abort()</li>
<li>setTimeout(timeout, [callback])</li>
<li>setNoDelay(true/false)</li>
<li>setSocketKeepAlive([enable], [initialDelay])</li>
</ul>

<h3 id="toc_192">http.ClientResponse</h3>

<p>a <code>Readable Stream</code> </p>

<ul>
<li>data</li>
<li>end</li>
<li><p>close</p></li>
<li><p>statusCode</p></li>
<li><p>headers</p></li>
<li><p>trailers</p></li>
<li><p>setEncoding([encoding])</p></li>
<li><p>pause()</p></li>
<li><p>resume()</p></li>
</ul>

<h2 id="toc_193">HTTPS</h2>

<h2 id="toc_194">URL</h2>

<ul>
<li>href - <code>http://user:pass@host.com:8080/p/a/t/h?query=string#hash</code></li>
<li>protocol</li>
<li>host</li>
<li>auth</li>
<li>hostname</li>
<li>port</li>
<li>pathname</li>
<li>search </li>
<li>path</li>
<li>query</li>
<li><p>hash</p></li>
<li><p>url.parse(urlStr)</p></li>
</ul>

<h2 id="toc_195">Readline</h2>

<p>加入这个模块后，创建interface之后（书上仅仅说调用这个模块，没说创建）程序不会退出直至你关闭这个interface。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Note on CoffeeScript]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/06/01/note-on-coffeescript/"/>
    <updated>2012-06-01T11:06:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/06/01/note-on-coffeescript</id>
    <content type="html"><![CDATA[<p>这是阅读&#39;The little Book on CoffeeScript&#39;的笔记。全书只有60页。和CoffeeScript还是相符合的。毕竟它也是一个清简的工具。
不需要太大的部头。</p>

<h1 id="toc_196">安装步骤</h1>

<p>coffee可以直接运行在浏览器中，只要浏览器引入了一个js文件。</p>

<p>但这种是需要运行的时候解析的，所以还是应该运用服务端编译的方法，compile成js。下面是执行步骤，注意这里是基于node.js的，
但实际上只要有引擎即可。只不过是因为node安装方便，而且已经自带了引擎。</p>

<p><strong>编译</strong> <code>coffee --compile my-script.coffee</code> , 按目录编译 <code>coffee --output lib --compile src</code> 
<strong>运行</strong> <code>coffee my-script.coffee</code>
<strong>命令行</strong> <code>coffee</code> , 值得注意的是，这时候的if等语句换行需要跟随 <code>\</code></p>

<h1 id="toc_197">1. Syntax</h1>

<p>CoffeeScript并不是Js的超集合，所以有些句法是<strong>不能</strong>使用的。<br>
和ruby一样，没有分号；if可以尾随的与语法糖；  单行的if需要用than  </p>

<p>和python一样，空白是重要的，所以程序必须保持sane manner；if的缩进  </p>

<p>支持多行注释<br>
<code>js
  ###
    A multiline comment,
  ###
</code></p>

<h3 id="toc_198">变量和范围</h3>

<p>CS让所有的变量全部变成局部变量，避免了js这方面的混乱。<br>
需要声明全局变量时，可以直接在浏览器的js代码里面生成，也可以使用<code>this</code>关键字，它代表
<strong>global object</strong><br>
<code>js
exports = this
exports.MyVariable = &quot;foo-bar&quot;
</code>  </p>

<h3 id="toc_199">Functions</h3>

<p>cs去掉了js冗长的函数定义语句，改用arrow <code>-&gt;</code>  ，这个替换js的function关键字
单行函数 <code>func = -&gt; &quot;bar&quot;</code><br>
多行函数，必须注意<strong>缩进</strong>（indent）<br>
<code>js
func = -&gt;
  # An extra line
  &quot;bar&quot;
</code></p>

<p>在 <code>-&gt;</code>前配置<strong>arguments</strong> <code>times = (a = 1, b = 2) -&gt; a * b</code><br>
接受多个参数 <code>sum = (nums...) -&gt;</code></p>

<p><strong>调用</strong>时，可以跟<code>()</code>或者不跟。当跟上一个或多个参数的时候表现的像ruby，是当函数来调用；但是当
没有参数时，会死死的被当做变量，此时表现的更像python。与ruby不同，ruby永远把应用当函数来调用。</p>

<p>Function <strong>Context</strong> 待进一步了解<br>
<code>=&gt;</code></p>

<h3 id="toc_200">一些表达式</h3>

<p>花括号是可选的，hash和array可以利用缩进完成。
```js
object2 = one: 1, two: 2</p>

<p>object3 = 
  one: 1
  two: 2</p>

<p>array1 = [1, 2, 3]</p>

<p>array2 = [
  1
  2
  3
]
```</p>

<p>Flow Control<br>
像python，像ruby</p>

<p>String的解析，和ruby类似</p>

<h3 id="toc_201">循环和综合（类似python)</h3>

<p><code>in</code> ---- <code>for name in [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</code><br>
需要index ---- <code>for name, i in [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</code>， 只需要加一个参数<br>
把操作也写成一行 ---- <code>release prisoner for prisoner in []</code><br>
comprehensions: ---- <code>release p for p in prisoners when prisoners[0] == &quot;R&quot;</code>
内置的仅支持while  </p>

<h3 id="toc_202">几个替换和操作符</h3>

<p><code>@</code> serve as <code>this</code>, <code>@saviour = true</code><br>
<code>::</code> serve as <code>prototype</code>, <code>User::first = -&gt; @records[0]</code>  </p>

<p><code>?</code> similiar to Ruby&#39;s nil?, <code>praise if brian?</code> , it&#39;s also a <code>||</code>， <code>velocity = southern ? 40</code>  </p>

<h1 id="toc_203">2. CoffeeScript Classes</h1>

<p>CS使用<code>class</code>做关键字来定义类 <code>class Animal</code>  ，
使用new 来新建对象 <code>animal = new Animal</code>,<br>
<code>contructor</code> 类似ruby的initialize， 
<code>js
class Animal 
  constructor: (name) -&gt; 
    @name = name
</code><br>
其中，构造函数的参数如果带@则会自动被当成实例变量进行设置<br>
```js
class Animal
  constuctor: (@name) -&gt;</p>

<p>animal = new Animal(&quot;Parrot&quot;)
```</p>

<h3 id="toc_204">instance 属性</h3>

<p>给实例加属性如同给object加属性 </p>

<p>为了确保将<code>this</code>锁定在它被定义的context中，需要用fat arrow <code>=&gt;</code>，这样this就不会随着event callbacks
环境的变化而变化。</p>

<h3 id="toc_205">Static 属性</h3>

<p>这就是class变量，需要用到this 或者 @<br>
```js
class Animal
  this.find = (name) -&gt;</p>

<p>Animal.find(&quot;Parrot&quot;)</p>

<p>Class Animal
  @find: (name) -&gt;</p>

<p>Animal.find(&quot;Parrot&quot;)
```</p>

<h3 id="toc_206">继承与Super</h3>

<p>和ruby python的继承类似，使用<code>extends</code>关键字，内部实现是用prototype完成的。</p>

<h1 id="toc_207">3. 惯用法</h1>

<h1 id="toc_208">4. 编译</h1>

<p>提到了<a href="http://jashkenas.github.com/coffee-script/#cake">Cake</a>这个工具。
跟rake差不多，可以watch，可以自动编译。</p>

<h1 id="toc_209">5.优良部分</h1>

<p>孙子说，知己知彼百战不殆。</p>

<p>CS也只是修复了部分js的缺陷。</p>

<p><code>-&gt;</code> 是从input <em>points to</em> output。这个创意真棒。 <code>(input) -&gt; output</code></p>
]]></content>
  </entry>
  
</feed>
