<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: rails | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2014-05-03T17:20:17+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[IT系统架构的模式]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/04/12/itxi-tong-jia-gou-de-mo-shi/"/>
    <updated>2014-04-12T16:18:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/04/12/itxi-tong-jia-gou-de-mo-shi</id>
    <content type="html"><![CDATA[<p>近日终于得以拜读了Martin Fowler的大作《The Patterns of Enterprise Application Architecture》。</p>

<p>最早了解这本书是从robbin那里，在距今很多年前的一个Java书单里。彼时他对这本书的评价大意是适合要自己动手开发框架的人看，对应用开发没什么直接的帮助。同时，他认为读下来并没有太多感觉。而回过头来看，读过这本书的中国程序员应该是不少的，但真的从中汲取营养做出东西来的人几乎没有。从这也可以看出中国工程师在动手和创新方面确实有些先天不足。</p>

<p>然而，这本书对于DHH、对于Rails则可以说是一切的开端。对这本书贯彻的最到位、突破的最有力的，非DHH用Ruby开创Rails莫属。本书成书于2002年，彼时企业应用这个称呼比较时髦，按作者的说法，他的本意是IT系统的架构，而这也符合后来软件架构所适用的范围。如病人记录、订单跟踪、信用系统、保险、汇率兑换，这些都是IT系统，也就是企业应用。而文字处理、电梯控制、交换机、编译器、操作系统、游戏则基本不能算作企业应用。只是，2002年之后，企业应用这个名字被用的烂了，反而成了大慢笨的代表，导致07/08年的时候，甚至有不少人认为Rails不适合做企业应用。但彼时我感觉Rails对这些简单的所谓企业应用才是大杀器，毕竟大部分企业应用其实就是重度的CRUD应用，而这方面Rails堪比马克沁机枪对单兵的作战效果。至于互联网类的Web应用，交互、设计是占大头的，Rails投入使用的实际效果反而不如企业应用那么明显。</p>

<p>这本书确实是rails的设计指南，或者说是rails的设计文档。但DHH的突破和创新之处还是很明显的：</p>

<ol>
<li>本书是基于.Net 和 Java的，但提及了Python和Ruby，而作者更多的应该只是一种不抱希望的假设罢了，然而DHH真的用Ruby把这本书实作了出来。</li>
<li>虽然ActiveRecord取自于本书，然而作者本身并不是把这种模式看成一种自动化的ORM方案。广义的ORM，可以包含Dao(Table Gateway)、Data Transfer Object（json，xml）以及datamapper这些把记录化作内存对象所有模式，但狭义来看ORM是仅包含datamapper的。ActiveRecord在Fowler处其实只是一种Dao的变种。而DHH直接将ActiveRecord升格成了更高度自动化的ORM模式。</li>
<li>在视图层，坚决使用了Helper模式，未加入标签也未停留在scriplet阶段。</li>
</ol>


<p>对我而言，遗憾的一点是很晚才真的读了这本书，不知是喜是优的是因为晚读所以对这本书的内容很认可，而聊以自我安慰的是如果早读了说不定我也能
创造点什么东西，当然，最后一点纯属自娱自乐。<br/>
不过，这本书以及Rails，确实定义了过去10年Web开发的发展方向。因为Rails框架实际上已经成为了Web后台框架的一个标杆，
例如Spring MVC现在走的也是类似的道路。所以，这本书确实深深影响了Web应用的开发。</p>

<p>还有一点值得一提，就是这本书是真的基于Web总结的。很多模式的书籍，其实来源于客户端界面程序，比如从做菜单中提取出来的那些模式，而本书
是基于Web的，这就使得它和很多模式的书籍很不一样了。也因此，它才可以作为Rails的设计蓝图。而所有这些模式，大都来自于实践。实际上，
至今Rails也是Web开发优秀实践的最佳代表。而且Web开发的实践模式也不止书中提到的这些，实际上了解这些模式最好的方法就是接触Rails。虽然现在的模式比本书包含的更多了，本书依然很值得推荐阅读。</p>

<h2>笔记整理</h2>

<p>业务逻辑其实是业务反逻辑： complex business illogic</p>

<h3>分层的坏处</h3>

<ol>
<li>级联变更（Cascading Changes），就是改了一个地方往往要改n个地方</li>
<li>性能损害</li>
</ol>


<p>三层模型之所以能够流行，也是因为Web的流行。Client-Server工具中，是很难实现三层配置使用的。不过如今的App开发，好像也是三层模式。<br/>
但总体而言三层模型的流行是Web和Java等崛起的后果。</p>

<h3>常见的业务代码组织形式</h3>

<ul>
<li>Transaction Script</li>
<li>Domain Module , OO对TS的改变</li>
<li>Service层</li>
</ul>


<h3>会话状态</h3>

<ul>
<li>客户端 Cookie</li>
<li>服务端（内存）</li>
<li>共享服务端（数据库 Redis Memcache 共享文件夹）</li>
</ul>


<h3>分布式</h3>

<p>i
* 不要把不同的功能（对象）组件放在不同的服务器上，这样性能有问题
* 进程间只能尽量使用粗粒度接口，如N+1一次性读取同时返回很多信息
* 同一台服务器内部使用细粒度调用，远程外观模式<br/>
* Data Transfer Object ，传输对象，上面的那种是调用方法
* 同步的接口为主
* 异步的基于消息的处理方式
* 推动你思考而不是代替你思考，最终享受乐趣的是你，承担痛苦的也是你</p>

<h3>锁的种类</h3>

<ol>
<li>乐观锁，比如自己建立版本号；</li>
<li>悲观锁，就是常见的for lock；</li>
<li>粗颗粒（coarse-grainned)锁，就是一堆对象映射成一个入口，在入口处实施加锁；</li>
<li>隐含锁，把锁加到框架里，由Lock Manager和Lock Mapper来实现<strong>模板方法</strong>。</li>
</ol>


<h3>Stub和Mock</h3>

<p>Stub：用一个类直接替换某接口的实现，在测试或开发过程中使用这个替换类<br/>
Mock：用一个服务的重写来模拟某服务</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CentOS5 Ruby2.0 and Rails4.0]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/07/12/centos5-ruby2-dot-0-and-rails4-dot-0/"/>
    <updated>2013-07-12T12:55:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/07/12/centos5-ruby2-dot-0-and-rails4-dot-0</id>
    <content type="html"><![CDATA[<p>升级了一个很小的rails应用到4.0，原先使用的版本ree1.8.7 + rails3.1 。因为应用很小，也没使用很多插件，所以git checkout一个branch之后，用rails new生成新的目录完全替换掉老的文件。然后用<code>git diff</code>对一个一个目录或者文件进行比对与合并。整个过程下来，发现rails默认生成的文件，3.1和4.0的区别并非很大。</p>

<p>这个过程也就是只有几个小时，半天不到的时间就让应用可以跑起来了。本地测试了一下，写入数据库、查询、写入文件等都没什么问题。随后自然就是部署。</p>

<p>但此时，问题来了. 本地开发的环境是这样的：</p>

<ul>
<li>Ubuntu 12.04</li>
<li>gcc version 4.6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5)</li>
<li>ruby 2.0.0p195 (2013-05-14 revision 40734) [x86_64-linux]</li>
<li>rails 4</li>
</ul>


<p>而部署环境是这样的：</p>

<ul>
<li>CentOS release 5.4</li>
<li>gcc 版本 4.1.2 20080704</li>
<li>ruby 2.0.0p247 (2013-06-27) [i686-linux]</li>
<li>rails 4</li>
</ul>


<p>在本地运作良好的rails4应用，部署到生产环境后发生下面两个异常：</p>

<p>1 <code>rake db:migrate</code>每次只能成功一个migrate，但经反复执行后，能够migrate完整
<code>
SQLite3::SQLException: SQL logic error or missing database: INSERT INTO "schema_migrations" ("version") VALUES (?)
</code>
2 开发环境下正常，生产环境下会报告<code>nil?</code>在某个object上不存在。</p>

<p>为此，则折腾掉了很多的业余时间。</p>

<p>怀疑过是Gem的版本问题，怀疑过是ruby版本的问题,也怀疑过是ruby编译问题。</p>

<p>针对第一种可能，重新生成了一个rails应用，执行的结果照旧。<br/>
为了第二种可能，使用了ruby2.0.0p195，异常依旧；换成ruby1.9.3，但发现有个atom的gem都不能bundle上去。<br/>
随后，针对第三个可能，不惜<strong>升级的了CentOS到5.9</strong>(<code>yum upgrade</code>),为此下载了600MB的更新包。 <br/>
又重新编译安装了ruby2.0.0p0, 哦?!，世界太平了。虽然第一个异常依然，但第二个异常没了，应用是能够跑的起来了。
之后，再重新编译另外两个ruby版本就都可以正常工作了（第一个问题还是在的）。</p>

<p>由此可见，这是一个和gcc版本、os版本及ruby版本都相关的bug。</p>

<h3>教训</h3>

<p>新版的ruby或Rails同CentOS接触的并不好，如果要少麻烦的话，APP的OS还是应该选择Ubuntu。从生态的情况来看，这个责任只能怨CentOS支持的内核、gcc、lib库都过于老旧了。<br/>
之所以这么说，不单单是因为在ruby上碰到这种要比在ubuntu上麻烦的多的情形。从七周七语言的情况看，CentOS即使是CentOS6，也不支持对Haskell的安装，在安装其他语言时，多多少少都会遇到编译麻烦的问题。<br/>
CentOS是基于Redhat的，以稳定（老旧）为荣。而APP则是迅速发展的，因此二者极其容易脱节。所以，APP服务器首选Ubuntu。</p>

<h3>题外话</h3>

<p>从对OS的依赖少这点来看，Java确实做了件很漂亮的事情。一个编译好的jdk文件，可以在几乎全部的主流linux下解压，然后即可使用。部署时也不用担心底层OS是什么实现。所以，如果是Java的应用，继续用CentOS也是不会有很多坑的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deploy a Rails 4 app to Heroku]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/03/04/deploy-a-rails-4-app-to-heroku/"/>
    <updated>2013-03-04T20:03:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/03/04/deploy-a-rails-4-app-to-heroku</id>
    <content type="html"><![CDATA[<p>近期从<code>rvm</code>切换到了<code>rbenv</code>, ruby也全面升级到了2.0.0版本， Rails也装了4.0.0.beta，似乎一切欣欣向荣的样子。<br/>
为了方便测试获取一些设备的浏览器信息，写了一个自动获取并分析<code>User-Agent</code>的应用，并确定发布到heroku上。
在发布的过程中，发现还是有一些陷阱，也差不多被折腾了一个来小时,所以决定记录一下。</p>

<h3>0 事先准备</h3>

<p>虽然我用Heroku的时间可以追溯到很久以前，从 scanty 到 octopress，但到这次才发现其实之前我没在heroku上部署过Rails应用。
但这也意味着，第一我很早以前就有了Heroku的帐号，第二我的机器上的ssh-key同heroku都是打通的，第三已经安装了heroku这个gem。</p>

<h3>1 创建应用</h3>

<p>首先执行
```
heroku apps:create user-agent-show2</p>

<p><code>
这样会在heroku处创建一个stack，目前版本是`cedar`. 同时，在.git/config里面会增加一个heroku分支
</code>
[remote "heroku"]</p>

<pre><code>    url = git@heroku.com:user-agent-show.git
    fetch = +refs/heads/*:refs/remotes/heroku/*
</code></pre>

<p>```</p>

<h3>2 Git push</h3>

<p>随后就可以执行
<code>
git push heroku
</code>
部署应用了。
但这里就会碰到陷阱。首先，Heroku是支持pg的应用，所以需要在Gemfile里增加<code>gem 'pg'</code>，同时也要确保这个gem在本机有依赖的Native包。对于ubuntu，
基本需要安装<code>apt-get install libpq-dev</code> 这个包，不过这个包很小，只有900多KB。</p>

<p>其次，对于assets，可以选择预先执行<code>rake assets:precompile</code>，也可也让heroku在部署时执行。但默认情况下生成的js和css文件是访问不到的。
因为rails 4默认生成environments/production.rb中是这样配置的
<code>
config.serve_static_assets = false
</code>
这个会导致thin或者unicorn不负责对静态文件的处理。如果是基于Nginx或者Apache之类的部署，这点毫无问题，因为代理在收到请求后就处理掉了，但
对于heroku，则在起初时是必须由thin负责这部分内容的，因此需要把上面的配置改成
<code>
config.serve_static_assets = true
</code>
这样才能保证静态文件被正常访问。</p>

<h3>3 数据库更新</h3>

<p><code>
heroku run rake db:migrate
</code></p>

<p>push成功后，就可以执行迁移了。也能执行<code>heroku run bash</code> 等命令去查看云服务器的实际运行情况。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Rails View]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/04/24/the-rails-view/"/>
    <updated>2012-04-24T12:11:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/04/24/the-rails-view</id>
    <content type="html"><![CDATA[<p><a href="http://pragprog.com/book/warv/the-rails-view">The Rails View</a>有pdf版。
是对View层实践的描述，可以认为是对rails的扩展。rails做的最好的还是model、controller这样用ruby写的，是靠强大的mc来
提高v的易写性。而在view层，还是可以有很多工作要做，很多实践经验可以总结。本书正是针对这个领域的作品。</p>

<p>(待续)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RoR捧红的东西]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2011/12/08/ror-penghong/"/>
    <updated>2011-12-08T17:03:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2011/12/08/ror-penghong</id>
    <content type="html"><![CDATA[<p>看见一篇抱怨ruby在国内社区越来越小的帖子。仔细想想，ruby或者说rails在国内的状况始终是不愠不火，她的社区可能在中国的环境下就是不会大。但是如果说到rails社区，似乎捧红了不少软件开发业的亮点。</p>

<p>第一个，自然就是ruby。原本只有日本人知道的脚本语言一年内就完成了全球化，即使六七年过去了，说起ruby的杀手级应用依然是rails.很多人学python是因为google支持python，这方面ruby的支撑巨头显然少的多。</p>

<p>第二个，应该算nginx。原本只有懂俄语的人才会去架设的web服务器，因为反向代理在rails的部署方面的表现，变得为人熟知。尽管这是nginx的实力是她本身的性能优势实在出众。但不可否认，rails也是nginx引导向全球的主要突破者。</p>

<p>第三个，git和github。git是系出名门。为人所知则是从Rails自svn迁移到git起始。随后就出现一轮狂飙，众多主流开源软件纷纷开始往git，实际上是github进行迁移。git和github今日的成就已有目共睹，说是傍上rails才火的那么有爆发性并不为过。当然关键还是看自身的底子，比较起来，当时同时一起迁移的票据系统lighthouse则黯淡的多。</p>

<p>第四个，heroku。如果说其他几个是不论rails在与不在，他们全都存在。但是heroku则是没有rails就不会有她的。时至今日，heroku已经是一个多语言环境的PaaS，但头两三年确实一直只支持ruby系的web框架，完全以此起家。</p>

<p>下一个会是什么？coffee.js或者其他什么东西。这个还真的难以预料。因为以上这些全是rails发展过程中的副产品，捧谁不捧谁只有天知道，捧得起捧不起只有看被捧的东西。Rails自己关心的始终是web开发的创新。</p>

<p>从中我们也可以发现，国外的软件生态圈更多的是n样独立的东西共赢发展，每样独立的东西本身规模都比较小。这和我们这个民族所向往的求最大、求一体化完全是两码事情。</p>
]]></content>
  </entry>
  
</feed>
