<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: rails | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2013-06-12T17:11:12+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Deploy a Rails 4 app to Heroku]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/03/04/deploy-a-rails-4-app-to-heroku/"/>
    <updated>2013-03-04T20:03:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/03/04/deploy-a-rails-4-app-to-heroku</id>
    <content type="html"><![CDATA[<p>近期从<code>rvm</code>切换到了<code>rbenv</code>, ruby也全面升级到了2.0.0版本， Rails也装了4.0.0.beta，似乎一切欣欣向荣的样子。<br/>
为了方便测试获取一些设备的浏览器信息，写了一个自动获取并分析<code>User-Agent</code>的应用，并确定发布到heroku上。
在发布的过程中，发现还是有一些陷阱，也差不多被折腾了一个来小时,所以决定记录一下。</p>

<h3>0 事先准备</h3>

<p>虽然我用Heroku的时间可以追溯到很久以前，从 scanty 到 octopress，但到这次才发现其实之前我没在heroku上部署过Rails应用。
但这也意味着，第一我很早以前就有了Heroku的帐号，第二我的机器上的ssh-key同heroku都是打通的，第三已经安装了heroku这个gem。</p>

<h3>1 创建应用</h3>

<p>首先执行
```
heroku apps:create user-agent-show2</p>

<p><code>
这样会在heroku处创建一个stack，目前版本是`cedar`. 同时，在.git/config里面会增加一个heroku分支
</code>
[remote "heroku"]</p>

<pre><code>    url = git@heroku.com:user-agent-show.git
    fetch = +refs/heads/*:refs/remotes/heroku/*
</code></pre>

<p>```</p>

<h3>2 Git push</h3>

<p>随后就可以执行
<code>
git push heroku
</code>
部署应用了。
但这里就会碰到陷阱。首先，Heroku是支持pg的应用，所以需要在Gemfile里增加<code>gem 'pg'</code>，同时也要确保这个gem在本机有依赖的Native包。对于ubuntu，
基本需要安装<code>apt-get install libpq-dev</code> 这个包，不过这个包很小，只有900多KB。</p>

<p>其次，对于assets，可以选择预先执行<code>rake assets:precompile</code>，也可也让heroku在部署时执行。但默认情况下生成的js和css文件是访问不到的。
因为rails 4默认生成environments/production.rb中是这样配置的
<code>
config.serve_static_assets = false
</code>
这个会导致thin或者unicorn不负责对静态文件的处理。如果是基于Nginx或者Apache之类的部署，这点毫无问题，因为代理在收到请求后就处理掉了，但
对于heroku，则在起初时是必须由thin负责这部分内容的，因此需要把上面的配置改成
<code>
config.serve_static_assets = true
</code>
这样才能保证静态文件被正常访问。</p>

<h3>3 数据库更新</h3>

<p><code>
heroku run rake db:migrate
</code></p>

<p>push成功后，就可以执行迁移了。也能执行<code>heroku run bash</code> 等命令去查看云服务器的实际运行情况。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Rails View]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/04/24/the-rails-view/"/>
    <updated>2012-04-24T12:11:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/04/24/the-rails-view</id>
    <content type="html"><![CDATA[<p><a href="http://pragprog.com/book/warv/the-rails-view">The Rails View</a>有pdf版。
是对View层实践的描述，可以认为是对rails的扩展。rails做的最好的还是model、controller这样用ruby写的，是靠强大的mc来
提高v的易写性。而在view层，还是可以有很多工作要做，很多实践经验可以总结。本书正是针对这个领域的作品。</p>

<p>(待续)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RoR捧红的东西]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2011/12/08/ror-penghong/"/>
    <updated>2011-12-08T17:03:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2011/12/08/ror-penghong</id>
    <content type="html"><![CDATA[<p>看见一篇抱怨ruby在国内社区越来越小的帖子。仔细想想，ruby或者说rails在国内的状况始终是不愠不火，她的社区可能在中国的环境下就是不会大。但是如果说到rails社区，似乎捧红了不少软件开发业的亮点。</p>

<p>第一个，自然就是ruby。原本只有日本人知道的脚本语言一年内就完成了全球化，即使六七年过去了，说起ruby的杀手级应用依然是rails.很多人学python是因为google支持python，这方面ruby的支撑巨头显然少的多。</p>

<p>第二个，应该算nginx。原本只有懂俄语的人才会去架设的web服务器，因为反向代理在rails的部署方面的表现，变得为人熟知。尽管这是nginx的实力是她本身的性能优势实在出众。但不可否认，rails也是nginx引导向全球的主要突破者。</p>

<p>第三个，git和github。git是系出名门。为人所知则是从Rails自svn迁移到git起始。随后就出现一轮狂飙，众多主流开源软件纷纷开始往git，实际上是github进行迁移。git和github今日的成就已有目共睹，说是傍上rails才火的那么有爆发性并不为过。当然关键还是看自身的底子，比较起来，当时同时一起迁移的票据系统lighthouse则黯淡的多。</p>

<p>第四个，heroku。如果说其他几个是不论rails在与不在，他们全都存在。但是heroku则是没有rails就不会有她的。时至今日，heroku已经是一个多语言环境的PaaS，但头两三年确实一直只支持ruby系的web框架，完全以此起家。</p>

<p>下一个会是什么？coffee.js或者其他什么东西。这个还真的难以预料。因为以上这些全是rails发展过程中的副产品，捧谁不捧谁只有天知道，捧得起捧不起只有看被捧的东西。Rails自己关心的始终是web开发的创新。</p>

<p>从中我们也可以发现，国外的软件生态圈更多的是n样独立的东西共赢发展，每样独立的东西本身规模都比较小。这和我们这个民族所向往的求最大、求一体化完全是两码事情。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[zz]Rails与Merb合并背后的故事]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2011/06/21/inside-rails-and-merb/"/>
    <updated>2011-06-21T16:48:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2011/06/21/inside-rails-and-merb</id>
    <content type="html"><![CDATA[<p>Rails的目标是减少cost并带来极大的方便，而yehuda提出的现代化框架虽然有架构之美，但对方便性却没什么意义，效益增收不明显，而且实践极难，所以rails团队一直没做。</p>

<pre><code>*
* [閒聊] Rails 與 Merb 合併背後的故事 剛剛有感而發，在公司開發的 microblog上寫了一段 Rails 與 Merb 合併的故事，以作
</code></pre>

<p>1
2010-03-10 　　
发表:xdite</p>

<p>剛剛有感而發，在公司開發的 microblog上寫了一段 Rails 與 Merb 合併的故事，以作為一些事情的借鏡。後來覺得寫太長了，所以就乾脆整理一下貼過來…</p>

<p>====</p>

<p>Merb 當初是為了要解決 Rails 沒辦法解決的問題，比如說上傳檔案會造成整個網站 hang 住才開始開發的。在 Yehuda 當初設計的哲學之中，他認為 Framework 內部要能夠 modularity 。同時要能實現 ORM Agnosticism，甚至不只 ORM ，包括 javascript library 之類的也都必須要可以這麼做。最後幹出了一套 merb。於是在 2008 年逐漸形成了 Rails 與 Merb 之爭。</p>

<p>但 Merb 越來越開發到最後，core team 發現到一件事，”過於自由” 並不會帶來開發上的便利，反而形成 Merb 內部 component dependency 的 conflict。同時，對於寫出一套 Merb application，不像 Rails 一樣，大家並沒有很清楚的開發標準與 Best Practice，而光看教學文件，因為版本與寫法的關係，造成有心踏入 merb 的開發者一天到晚踩中難以解決的地雷。</p>

<p>更糟糕的是，跳槽來 Merb 的人都是前 Rails 開發者，雖然他們多半是不滿 Rails 的束縛過來的，但他們過來之後，對 Merb 最大的抱怨變成：Merb 並沒有 Rails 那麼便利。這個沒有，那個沒有 ….</p>

<p>剛開始，Merb 的核心團隊，對於這些抱怨，解決之道，就是你喊缺，我們就加！但寫到最後越來越不對勁。他們越來越接近在「重寫」一個 Rails 而已。但這些開發者並不會感激他們。開發者還是只會抱怨 Merb 相比起 Rails「還」缺了甚麼。</p>

<p>加功能，並不會讓 Merb 從此以後取代 Rails，只是永無止盡的追趕和重造輪子，但是開發者還是只是會繼續抱怨。而且，一個 Community 再大，力量也只撐的起一個「主流」Framework。Merb 與 Rails 之爭，相當的損害了社群的開發元氣。</p>

<p>Yehuda 覺得這樣發展下去並不是他的本意。於是找上了 Rails core team 談。一談之下，才達成了現在的合併共識。Rails Core Team 覺得 Yehuda 提的 modulity 與 API 是很好的提議，只是他們「不在乎」。這個不在乎並不是真的不在乎，而是 Rails 的 goal 是壓縮開發的 cost，讓 convention 達到最大化，在此目標之下，要做這件事並沒有太大的實質效益，而且他們這些人的力量與技術能力也不夠做這件事。</p>

<p>而 Yehuda 的原意是他要解決 Rails 沒有辦法達成的事，同時帶進他覺得 modern framework 應該要有的設計，這樣才能讓整個 framework scable，連帶 application 也 scable。而非玩到如今的局面 :「 硬是重造一個 Rails」。既然 Rails core team 也覺得 Yehuda 提的很好很重要，只是他們沒能力去做。而如今 Yehuda 也有能力有意願去做，那就讓他加入 Rails core team 做這件事吧。</p>

<p>所以才造就現在看到的偉大 framework : Rails 3。</p>

<p>====</p>

<p>apply 到一些場景，真是感觸良多啊 /_\</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的开发环境]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2011/06/20/my-developing-environment/"/>
    <updated>2011-06-20T15:48:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2011/06/20/my-developing-environment</id>
    <content type="html"><![CDATA[<p>牵涉到的软件：</p>

<p>vmware</p>

<p>  ubuntu1104</p>

<pre><code>ssh

rvm

 ruby gem rails thin
</code></pre>

<p>windows</p>

<p>  securecrt</p>

<p>  radrails</p>

<pre><code>rse 远程控制插件
Target Management 3.0 Update Site   http://download.eclipse.org/dsdp/tm/updates/3.0 Enabled
</code></pre>

<p>其实就是通过一个virtualbox的方式，将rails的环境安装在ubuntu上。而ide利用radrails+ssh通道的方式访问整个虚拟机的目录，同时搭配securecrt的console能力。可以说，这是在windows下最好的方案。考虑到中文等支持，可能也是比ubuntu下直接利用netbeans等开发更好的方案了。</p>

<p>具体做法，前提是vmware上装好ubuntu，同时装好并启用ssh
sudo apt-get install openssh-server</p>

<p>然后，下载最新版的radrails，安装后，选择安装软件，更新增加里面的rse插件，基本做法可以是输入remote
　　让系统去filter
　　。</p>
]]></content>
  </entry>
  
</feed>
