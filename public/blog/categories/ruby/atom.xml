<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: ruby | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2013-06-05T23:17:39+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[为什么ruby不火仍然值得学]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/03/24/wei-shi-yao-rubybu-huo-reng-ran-zhi-de-xue/"/>
    <updated>2013-03-24T16:14:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/03/24/wei-shi-yao-rubybu-huo-reng-ran-zhi-de-xue</id>
    <content type="html"><![CDATA[<p>从某些角度而言，这本不是问题，毕竟因为什么东西火就去学习什么东西的话，那么学与不学什么就无需再计较了。世上总有火的和流行的东西，仅就IT而言，Java火了很多年，这几年安卓 iOS的开发者的需求也很旺盛。如果想学火的东西，那么尽可以去学这些。一旦一样一个东西不怎么火，<strong>反而更可以看出大家为什么要学它。</strong></p>

<p>喜欢ruby可以有多个理由，特别是在rails引进门之后。在我看来，可以有以下几点。</p>

<h3>1. 简单</h3>

<p>换个术语可以叫做用户友好。ruby确实是简单的，相对于C、JavaScript而言。当然，ruby也可以用的很复杂，只是那通常是不需要进入的。</p>

<h3>2. 方便</h3>

<p>这是所有脚本语言的特长，写起来比较方便，不啰嗦。Java也很简单，但是太啰嗦，还需要编译等，所以我还是倾向于在辅助任务中使用ruby而非java。
方便的另一个同义词是表达力强。拥有的表达方式多，而且够简短，即信息量高。</p>

<h3>3.程序员（IT人员）的朋友</h3>

<p>和友好性不同，这是指真的可以用来作为日常工作的工具，用IT技术解决自己工作中的问题。而不仅仅是用IT技术解决客户等其他人的问题。</p>

<h3>4. Rails</h3>

<p>不可忽视，很多人是因为Rails才接触了ruby。至于为什么要学Rails，那可以单独再开一片文章了。大体上是因为Rails的先进和效率。但是，Rails
的引入<strong>大大提高了学习曲线</strong>。Ruby是简单的，不过加进Rails，那就复杂了。
不过如果想用Rails，想通过Rails学习东西，学习一些好的实践和想法，就必须去学习Ruby。</p>

<p>以上是我对ruby不够火的回答。希望学习火的东西人可以去学当前热门的那些东西。Java太平常的话，那就iOS开发、安卓开发，这些都是大面积缺人的。当然，我揣测提问者心里真实的想法是：
现在学ruby是希望今后有一天她能火，然后自己就可以抬高身价。而这东西既然始终不火，那似乎就没有投资学习的必要。</p>

<p>对于这种想法，自然是没有问题的。关键还是在于有没有其他的投资方向。如果有而且看准了，自然可以去新的方向。我们不是Mats也不是DHH，即使是学ruby的人离开也不会有很大的损失，何况本来就持观望态度的人呢？</p>

<p>如果是想靠web技术发财，那么最重要的还是棒个好的创业伙伴，技术此时是次要的，业务和产品才是关键。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[notes of matz on Ruby 2.0 at herokus waza]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/03/08/notes-of-matz-on-ruby-2-dot-0-at-herokus-waza/"/>
    <updated>2013-03-08T11:15:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/03/08/notes-of-matz-on-ruby-2-dot-0-at-herokus-waza</id>
    <content type="html"><![CDATA[<p><a href="https://speakerdeck.com/yukihiro_matz/ruby-2-dot-0-en">Mats Ruby 2.0</a>
的笔记。</p>

<p>首先讲了Ruby的历史</p>

<ul>
<li>Dec 1995 0.95</li>
<li>Dec 1996 1.0</li>
<li>Aug 1997 1.1</li>
<li>Dec 1998 1.2</li>
<li>Aug 1999 1.4</li>
<li>Sep 2000 1.6</li>
</ul>


<p>以上是节假日驱动开发，后来改成了周年纪念开发，呵呵。</p>

<p>voccation-driven development<br/>
Anniversary-driven development</p>

<ul>
<li>Aug 2003 1.8</li>
<li>Dec 2007 1.9.0</li>
<li>Aug 2010 1.9.2</li>
<li>Oct 2011 1.9.3</li>
<li>Feb 2013 2.0.0</li>
</ul>


<p>2.0版最早是在Ruby Conf 2001提出，包括</p>

<ul>
<li>new GC</li>
<li>native Thread with GIL</li>
<li>有些特性后来放弃了</li>
</ul>


<p>2.0的发布带来了：</p>

<ul>
<li>New Hash literals</li>
</ul>


<p><code>
  {foo: 1, bar: 2} =&gt; {:foo=&gt;1, :bar=&gt;2}
</code></p>

<ul>
<li>keyword arguments</li>
</ul>


<p>```
  def log(msg, level: "ERROR", time: Time.now)</p>

<pre><code>puts "..."
</code></pre>

<p>  end</p>

<p>  # existing hash passing
  log("Hello!", **hash)
```</p>

<ul>
<li>Module#prepend, alias method chain, from CommonLisp</li>
</ul>


<p>```</p>

<h1>prepend put them before to wrap methods</h1>

<p>class Foo
  def foo; p :foo; end
end</p>

<p>module Prepend
  def foo</p>

<pre><code>p :before
super
p :after
</code></pre>

<p>  end
end</p>

<p>class Foo
  prepend Prepend # just as include Prepend
end</p>

<p>Foo.new.foo</p>

<p>```</p>

<ul>
<li>refine，to constrain open class, scoped monkey patching</li>
</ul>


<p>```
module R
  refine String do</p>

<pre><code>def foo
  puts "aaa"
end
</code></pre>

<p>  end
end</p>

<p>"".foo # => error!</p>

<p>using R
"".foo
```</p>

<p>Java 和 Smalltalk有classbox的概念，也与此类似</p>

<ul>
<li>Enumerable#lazy， 受函数式编程影响</li>
</ul>


<p><code>
(1..Float::INFINITY).lazy.map {|i|
  i.to_s
}.select {|s|
  /3/ === s
}.first(500000)
</code></p>

<ul>
<li>Symbol array literals</li>
</ul>


<p><code>
%i(foo bar baz) =&gt; [:foo, :bar, :baz]
</code></p>

<ul>
<li><p>to_h, to_hash</p></li>
<li><p>UTF-8 by default</p></li>
<li><p>Performance Faster:</p>

<ul>
<li>VM(YARV)</li>
<li>GC</li>
<li>require</li>
</ul>
</li>
</ul>


<p>Ruby 2.1 maybe 25.12.2013</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deploy a Rails 4 app to Heroku]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/03/04/deploy-a-rails-4-app-to-heroku/"/>
    <updated>2013-03-04T20:03:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/03/04/deploy-a-rails-4-app-to-heroku</id>
    <content type="html"><![CDATA[<p>近期从<code>rvm</code>切换到了<code>rbenv</code>, ruby也全面升级到了2.0.0版本， Rails也装了4.0.0.beta，似乎一切欣欣向荣的样子。<br/>
为了方便测试获取一些设备的浏览器信息，写了一个自动获取并分析<code>User-Agent</code>的应用，并确定发布到heroku上。
在发布的过程中，发现还是有一些陷阱，也差不多被折腾了一个来小时,所以决定记录一下。</p>

<h3>0 事先准备</h3>

<p>虽然我用Heroku的时间可以追溯到很久以前，从 scanty 到 octopress，但到这次才发现其实之前我没在heroku上部署过Rails应用。
但这也意味着，第一我很早以前就有了Heroku的帐号，第二我的机器上的ssh-key同heroku都是打通的，第三已经安装了heroku这个gem。</p>

<h3>1 创建应用</h3>

<p>首先执行
```
heroku apps:create user-agent-show2</p>

<p><code>
这样会在heroku处创建一个stack，目前版本是`cedar`. 同时，在.git/config里面会增加一个heroku分支
</code>
[remote "heroku"]</p>

<pre><code>    url = git@heroku.com:user-agent-show.git
    fetch = +refs/heads/*:refs/remotes/heroku/*
</code></pre>

<p>```</p>

<h3>2 Git push</h3>

<p>随后就可以执行
<code>
git push heroku
</code>
部署应用了。
但这里就会碰到陷阱。首先，Heroku是支持pg的应用，所以需要在Gemfile里增加<code>gem 'pg'</code>，同时也要确保这个gem在本机有依赖的Native包。对于ubuntu，
基本需要安装<code>apt-get install libpq-dev</code> 这个包，不过这个包很小，只有900多KB。</p>

<p>其次，对于assets，可以选择预先执行<code>rake assets:precompile</code>，也可也让heroku在部署时执行。但默认情况下生成的js和css文件是访问不到的。
因为rails 4默认生成environments/production.rb中是这样配置的
<code>
config.serve_static_assets = false
</code>
这个会导致thin或者unicorn不负责对静态文件的处理。如果是基于Nginx或者Apache之类的部署，这点毫无问题，因为代理在收到请求后就处理掉了，但
对于heroku，则在起初时是必须由thin负责这部分内容的，因此需要把上面的配置改成
<code>
config.serve_static_assets = true
</code>
这样才能保证静态文件被正常访问。</p>

<h3>3 数据库更新</h3>

<p><code>
heroku run rake db:migrate
</code></p>

<p>push成功后，就可以执行迁移了。也能执行<code>heroku run bash</code> 等命令去查看云服务器的实际运行情况。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Every language will implement a lisp interpreter in itself]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/02/03/every-language-will-implement-a-lisp-interpreter-in-itself/"/>
    <updated>2013-02-03T12:48:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/02/03/every-language-will-implement-a-lisp-interpreter-in-itself</id>
    <content type="html"><![CDATA[<p>H&amp;P里面这句话起初还有点琢磨不过来，后来看了下jstl等东西，这不就是表达式在java中的一个实现么。</p>

<p>从头开始讲的话，需要从web开发讲起。Web中最耗开发时间的是页面的开发，因为在这个环节一切编程的好东西都是没有引入的。比如C的头文件有include检察，
而css依然一团乱；其他语言有的各类引用机制，到了页面全部木有。而在页面上的代码，主要有下面两种模式：</p>

<ul>
<li><code>&lt;% %&gt;</code> <code>&lt;%= %&gt;</code>这样的代码嵌入</li>
<li>代码标签及各类膜拜，如jstl标签，struts2标签，velocity模板等</li>
</ul>


<p>仔细观察，可以发现第二种代码标签和模板其实就是实现了一套语言解析器。往往Java的就用Java实现，有些语言就用自己的实现。
正好印证了Paul的话。为了应付实际的表达困难，表达力弱一些的语言不得不自建一套<strong>类Lisp的语言表达解释器</strong>。</p>

<p>所以，表达力越差（可以理解成
啰嗦、信息量低）的语言，其搭配的解释器可能越五花八门，因为<code>&lt;% %&gt;</code>是很难适应这类语言嵌入在Html中的需求的。而能力强的语言，则模板就要少许多，
因为语言本身的表达力强大，使得再造一套标签显得很没有必要，自然也就无人发明此类模板。</p>

<p>从表达力而言，Java确实较次些。按Paul的理论那就Ruby更接近Lisp。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Heredocs 和缩进]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/04/19/heredocs/"/>
    <updated>2012-04-19T12:41:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/04/19/heredocs</id>
    <content type="html"><![CDATA[<h3>heredocs是什么</h3>

<p><strong>heredocs</strong>适用于在代码中写一长串文档赋给变量的情形。标准的ruby heredocs是这样的</p>

<p><code>ruby
text = &lt;&lt;END
aaa
bbb
ccc
END
</code></p>

<p>但是使用heredocs的时候常有<strong>时灵时不灵</strong>的情形，这个陷阱在于最后一行的缩进。默认情况下，END是必须顶格的，比如可以这样写</p>

<p>```ruby
class Poem
  def initialize</p>

<pre><code>@text = &lt;&lt;END
</code></pre>

<p>"Faith" is a fine invention
When Gentlemen can see
But Microscopes are prudent</p>

<pre><code>       In an Emergency.
</code></pre>

<p>(Emily Dickinson 1830-1886)
END
  end
  def recite</p>

<pre><code>puts @text
</code></pre>

<p>  end
end
```</p>

<p>但是这样写就是<strong>不行</strong>了：</p>

<p><code>ruby
text = &lt;&lt;END
  aaa
  bbb
  END #END加了缩进就失败
</code></p>

<h3>解决办法</h3>

<p>在第一个END前面加<code>-</code>，即使用<code>-END</code>，会让最后结束符<code> END</code>前的空白都被忽略，而<strong>内容前面的空白则会被保留</strong>。如果也要去掉，可以使用gsub.
此处END可以换成任意大写字符，只要成对匹配即可。
```ruby
class Poem
  def initialize</p>

<pre><code>@text = &lt;&lt;-END.gsub(/^ {6}/, '')
  "Faith" is a fine invention
  When Gentlemen can see
  But Microscopes are prudent
             In an Emergency.
  (Emily Dickinson 1830-1886)
END
</code></pre>

<p>  end
  def recite</p>

<pre><code>puts @text
</code></pre>

<p>  end
end
```</p>

<h3><code>%w</code>是何方神圣</h3>

<p>有几次，我直接使用<code>%w{}</code>以为解决了这个问题。但实际上得到是一个Array。只不过Array.to_s又会获得和heredocs一样的效果，在使用ruby1.9的前提下。
%w要灵活方便的多吧，但这个确实不是heredocs，它只是数组。</p>

<p>```ruby
text2 = %w{
aaa
bbb
ccc
  dddd</p>

<pre><code>  }
</code></pre>

<p>puts text2
```</p>

<ul>
<li><a href="http://www.bitcetera.com/en/techblog/2009/07/02/heredoc-with-indent-in-ruby/">引用链接1</a></li>
<li><a href="https://github.com/styleguide/ruby">引用链接2</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
