<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: ruby | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2013-03-04T21:53:14+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Deploy a Rails 4 app to Heroku]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/03/04/deploy-a-rails-4-app-to-heroku/"/>
    <updated>2013-03-04T20:03:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/03/04/deploy-a-rails-4-app-to-heroku</id>
    <content type="html"><![CDATA[<p>近期从<code>rvm</code>切换到了<code>rbenv</code>, ruby也全面升级到了2.0.0版本， Rails也装了4.0.0.beta，似乎一切欣欣向荣的样子。<br/>
为了方便测试获取一些设备的浏览器信息，写了一个自动获取并分析<code>User-Agent</code>的应用，并确定发布到heroku上。
在发布的过程中，发现还是有一些陷阱，也差不多被折腾了一个来小时,所以决定记录一下。</p>

<h3>0 事先准备</h3>

<p>虽然我用Heroku的时间可以追溯到很久以前，从 scanty 到 octopress，但到这次才发现其实之前我没在heroku上部署过Rails应用。
但这也意味着，第一我很早以前就有了Heroku的帐号，第二我的机器上的ssh-key同heroku都是打通的，第三已经安装了heroku这个gem。</p>

<h3>1 创建应用</h3>

<p>首先执行
```
heroku apps:create user-agent-show2</p>

<p><code>
这样会在heroku处创建一个stack，目前版本是`cedar`. 同时，在.git/config里面会增加一个heroku分支
</code>
[remote "heroku"]</p>

<pre><code>    url = git@heroku.com:user-agent-show.git
    fetch = +refs/heads/*:refs/remotes/heroku/*
</code></pre>

<p>```</p>

<h3>2 Git push</h3>

<p>随后就可以执行
<code>
git push heroku
</code>
部署应用了。
但这里就会碰到陷阱。首先，Heroku是支持pg的应用，所以需要在Gemfile里增加<code>gem 'pg'</code>，同时也要确保这个gem在本机有依赖的Native包。对于ubuntu，
基本需要安装<code>apt-get install libpq-dev</code> 这个包，不过这个包很小，只有900多KB。</p>

<p>其次，对于assets，可以选择预先执行<code>rake assets:precompile</code>，也可也让heroku在部署时执行。但默认情况下生成的js和css文件是访问不到的。
因为rails 4默认生成environments/production.rb中是这样配置的
<code>
config.serve_static_assets = false
</code>
这个会导致thin或者unicorn不负责对静态文件的处理。如果是基于Nginx或者Apache之类的部署，这点毫无问题，因为代理在收到请求后就处理掉了，但
对于heroku，则在起初时是必须由thin负责这部分内容的，因此需要把上面的配置改成
<code>
config.serve_static_assets = true
</code>
这样才能保证静态文件被正常访问。</p>

<h3>3 数据库更新</h3>

<p><code>
heroku run rake db:migrate
</code></p>

<p>push成功后，就可以执行迁移了。也能执行<code>heroku run bash</code> 等命令去查看云服务器的实际运行情况。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Change to Ruby 2.0.0]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/02/26/change-to-ruby-2-dot-0-0/"/>
    <updated>2013-02-26T11:30:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/02/26/change-to-ruby-2-dot-0-0</id>
    <content type="html"><![CDATA[<p>借着Ruby 2.0.0发布的东风，又加之Rails 也发布了4.0.beta来给献礼，营造了RR24，我也把octopress升级到了ruby 2.0.0.</p>

<p>步骤如下：</p>

<ol>
<li>在Gemfile中加入 <code>ruby "2.0.0"</code></li>
<li>更新Gemfile中其他的一些gem，把octopress最新版的内容加进来即可，否则可能还是不能和2.0兼容的</li>
<li><code>bundle intall</code>, <code>bundle install --binstubs</code></li>
<li><code>git commit -a</code></li>
<li><code>git push heroku</code></li>
</ol>


<p>```
Counting objects: 119, done.
Compressing objects: 100% (59/59), done.
Writing objects: 100% (60/60), 5.46 KiB, done.
Total 60 (delta 32), reused 0 (delta 0)
-----> Deleting 5 files matching .slugignore patterns.
-----> Ruby/Rack app detected
-----> Using Ruby version: ruby-2.0.0
-----> Installing dependencies using Bundler version 1.3.0.pre.5</p>

<pre><code>   Ruby version change detected. Clearing bundler cache.
   Old: ruby 1.9.2p290 (2011-07-09 revision 32553) [x86_64-linux]
   New: ruby 2.0.0p0 (2013-02-24 revision 39474) [x86_64-linux]
   Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin --deployment
   Fetching gem metadata from http://ruby.taobao.org/.
   Fetching full source index from http://ruby.taobao.org/
   Installing daemons (1.1.8)
   Installing eventmachine (0.12.10)
   Installing rack (1.4.1)
   Installing rack-protection (1.3.2)
   Installing tilt (1.3.3)
   Installing sinatra (1.3.5)
   Installing thin (1.4.1)
   Using bundler (1.3.0.pre.5)
   Your bundle is complete! It was installed into ./vendor/bundle
   Cleaning up the bundler cache.
</code></pre>

<p>-----> Discovering process types</p>

<pre><code>   Procfile declares types     -&gt; (none)
   Default types for Ruby/Rack -&gt; console, rake, web
</code></pre>

<p>-----> Compiled slug size: 30.5MB
-----> Launching... done, v48
```</p>

<p>但我不太理解slug size为啥变大了。</p>

<p>而且和thin里面的eventmachine配合似乎有问题，可能是版本太老，也可能是别的什么，
于是改用了unicorn，又折腾了Procfile</p>

<p><code>
web: bundle exec unicorn -p $PORT
</code></p>

<p>```
Total 3 (delta 1), reused 0 (delta 0)
-----> Deleting 5 files matching .slugignore patterns.
-----> Ruby/Rack app detected
-----> Using Ruby version: ruby-2.0.0
-----> Installing dependencies using Bundler version 1.3.0.pre.5</p>

<pre><code>   Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin --deployment
   Using kgio (2.8.0)
   Using rack (1.4.5)
   Using rack-protection (1.3.2)
   Using raindrops (0.10.0)
   Using tilt (1.3.3)
   Using sinatra (1.3.5)
   Using unicorn (4.6.2)
   Using bundler (1.3.0.pre.5)
   Your bundle is complete! It was installed into ./vendor/bundle
   Cleaning up the bundler cache.
   Would have removed thin (1.4.1)
   Would have removed daemons (1.1.9)
   Would have removed daemons (1.1.8)
   Would have removed thin (1.5.0)
   Would have removed rack (1.4.1)
   Would have removed eventmachine (1.0.0)
   Would have removed eventmachine (0.12.10)
</code></pre>

<p>-----> Discovering process types</p>

<pre><code>   Procfile declares types     -&gt; web
   Default types for Ruby/Rack -&gt; console, rake
</code></pre>

<p>-----> Compiled slug size: 35.9MB
-----> Launching... done, v53
```</p>

<p>最后重新弄了一下，发现还是很大。</p>

<p>```
Writing objects: 100% (3/3), 281 bytes, done.
Total 3 (delta 2), reused 0 (delta 0)
-----> Deleting 5 files matching .slugignore patterns.
-----> Ruby/Rack app detected
-----> Using Ruby version: ruby-2.0.0
-----> Installing dependencies using Bundler version 1.3.0.pre.5</p>

<pre><code>   Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin --deployment
   Using kgio (2.8.0)
   Using rack (1.4.5)
   Using rack-protection (1.3.2)
   Using raindrops (0.10.0)
   Using tilt (1.3.3)
   Using sinatra (1.3.5)
   Using unicorn (4.6.2)
   Using bundler (1.3.0.pre.5)
   Your bundle is complete! It was installed into ./vendor/bundle
   Cleaning up the bundler cache.
</code></pre>

<p>-----> Discovering process types</p>

<pre><code>   Procfile declares types     -&gt; web
   Default types for Ruby/Rack -&gt; console, rake
</code></pre>

<p>-----> Compiled slug size: 27.3MB
-----> Launching... done, v5</p>

<pre><code>   http://octopresszhangyu.herokuapp.com deployed to Heroku
</code></pre>

<p>```</p>

<p>感觉adam不再怎么发文之后，Heroku有点日趋堕落的趋势。另外，在Procfile里面运用unicorn绝对是个好主义。其效果类似一个dyno(ubuntu)上跑了几个unicorn的进程，
明显处理能力会强于只有一个实例的thin。以上灵感来自<a href="http://blog.codeship.io/2012/05/06/Unicorn-on-Heroku.html">unicorn的部署高人</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Every language will implement a lisp interpreter in itself]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/02/03/every-language-will-implement-a-lisp-interpreter-in-itself/"/>
    <updated>2013-02-03T12:48:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/02/03/every-language-will-implement-a-lisp-interpreter-in-itself</id>
    <content type="html"><![CDATA[<p>H&amp;P里面这句话起初还有点琢磨不过来，后来看了下jstl等东西，这不就是表达式在java中的一个实现么。</p>

<p>从头开始讲的话，需要从web开发讲起。Web中最耗开发时间的是页面的开发，因为在这个环节一切编程的好东西都是没有引入的。比如C的头文件有include检察，
而css依然一团乱；其他语言有的各类引用机制，到了页面全部木有。而在页面上的代码，主要有下面两种模式：</p>

<ul>
<li><code>&lt;% %&gt;</code> <code>&lt;%= %&gt;</code>这样的代码嵌入</li>
<li>代码标签及各类膜拜，如jstl标签，struts2标签，velocity模板等</li>
</ul>


<p>仔细观察，可以发现第二种代码标签和模板其实就是实现了一套语言解析器。往往Java的就用Java实现，有些语言就用自己的实现。
正好印证了Paul的话。为了应付实际的表达困难，表达力弱一些的语言不得不自建一套<strong>类Lisp的语言表达解释器</strong>。</p>

<p>所以，表达力越差（可以理解成
啰嗦、信息量低）的语言，其搭配的解释器可能越五花八门，因为<code>&lt;% %&gt;</code>是很难适应这类语言嵌入在Html中的需求的。而能力强的语言，则模板就要少许多，
因为语言本身的表达力强大，使得再造一套标签显得很没有必要，自然也就无人发明此类模板。</p>

<p>从表达力而言，Java确实较次些。按Paul的理论那就Ruby更接近Lisp。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Heredocs 和缩进]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/04/19/heredocs/"/>
    <updated>2012-04-19T12:41:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/04/19/heredocs</id>
    <content type="html"><![CDATA[<h3>heredocs是什么</h3>

<p><strong>heredocs</strong>适用于在代码中写一长串文档赋给变量的情形。标准的ruby heredocs是这样的</p>

<p><code>ruby
text = &lt;&lt;END
aaa
bbb
ccc
END
</code></p>

<p>但是使用heredocs的时候常有<strong>时灵时不灵</strong>的情形，这个陷阱在于最后一行的缩进。默认情况下，END是必须顶格的，比如可以这样写</p>

<p>```ruby
class Poem
  def initialize</p>

<pre><code>@text = &lt;&lt;END
</code></pre>

<p>"Faith" is a fine invention
When Gentlemen can see
But Microscopes are prudent</p>

<pre><code>       In an Emergency.
</code></pre>

<p>(Emily Dickinson 1830-1886)
END
  end
  def recite</p>

<pre><code>puts @text
</code></pre>

<p>  end
end
```</p>

<p>但是这样写就是<strong>不行</strong>了：</p>

<p><code>ruby
text = &lt;&lt;END
  aaa
  bbb
  END #END加了缩进就失败
</code></p>

<h3>解决办法</h3>

<p>在第一个END前面加<code>-</code>，即使用<code>-END</code>，会让最后结束符<code> END</code>前的空白都被忽略，而<strong>内容前面的空白则会被保留</strong>。如果也要去掉，可以使用gsub.
此处END可以换成任意大写字符，只要成对匹配即可。
```ruby
class Poem
  def initialize</p>

<pre><code>@text = &lt;&lt;-END.gsub(/^ {6}/, '')
  "Faith" is a fine invention
  When Gentlemen can see
  But Microscopes are prudent
             In an Emergency.
  (Emily Dickinson 1830-1886)
END
</code></pre>

<p>  end
  def recite</p>

<pre><code>puts @text
</code></pre>

<p>  end
end
```</p>

<h3><code>%w</code>是何方神圣</h3>

<p>有几次，我直接使用<code>%w{}</code>以为解决了这个问题。但实际上得到是一个Array。只不过Array.to_s又会获得和heredocs一样的效果，在使用ruby1.9的前提下。
%w要灵活方便的多吧，但这个确实不是heredocs，它只是数组。</p>

<p>```ruby
text2 = %w{
aaa
bbb
ccc
  dddd</p>

<pre><code>  }
</code></pre>

<p>puts text2
```</p>

<ul>
<li><a href="http://www.bitcetera.com/en/techblog/2009/07/02/heredoc-with-indent-in-ruby/">引用链接1</a></li>
<li><a href="https://github.com/styleguide/ruby">引用链接2</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Inside 3月链接]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/04/19/some-useful-link/"/>
    <updated>2012-04-19T11:23:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/04/19/some-useful-link</id>
    <content type="html"><![CDATA[<p>发现<a href="http://www.rubyinside.com/march-2012-ruby-news-5841.html?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+RubyInside+%28Ruby+Inside%29">Ruby Inside</a>最近的
文章又好看了起来。选了一些细细研究如下。</p>

<ul>
<li><p><a href="https://github.com/styleguide/ruby">GitHub's Ruby Style Guide</a><br/>
很好的ruby编码规范，来自github，还澄清了我一些似是而非的概念。值得ruby学习者经常review。<br/>
此外，还有<a href="http://tomdoc.org/">tomdoc</a>做编码文档的规范，也需要进一步阅读。</p></li>
<li><p><a href="http://rubysource.com/zero-to-jekyll-in-20-minutes/">jekyll</a></p></li>
</ul>


<p>jekyll是一个输入markdown文件输出site的html的<strong>引擎</strong>。</p>

<p><code>sh
$ mkdir your_blog
$ cd ./your_blog
$ mkdir _layouts _plugins _includes _posts css javascripts images
$ touch index.html _config.yml _layouts/default.html
</code>
目录树结构</p>

<p>```sh
├── README.md
├── <em>config.yml
├── </em>layouts</p>

<pre><code>└── default.html
</code></pre>

<p>├── <em>plugins
├── </em>includes
├── _posts
│   ├── 2012-03-27-your_first_post_in_markdown.md
│   └── 2012-03-27-your_second_post_in_textile.textile
├── css
│   └── screen.css
├── javascripts
├── images
└── index.html
```</p>

<p><code>sh
$ jekyll --server --auto
</code></p>

<p>文档的要求只有一个:</p>

<h2>```sh</h2>

<p>layout: default</p>

<h2>title: Your First Post In Markdown</h2>

<p>```</p>

<p>就会按markdown里面的layout产生内容。</p>

<p>这样就可以明白octopress和jekyll的关系了。o是利用了jekyll做引擎，根据jekyll的目录要求加入了css、布局、图片等，同时还有.rb的一些插件，于是有了这个blog系统。而jekyll则还可以用来写书。道理也是一样的。自己设计layout，然后运行上面的命令即可。</p>

<ul>
<li><a href="http://spin.atomicobject.com/2012/02/28/load-balancing-and-reverse-proxying-with-nginx/">使用Nginx做分发的教程</a></li>
</ul>


<p>基本的内容都有了。而且还有利用nginx实现转发时使用basic验证和加Authorization的例子。</p>

<ul>
<li><a href="http://news.railstutorial.org/ruby-on-rails-tutorial-now-with-twitters-boot">配备了bootstrap的Rails教程</a></li>
</ul>


<p>Bootstrap 是一个优秀的CSS和UI框架，而这个正好是Rails所欠缺的。二者的结合将是威力巨大的。因为Rails可以解决开发中的
<strong>编码效率</strong>问题，但对<strong>界面美化</strong>却不能为力。而Bootstrap可以很好地弥补这一点。有点类似Jekyll和Octopress的关系。
<strong>结果</strong>都是可以让程序员和不具备界面美化能力的项目经理也可以设计出说得过去的应用。</p>

<ul>
<li><p><a href="http://patshaughnessy.net/2012/3/23/why-you-should-be-excited-about-garbage-collection-in-ruby-2-0">ruby 2.0 garbage collection</a></p></li>
<li><p><a href="http://addyosmani.com/blog/building-backbone-js-apps-with-ruby-sinatra-mongodb-and-haml/">building backbone js apps with ruby sinatra mongodb and haml</a></p></li>
</ul>


<p>全篇对backbone基本无介绍，火力集中在sinatra mongodb haml这些东西上了。文章的价值不大。</p>
]]></content>
  </entry>
  
</feed>
