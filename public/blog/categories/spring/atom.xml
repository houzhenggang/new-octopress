<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: spring | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/spring/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2015-05-17T00:26:45+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring 4 中的新东西]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/05/04/spring-4-zhong-de-xin-dong-xi/"/>
    <updated>2015-05-04T14:30:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/05/04/spring-4-zhong-de-xin-dong-xi</id>
    <content type="html"><![CDATA[<p>Spring还在继续提高与演进中。</p>

<h3>3.1中的新东西</h3>

<ul>
<li>environment profiles，支持development、test和production等条件下独特的配置</li>
<li>增加enable annotations，在Java文件配置中</li>
<li>Declarative caching support，像支持事务一样支持缓存</li>
<li>支持Servlet 3.0，包括在java文件中声明servlets和filters，而不仅仅是在web.xml中</li>
<li>JPA支持的提升，可以不再需要persistence.xml</li>
<li>自动绑定路径便利给model属性</li>
<li>支持对Accept和Content-Type消息头的匹配，通过@RequestMappingproduces</li>
<li>绑定部分二进制表单请求给方法参数，通过@RequestPart，比@RequestParam更强大（只能对请求参数数据绑定，key-alue格式），而@RequestPart支持如JSON、XML内容区数据的绑定</li>
<li>flash属性的支持</li>
<li>JpaTemplate和JpaDaoSupport让位于EntityManager</li>
</ul>


<h3>3.2中的新东西</h3>

<ul>
<li>支持servlet 3中的异步请求，使得一个请求可以在独立的线程中被处理，让servlet线程可以处理更多的请求</li>
<li>Spring MVC的test框架，包括RestTemplate的测试支持</li>
<li>@controllerAdvice使得@ModelAttributes等控制器的方法可以在单个类中重新组织</li>
<li>ContentNegotiatingViewResolver</li>
<li>@MatrixVariable</li>
<li>Rest方面的改进与支持</li>
</ul>


<h3>4.0中的新东西</h3>

<ul>
<li>WebSocket的支持，包括JSR-356中Java API对WebSocket的支持</li>
<li>SockJS/STOMP对WebSocket和消息模块的封装</li>
<li>Java 8 特性的应用，比如lambda。callback interface的使用变简单了，如RowMapper和JdbcTemplate</li>
<li>Java 8中的时间日期api</li>
<li>RestTemplate的一个异步版实现</li>
<li>新增对JMS 2.0 JTA 1.2， JPA 2.1的支持</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[静态文件的url后缀md5化]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/01/22/jing-tai-wen-jian-de-urlhou-zhui-md5hua/"/>
    <updated>2015-01-22T09:55:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/01/22/jing-tai-wen-jian-de-urlhou-zhui-md5hua</id>
    <content type="html"><![CDATA[<p>长久以来，在jsp中引入css和JavaScript都是手工硬编的:</p>

<p>```jsp
<link href='http://octopresszhangyu.herokuapp.com/toolbar/static/orderFlow/css/reset.css' rel="stylesheet" type="text/css" /></p>

<script src="http://octopresszhangyu.herokuapp.com/toolbar/static/jquery/jquery.min.js" charset="utf-8"></script>


<p>```</p>

<p>好处很明显，最接近实际生成的html，很直观。坏处在于重复性高，而且无法控制后台生成的随机数，这样不太利于nginx等处理静态资源的缓存。终极方案莫过于在后缀上加上md5指纹信息，这样既可以让nginx等通知浏览器长期缓存，而一旦文件发生变化也必然可以让浏览器再次发起请求获得css和JavaScript。最终生成的页面信息达到下面的效果：</p>

<p>```jsp</p>

<script src="http://octopresszhangyu.herokuapp.com/toolbar/static/jquery/toolbar.js?2dc0cb76e7faa4c150fca76981cbcd20" charset="utf-8"></script>


<p>```</p>

<p>实现包含两部分，一方面需要可以计算出静态文件的md5值，另一方面则是可以在jsp中调用并生成上述html。多番比较后，发现jsp中还是使用标签比较合适，所以继续写tag文件：</p>

<p>style.tag
<code>jsp
&lt;%@ tag pageEncoding="UTF-8" import="com.sanss.toolbar.hepler.BaseHelper" %&gt;
&lt;%@ attribute name="file" type="java.lang.String" required="true" %&gt;
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;c:set var="ctx" value="${pageContext.request.contextPath}" /&gt;
&lt;link href='${ctx}&lt;%=BaseHelper.rtg(file) %&gt;' rel="stylesheet" type="text/css" /&gt;
</code></p>

<p>javascript.tag
```jsp
&lt;%@tag pageEncoding="UTF-8" import="com.sanss.toolbar.hepler.BaseHelper"%>
&lt;%@ attribute name="file" type="java.lang.String" required="true"%>
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
&lt;c:set var="ctx" value="${pageContext.request.contextPath}" /></p>

<script src="${ctx}<%=BaseHelper.rtg(file) %>" charset="utf-8"></script>


<p>```</p>

<p>其中使用到了BaseHelper里面的生成md5后缀级链接的方法<code>rtg(filepath)i</code></p>

<p>```java
/<em>* 生成静态文件链接的公共方法，加上md5后缀或者时间戳。
   * @param resource
   * @return
   </em>/
  public static String rtg(String resource) {</p>

<pre><code>String fileMd5 = fileMD5s.get(resource);
if (StringUtils.isEmpty(fileMd5)) {
  System.out.println(System.getProperty("user.dir"));
  fileMd5 = getFileMD5("../webapps/toolbar/static/"+resource);
  if (StringUtils.isEmpty(fileMd5)) {
    fileMd5 = timestamp;
  }
  fileMD5s.put(resource, fileMd5);
}

return "/static/"+resource+"?"+fileMd5;
</code></pre>

<p>  }
```</p>

<p>最不济的情况下，也能给文件加上启动日期的时间戳。</p>

<p>而在布局或者其他需要引入css和js的页面，直接使用这种代码即可:</p>

<p><code>jsp
&lt;tags:style file="styles/css1.css" /&gt;
&lt;tags:javascript file="jquery/jquery.min.js" /&gt;
&lt;tags:javascript file="jquery/tl.js" /&gt;
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring中的CRON]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/12/28/springzhong-de-cron/"/>
    <updated>2014-12-28T15:12:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/12/28/springzhong-de-cron</id>
    <content type="html"><![CDATA[<p>在<a href="/blog/2014/09/11/webrong-qi-zhong-tong-guo-springtian-jia-jobren-wu/">Web容器中通过Spring添加Job任务</a>一文中，
已经提过在spring中增加例行任务。只是当时提交的任务仅限于间隔一段时间后执行，比如每分钟执行一次，因此使用
<code>period</code> 和 <code>delay</code>两个参数就够了。</p>

<p>这次新遇到的需求是要求定点执行，比如固定在夜间23:30启动，这时候就需要cron了。好在Spring 4.0版
开始已经支持cron，配置起来也很简洁。</p>

<p>首先，在<code>spring-mvc.xml</code>中增加要定期执行的类作为bean，作用是把要定期执行的类交给spring扫描</p>

<p><code>xml
&lt;bean id="LastDayDevicePackorderlogRefreshTaskExecutor" class="com.sanss.toolbar.job.LastDayDevicePackorderlogRefreshTaskExecutor"&gt;
&lt;/bean&gt;
</code></p>

<p>其次，在这个类上使用标注<code>@EnableScheduling</code>，让spring意识到这是一个定期调度启动的任务。</p>

<p>```java
@EnableScheduling
public class LastDayDevicePackorderlogRefreshTaskExecutor implements Runnable {</p>

<p>}
```</p>

<p>最后，是在具体要启动的method上标注<code>@Scheduled(cron = "0 * * * * *")</code>，以此给出具体的执行安排。<br/>
标注中cron的具体含义可以见下面的注释。</p>

<p>```java</p>

<pre><code>/*
 * 一个cron表达式有至少6个（也可能7个）有空格分隔的时间元素。
 *
 * 按顺序依次为 秒（0~59）
 *
 * 分钟（0~59）
 *
 * 小时（0~23）
 *
 * 天（月）（0~31，但是你需要考虑你月的天数）
 *
 * 月（0~11）
 *
 * 天（星期）（1~7 1=SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT）
 *
 * 7.年份（1970－2099）
 */
@Scheduled(cron = "0 * * * * *")
public void run() {
    // TODO Auto-generated method stub
    // doit();
    logger.info("定期触发");
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx 处理Spring 静态资源的配置]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/10/14/nginx-chu-li-spring-jing-tai-zi-yuan-de-pei-zhi/"/>
    <updated>2014-10-14T13:19:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/10/14/nginx-chu-li-spring-jing-tai-zi-yuan-de-pei-zhi</id>
    <content type="html"><![CDATA[<p>用Nginx处理静态资源是挺常见的一个事情，自从使用了Spring，也经常直接利用Spring的处理静态文件的功能，也能打上Etag。避免流量传输。
但是近来发现，Spring处理静态资源后，对静态文件获取的请求浏览器还是会发起，只是每次都是返回304。所以想继续借助Nginx给Spring的静态资源打上expire的标记。</p>

<p>需求也算简单：</p>

<ol>
<li>基于app toolbar的动态请求转发给java</li>
<li>gif,png，js等nginx直接处理，并加expire 3h；</li>
<li>部分.js请求如t.js还是转给java，有效期为0；</li>
<li>敏感文件不会被nginx处理，如web.xml无法被nginx转走</li>
</ol>


<p>因为目前Spring的静态资源单独存放在和WEB-INF并排的目录下，所以利用Nginx配置就大为简单了，只要限制路径名称即可。</p>

<p>```</p>

<pre><code>    location /toolbar {
        root   html;
        proxy_pass http://192.168.203.198:8080;
    }
    location ~ /toolbar/static {
        root   html;
        if (-f $request_filename) {
            expires 1d;
            break;
        }
    }
    location = /toolbar/enter/t.js {
        root   html;
        proxy_pass http://192.168.202.72:8080;
    }
</code></pre>

<p>```</p>

<p>然后在nginx的html目录下建立目录<code>toolbar</code>，并在其增加一个符号连接<code>ln -s /home/web/apache-tomcat-7.0.56/webapps/toolbar/static static</code>，就可以实现上述要求了。</p>

<p>这里面用到了几种Nginx的配置。</p>

<ol>
<li><code>location /toolbar</code>，这是最基本的匹配字符串的表达方式，优先级一般情况下也最低，然而<code>^~</code>是一个例外，它的优先级比下面的正则要高。</li>
<li><code>location ~ /toolbar/static</code>，这个是用到了正则表达式的匹配，优先级要高于基础的只比较字符。</li>
<li><code>location = /toolbar/enter/t.js</code>，这是优先级最高的匹配符，要求uri完全相等。</li>
</ol>


<p>如果需要使用正则表达式匹配，则必须使用<code>~</code>或者<code>~*</code>，其中后者和前者的区别是不区分大小写。</p>

<p>整个匹配顺序是：</p>

<ol>
<li>对<code>=</code>进行匹配，有相符的就停止；</li>
<li>对所有的非正则表达式（为使用~ 和 ~*）进行匹配，如果遇到<code>^~</code>则也停止，否则全部比对完毕后，最接近的匹配将被选用作为候选，随后进入3匹配正则表达式；</li>
<li>正则表达式按定义的顺序进行匹配，有匹配的则停止，即可选用刚刚匹配的正则表达式，如没有匹配的正则，则选用2中得到的结果。</li>
</ol>


<p>因此对静态资源的选择，可以加上<code>~</code>，也可以不加。但为了避免今后配置的冲突，还是让静态资源的优先级高一些来的好。</p>

<p>随后，可以使用下面的链接进行测试，看看是否满足需求：</p>

<p>http://192.168.203.198/toolbar/enter/t.js,<br/>
http://192.168.203.198/toolbar/static/images/logo1.png,<br/>
http://192.168.203.198/toolbar/WEB-INF/web.xml</p>

<p>前面两个应该得到返回内容，最后一个应该获得报错。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web容器中通过Spring添加Job任务]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/09/11/webrong-qi-zhong-tong-guo-springtian-jia-jobren-wu/"/>
    <updated>2014-09-11T21:59:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/09/11/webrong-qi-zhong-tong-guo-springtian-jia-jobren-wu</id>
    <content type="html"><![CDATA[<p>实际投入使用的Web站点总有很多例行任务要做，习惯的做法是利用操作系统的crontab定期执行脚本或者Java程序。
在更早的时候，曾经试过quartz，但后来因为quartz创建的线程属于JVM而不是Web容器，导致停止或
重新部署应用时线程并未终止，因此后来跑java程序例行任务的话，主要就
是单独运行jar文件。</p>

<p>时过境迁，了解到Spring已经接管了定时任务的线程处理，之前在
Web容器里跑多线程任务的最大隐患已经不存在了，所以尝试了一下在
Spring中使用例行更新。</p>

<p>这样做最大的好处当然就是代码集中，容易维护也容易部署。</p>

<h3>功能说明</h3>

<p>整个功能并不复杂，需要对redis中的设备号列表进行遍历，对每一个
号码调用远程接口获取该号码的一些动态变化的信息。取得后，这些信息
的时效时间是6小时，在失效前的10分钟内，需要再次调用远程接口刷新缓存。</p>

<p>因为整个功能的瓶颈在于远程调用，为了提高并发，
调用远程接口采取多线程的方式。而遍历的性能极好，使用单线程就够了。</p>

<h3>使用组件</h3>

<p>采用Java中线程的Executors实现起来最简单直接。Executors实质上就是一个
线程池，每塞给一个号码，就调用派发一个线程进行处理。如果没有线程可派，
则放入队列中，如队列满了则会依据设置再增加线程数量。</p>

<p><code>java
private TaskExecutor taskExecutor
</code></p>

<p>Executor确实是一个比较好的多线程编程方式，融合了Actor模式和队列，
使用起来也比较方便。</p>

<p>Executors可以由spring进行注入，在这个任务里比较合适的是采用ThreadPool*</p>

<p>```xml</p>

<pre><code>&lt;bean id="taskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"&gt;
    &lt;property name="corePoolSize" value="5" /&gt;
    &lt;property name="maxPoolSize" value="10" /&gt;
    &lt;property name="queueCapacity" value="2500" /&gt;
&lt;/bean&gt;
</code></pre>

<p>```
corePoolSize是例行打开的线程数，queueCapacity是在没有core线程处理时的排队数量，
当超过这个数量时，会再启动线程直到maxPoolSize。如果都使用完毕，则可指定溢出时的抛弃处理方式。</p>

<p>派发任务由<code>taskExecutor.execute(new PollItInterfaceTask(mdn))</code>表达，
要同步的数据通过mdn传入。</p>

<p>此外，因为遍历的线程执行速度快，而workers可能需要更长时间才能完成队列中的任务，
为防止重复提交设置了一个多线程会并发访问的集合<code>private Set&lt;String&gt; mdnInQueue = new ConcurrentSkipListSet&lt;String&gt;(); //用于记录已安排执行但还未执行的号码</code>
。整个代码的情况如下:</p>

<p>```java
package com.sanss.toolbar.job;</p>

<p>import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.TimerTask;
import java.util.concurrent.ConcurrentSkipListSet;</p>

<p>import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.junit.Assert;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.task.TaskExecutor;</p>

<p>import com.sanss.toolbar.service.CacheItInterfaceQueryService;</p>

<p>/<em>多线程发起的、向IT抓取用户套餐信息的线程池执行者，由spring中触发，根据接口run()</em>/
public class PollItInterfaceTaskExecutor  implements Runnable {</p>

<pre><code>private static Log logger = LogFactory.getLog(PollItInterfaceTaskExecutor.class);
private Set&lt;String&gt; mdnInQueue = new ConcurrentSkipListSet&lt;String&gt;(); //用于记录已安排执行但还未执行的号码
@Autowired
CacheItInterfaceQueryService cacheItInterfaceQueryService;

/*实际被多线程执行的任务,获取在队列中存放的mdn*/
private class PollItInterfaceTask implements Runnable {
    private String mdn;
    public PollItInterfaceTask(String mdn) {
        this.mdn = mdn;
    }

    public void run() {
        cacheItInterfaceQueryService.setCacheFlux(mdn);
        mdnInQueue.remove(mdn);
        Thread currentThread = Thread.currentThread();  // 获得当前的线程  
        String threadName = currentThread.getName();  
        logger.debug(threadName + ": 刷新下面号码的cache: " + mdn);
    }
}

private TaskExecutor taskExecutor;

public PollItInterfaceTaskExecutor(TaskExecutor taskExecutor) {
    this.taskExecutor = taskExecutor;

}

//任务出发后，被run自动执行的任务。首先获得所有需要提前取得IT流量信息的hashkey集合，随后遍历集合分别取出相关的一系列mdn，
//之后根据mdn检查ttl信息，发现小于500秒就安排Executor执行任务。
public void doit() {
    Set&lt;String&gt; tlbKeys = cacheItInterfaceQueryService.getAllTlbsetQueryList();
    int total = 0; //号码列表总数
    int count = 0; //本轮需要刷新的
    for (String hshkey : tlbKeys) {
        Map&lt;String, String&gt; mdns = cacheItInterfaceQueryService.getAllFieldsByAKey(hshkey);
        for(String mdn : mdns.keySet()) {
            long ttl = cacheItInterfaceQueryService.ttlFlux(mdn);
            if (ttl &lt; 500 ) {
                if (!mdnInQueue.contains(mdn)) {
                    mdnInQueue.add(mdn);
                    taskExecutor.execute(new PollItInterfaceTask(mdn));
                    count++;
               }
            }
            total++;
        }
    }
    logger.info("本轮刷新"+count+"个记录, 共有"+total+"个记录");
}

@Override
public void run() {
    // TODO Auto-generated method stub
 System.out.format("开始执行 %s ...%n", new Date());  
    doit();
}
</code></pre>

<p>}</p>

<p>```</p>

<p>CacheItInterfaceQueryService是项目中的一个服务模块，负责具体设置缓存。</p>

<p>```xml</p>

<!-- 定期去IT接口轮训的部署 -->


<pre><code>&lt;bean id="taskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"&gt;
    &lt;property name="corePoolSize" value="5" /&gt;
    &lt;property name="maxPoolSize" value="10" /&gt;
    &lt;property name="queueCapacity" value="2500" /&gt;
&lt;/bean&gt;

  &lt;bean id="pollItInterfaceTaskExecutor" class="com.sanss.toolbar.job.PollItInterfaceTaskExecutor"&gt;
       &lt;constructor-arg ref="taskExecutor" /&gt;
 &lt;/bean&gt;

&lt;bean id="springScheduleExecutorTask"  
    class="org.springframework.scheduling.concurrent.ScheduledExecutorTask"&gt;  

    &lt;property name="runnable" ref="pollItInterfaceTaskExecutor" /&gt;  

    &lt;property name="delay" value="1000" /&gt;  
    &lt;!-- 每次任务间隔 一分钟--&gt;  
    &lt;property name="period" value="60000" /&gt;  
&lt;/bean&gt;  

 &lt;bean id="springScheduledExecutorFactoryBean"  
    class="org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean"&gt;  
    &lt;property name="scheduledExecutorTasks"&gt;  
        &lt;list&gt;  
            &lt;ref bean="springScheduleExecutorTask" /&gt;  
        &lt;/list&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;  
</code></pre>

<p><code>``
避免不了的配置如上，</code>taskExecutor<code>已经在前面描述过，第二段的</code>pollItInterfaceTaskExecutor<code>就是把线程池执行者
作为参数传给自己编写的任务的构造函数，然后第三段定义一个周期执行的任务，设置好执行的间隔，runnable要提供自己编写的业务类（第二段中的内容），
最后第四步把这个周期任务交给Spring的</code>ScheduledExecutorFactoryBean`工厂来负责管理。
需要注意的是，ScheduledExecutorFactoryBean是spring4中的写法，在spring3中还是另一套描述方式，虽然功能差不多。
但在版本升级时，这是一个不大不小的坑。</p>
]]></content>
  </entry>
  
</feed>
