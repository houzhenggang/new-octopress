<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: spring | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/spring/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2015-05-19T17:41:58+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[HttpSession在Spring中的配法和问题]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/05/19/httpsessionzai-springzhong-de-pei-fa-he-wen-ti/"/>
    <updated>2015-05-19T17:22:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/05/19/httpsessionzai-springzhong-de-pei-fa-he-wen-ti</id>
    <content type="html"><![CDATA[<p>最早出于使用struts2的习惯，在Spring中如果需要使用<code>HttpSession</code>，做法是把这个对象作为整个类的一个实例对象。</p>

<p>1</p>

<p>```java
public class TestController {</p>

<p>  private static final Log logger = LogFactory.getLog(TestController.class);</p>

<p>  @Autowired
  HttpSession session;</p>

<p>  ...
}
```</p>

<p>后来因为担心Controller在Spring中是单例的（在struts2中是多例的），怕引出线程安全问题，于是把<code>session</code>放入了method中进行注入。</p>

<p>2</p>

<p>```java
@ResponseBody
  @RequestMapping(method = RequestMethod.GET,  produces = MediaTypes.TEXT_HTML_UTF_8)
  public String testSession(HttpServletRequest request, HttpServletResponse response, Model model, HttpSession session) {</p>

<pre><code>int hashCode = session.hashCode();

int i = 0  ;
if (session.getAttribute("val")!=null) {
  i = (int)session.getAttribute("val");
  i++;
} 

session.setAttribute("val", i%3);

logger.info("hashCode: " + hashCode);

return ""+hashCode + ": " + i;
</code></pre>

<p>  }
```</p>

<p>近日在学习Spring in Action的过程中，发现其实第一种方式下使用了<code>proxy 模式</code>, 实际被注入的类是<code>session  $Proxy38</code>这样的代理类，
类似于避免反复调用<code>createEntityManager</code>的做法，该代理类会寻找实际对应的session并进行操作,只是给controller注入了一个壳。</p>

<p>而第2种方法中，注入的则是标准的容器session: <code>org.apache.catalina.session.StandardSessionFacade</code></p>

<p>3</p>

<p>此外，受到推崇的是第三种写法，</p>

<p><code>java
@Component
@Scope(proxyMode=ScopedProxyMode.TARGET_CLASS, value="session")
public class ShoppingCart implements Serializable{
}
</code></p>

<p>这种写法将整个购物车变成一个scope属于session的bean，由spring注入并负责保存。</p>

<p>但这种写法我个人感觉有点过于抛离了web开发。尽管Spring的一大好处是取消对容器的依赖，从而做到测试的方便。但完全和Web容器隔离，变得不像Web开发也不是什么好的策略。
毕竟Session的概念几乎每个Web开发者都有，而scope=session则反而会增加沟通的难度。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring 4 中的新东西]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/05/04/spring-4-zhong-de-xin-dong-xi/"/>
    <updated>2015-05-04T14:30:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/05/04/spring-4-zhong-de-xin-dong-xi</id>
    <content type="html"><![CDATA[<p>Spring还在继续提高与演进中。</p>

<h3>3.1中的新东西</h3>

<ul>
<li>environment profiles，支持development、test和production等条件下独特的配置</li>
<li>增加enable annotations，在Java文件配置中</li>
<li>Declarative caching support，像支持事务一样支持缓存</li>
<li>支持Servlet 3.0，包括在java文件中声明servlets和filters，而不仅仅是在web.xml中</li>
<li>JPA支持的提升，可以不再需要persistence.xml</li>
<li>自动绑定路径便利给model属性</li>
<li>支持对Accept和Content-Type消息头的匹配，通过@RequestMappingproduces</li>
<li>绑定部分二进制表单请求给方法参数，通过@RequestPart，比@RequestParam更强大（只能对请求参数数据绑定，key-alue格式），而@RequestPart支持如JSON、XML内容区数据的绑定</li>
<li>flash属性的支持</li>
<li>JpaTemplate和JpaDaoSupport让位于EntityManager</li>
</ul>


<h3>3.2中的新东西</h3>

<ul>
<li>支持servlet 3中的异步请求，使得一个请求可以在独立的线程中被处理，让servlet线程可以处理更多的请求</li>
<li>Spring MVC的test框架，包括RestTemplate的测试支持</li>
<li>@controllerAdvice使得@ModelAttributes等控制器的方法可以在单个类中重新组织</li>
<li>ContentNegotiatingViewResolver</li>
<li>@MatrixVariable</li>
<li>Rest方面的改进与支持</li>
</ul>


<h3>4.0中的新东西</h3>

<ul>
<li>WebSocket的支持，包括JSR-356中Java API对WebSocket的支持</li>
<li>SockJS/STOMP对WebSocket和消息模块的封装</li>
<li>Java 8 特性的应用，比如lambda。callback interface的使用变简单了，如RowMapper和JdbcTemplate</li>
<li>Java 8中的时间日期api</li>
<li>RestTemplate的一个异步版实现</li>
<li>新增对JMS 2.0 JTA 1.2， JPA 2.1的支持</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[静态文件的url后缀md5化]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/01/22/jing-tai-wen-jian-de-urlhou-zhui-md5hua/"/>
    <updated>2015-01-22T09:55:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/01/22/jing-tai-wen-jian-de-urlhou-zhui-md5hua</id>
    <content type="html"><![CDATA[<p>长久以来，在jsp中引入css和JavaScript都是手工硬编的:</p>

<p>```jsp
<link href='http://octopresszhangyu.herokuapp.com/toolbar/static/orderFlow/css/reset.css' rel="stylesheet" type="text/css" /></p>

<script src="http://octopresszhangyu.herokuapp.com/toolbar/static/jquery/jquery.min.js" charset="utf-8"></script>


<p>```</p>

<p>好处很明显，最接近实际生成的html，很直观。坏处在于重复性高，而且无法控制后台生成的随机数，这样不太利于nginx等处理静态资源的缓存。终极方案莫过于在后缀上加上md5指纹信息，这样既可以让nginx等通知浏览器长期缓存，而一旦文件发生变化也必然可以让浏览器再次发起请求获得css和JavaScript。最终生成的页面信息达到下面的效果：</p>

<p>```jsp</p>

<script src="http://octopresszhangyu.herokuapp.com/toolbar/static/jquery/toolbar.js?2dc0cb76e7faa4c150fca76981cbcd20" charset="utf-8"></script>


<p>```</p>

<p>实现包含两部分，一方面需要可以计算出静态文件的md5值，另一方面则是可以在jsp中调用并生成上述html。多番比较后，发现jsp中还是使用标签比较合适，所以继续写tag文件：</p>

<p>style.tag
<code>jsp
&lt;%@ tag pageEncoding="UTF-8" import="com.sanss.toolbar.hepler.BaseHelper" %&gt;
&lt;%@ attribute name="file" type="java.lang.String" required="true" %&gt;
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;c:set var="ctx" value="${pageContext.request.contextPath}" /&gt;
&lt;link href='${ctx}&lt;%=BaseHelper.rtg(file) %&gt;' rel="stylesheet" type="text/css" /&gt;
</code></p>

<p>javascript.tag
```jsp
&lt;%@tag pageEncoding="UTF-8" import="com.sanss.toolbar.hepler.BaseHelper"%>
&lt;%@ attribute name="file" type="java.lang.String" required="true"%>
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
&lt;c:set var="ctx" value="${pageContext.request.contextPath}" /></p>

<script src="${ctx}<%=BaseHelper.rtg(file) %>" charset="utf-8"></script>


<p>```</p>

<p>其中使用到了BaseHelper里面的生成md5后缀级链接的方法<code>rtg(filepath)i</code></p>

<p>```java
/<em>* 生成静态文件链接的公共方法，加上md5后缀或者时间戳。
   * @param resource
   * @return
   </em>/
  public static String rtg(String resource) {</p>

<pre><code>String fileMd5 = fileMD5s.get(resource);
if (StringUtils.isEmpty(fileMd5)) {
  System.out.println(System.getProperty("user.dir"));
  fileMd5 = getFileMD5("../webapps/toolbar/static/"+resource);
  if (StringUtils.isEmpty(fileMd5)) {
    fileMd5 = timestamp;
  }
  fileMD5s.put(resource, fileMd5);
}

return "/static/"+resource+"?"+fileMd5;
</code></pre>

<p>  }
```</p>

<p>最不济的情况下，也能给文件加上启动日期的时间戳。</p>

<p>而在布局或者其他需要引入css和js的页面，直接使用这种代码即可:</p>

<p><code>jsp
&lt;tags:style file="styles/css1.css" /&gt;
&lt;tags:javascript file="jquery/jquery.min.js" /&gt;
&lt;tags:javascript file="jquery/tl.js" /&gt;
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring中的CRON]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/12/28/springzhong-de-cron/"/>
    <updated>2014-12-28T15:12:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/12/28/springzhong-de-cron</id>
    <content type="html"><![CDATA[<p>在<a href="/blog/2014/09/11/webrong-qi-zhong-tong-guo-springtian-jia-jobren-wu/">Web容器中通过Spring添加Job任务</a>一文中，
已经提过在spring中增加例行任务。只是当时提交的任务仅限于间隔一段时间后执行，比如每分钟执行一次，因此使用
<code>period</code> 和 <code>delay</code>两个参数就够了。</p>

<p>这次新遇到的需求是要求定点执行，比如固定在夜间23:30启动，这时候就需要cron了。好在Spring 4.0版
开始已经支持cron，配置起来也很简洁。</p>

<p>首先，在<code>spring-mvc.xml</code>中增加要定期执行的类作为bean，作用是把要定期执行的类交给spring扫描</p>

<p><code>xml
&lt;bean id="LastDayDevicePackorderlogRefreshTaskExecutor" class="com.sanss.toolbar.job.LastDayDevicePackorderlogRefreshTaskExecutor"&gt;
&lt;/bean&gt;
</code></p>

<p>其次，在这个类上使用标注<code>@EnableScheduling</code>，让spring意识到这是一个定期调度启动的任务。</p>

<p>```java
@EnableScheduling
public class LastDayDevicePackorderlogRefreshTaskExecutor implements Runnable {</p>

<p>}
```</p>

<p>最后，是在具体要启动的method上标注<code>@Scheduled(cron = "0 * * * * *")</code>，以此给出具体的执行安排。<br/>
标注中cron的具体含义可以见下面的注释。</p>

<p>```java</p>

<pre><code>/*
 * 一个cron表达式有至少6个（也可能7个）有空格分隔的时间元素。
 *
 * 按顺序依次为 秒（0~59）
 *
 * 分钟（0~59）
 *
 * 小时（0~23）
 *
 * 天（月）（0~31，但是你需要考虑你月的天数）
 *
 * 月（0~11）
 *
 * 天（星期）（1~7 1=SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT）
 *
 * 7.年份（1970－2099）
 */
@Scheduled(cron = "0 * * * * *")
public void run() {
    // TODO Auto-generated method stub
    // doit();
    logger.info("定期触发");
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx 处理Spring 静态资源的配置]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/10/14/nginx-chu-li-spring-jing-tai-zi-yuan-de-pei-zhi/"/>
    <updated>2014-10-14T13:19:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/10/14/nginx-chu-li-spring-jing-tai-zi-yuan-de-pei-zhi</id>
    <content type="html"><![CDATA[<p>用Nginx处理静态资源是挺常见的一个事情，自从使用了Spring，也经常直接利用Spring的处理静态文件的功能，也能打上Etag。避免流量传输。
但是近来发现，Spring处理静态资源后，对静态文件获取的请求浏览器还是会发起，只是每次都是返回304。所以想继续借助Nginx给Spring的静态资源打上expire的标记。</p>

<p>需求也算简单：</p>

<ol>
<li>基于app toolbar的动态请求转发给java</li>
<li>gif,png，js等nginx直接处理，并加expire 3h；</li>
<li>部分.js请求如t.js还是转给java，有效期为0；</li>
<li>敏感文件不会被nginx处理，如web.xml无法被nginx转走</li>
</ol>


<p>因为目前Spring的静态资源单独存放在和WEB-INF并排的目录下，所以利用Nginx配置就大为简单了，只要限制路径名称即可。</p>

<p>```</p>

<pre><code>    location /toolbar {
        root   html;
        proxy_pass http://192.168.203.198:8080;
    }
    location ~ /toolbar/static {
        root   html;
        if (-f $request_filename) {
            expires 1d;
            break;
        }
    }
    location = /toolbar/enter/t.js {
        root   html;
        proxy_pass http://192.168.202.72:8080;
    }
</code></pre>

<p>```</p>

<p>然后在nginx的html目录下建立目录<code>toolbar</code>，并在其增加一个符号连接<code>ln -s /home/web/apache-tomcat-7.0.56/webapps/toolbar/static static</code>，就可以实现上述要求了。</p>

<p>这里面用到了几种Nginx的配置。</p>

<ol>
<li><code>location /toolbar</code>，这是最基本的匹配字符串的表达方式，优先级一般情况下也最低，然而<code>^~</code>是一个例外，它的优先级比下面的正则要高。</li>
<li><code>location ~ /toolbar/static</code>，这个是用到了正则表达式的匹配，优先级要高于基础的只比较字符。</li>
<li><code>location = /toolbar/enter/t.js</code>，这是优先级最高的匹配符，要求uri完全相等。</li>
</ol>


<p>如果需要使用正则表达式匹配，则必须使用<code>~</code>或者<code>~*</code>，其中后者和前者的区别是不区分大小写。</p>

<p>整个匹配顺序是：</p>

<ol>
<li>对<code>=</code>进行匹配，有相符的就停止；</li>
<li>对所有的非正则表达式（为使用~ 和 ~*）进行匹配，如果遇到<code>^~</code>则也停止，否则全部比对完毕后，最接近的匹配将被选用作为候选，随后进入3匹配正则表达式；</li>
<li>正则表达式按定义的顺序进行匹配，有匹配的则停止，即可选用刚刚匹配的正则表达式，如没有匹配的正则，则选用2中得到的结果。</li>
</ol>


<p>因此对静态资源的选择，可以加上<code>~</code>，也可以不加。但为了避免今后配置的冲突，还是让静态资源的优先级高一些来的好。</p>

<p>随后，可以使用下面的链接进行测试，看看是否满足需求：</p>

<p>http://192.168.203.198/toolbar/enter/t.js,<br/>
http://192.168.203.198/toolbar/static/images/logo1.png,<br/>
http://192.168.203.198/toolbar/WEB-INF/web.xml</p>

<p>前面两个应该得到返回内容，最后一个应该获得报错。</p>
]]></content>
  </entry>
  
</feed>
