<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: spring | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/spring/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2015-03-06T16:51:06+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[静态文件的url后缀md5化]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/01/22/jing-tai-wen-jian-de-urlhou-zhui-md5hua/"/>
    <updated>2015-01-22T09:55:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/01/22/jing-tai-wen-jian-de-urlhou-zhui-md5hua</id>
    <content type="html"><![CDATA[<p>长久以来，在jsp中引入css和JavaScript都是手工硬编的:</p>

<p>```jsp
<link href='http://octopresszhangyu.herokuapp.com/toolbar/static/orderFlow/css/reset.css' rel="stylesheet" type="text/css" /></p>

<script src="http://octopresszhangyu.herokuapp.com/toolbar/static/jquery/jquery.min.js" charset="utf-8"></script>


<p>```</p>

<p>好处很明显，最接近实际生成的html，很直观。坏处在于重复性高，而且无法控制后台生成的随机数，这样不太利于nginx等处理静态资源的缓存。终极方案莫过于在后缀上加上md5指纹信息，这样既可以让nginx等通知浏览器长期缓存，而一旦文件发生变化也必然可以让浏览器再次发起请求获得css和JavaScript。最终生成的页面信息达到下面的效果：</p>

<p>```jsp</p>

<script src="http://octopresszhangyu.herokuapp.com/toolbar/static/jquery/toolbar.js?2dc0cb76e7faa4c150fca76981cbcd20" charset="utf-8"></script>


<p>```</p>

<p>实现包含两部分，一方面需要可以计算出静态文件的md5值，另一方面则是可以在jsp中调用并生成上述html。多番比较后，发现jsp中还是使用标签比较合适，所以继续写tag文件：</p>

<p>style.tag
<code>jsp
&lt;%@ tag pageEncoding="UTF-8" import="com.sanss.toolbar.hepler.BaseHelper" %&gt;
&lt;%@ attribute name="file" type="java.lang.String" required="true" %&gt;
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;c:set var="ctx" value="${pageContext.request.contextPath}" /&gt;
&lt;link href='${ctx}&lt;%=BaseHelper.rtg(file) %&gt;' rel="stylesheet" type="text/css" /&gt;
</code></p>

<p>javascript.tag
```jsp
&lt;%@tag pageEncoding="UTF-8" import="com.sanss.toolbar.hepler.BaseHelper"%>
&lt;%@ attribute name="file" type="java.lang.String" required="true"%>
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
&lt;c:set var="ctx" value="${pageContext.request.contextPath}" /></p>

<script src="${ctx}<%=BaseHelper.rtg(file) %>" charset="utf-8"></script>


<p>```</p>

<p>其中使用到了BaseHelper里面的生成md5后缀级链接的方法<code>rtg(filepath)i</code></p>

<p>```java
/<em>* 生成静态文件链接的公共方法，加上md5后缀或者时间戳。
   * @param resource
   * @return
   </em>/
  public static String rtg(String resource) {</p>

<pre><code>String fileMd5 = fileMD5s.get(resource);
if (StringUtils.isEmpty(fileMd5)) {
  System.out.println(System.getProperty("user.dir"));
  fileMd5 = getFileMD5("../webapps/toolbar/static/"+resource);
  if (StringUtils.isEmpty(fileMd5)) {
    fileMd5 = timestamp;
  }
  fileMD5s.put(resource, fileMd5);
}

return "/static/"+resource+"?"+fileMd5;
</code></pre>

<p>  }
```</p>

<p>最不济的情况下，也能给文件加上启动日期的时间戳。</p>

<p>而在布局或者其他需要引入css和js的页面，直接使用这种代码即可:</p>

<p><code>jsp
&lt;tags:style file="styles/css1.css" /&gt;
&lt;tags:javascript file="jquery/jquery.min.js" /&gt;
&lt;tags:javascript file="jquery/tl.js" /&gt;
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring中的CRON]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/12/28/springzhong-de-cron/"/>
    <updated>2014-12-28T15:12:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/12/28/springzhong-de-cron</id>
    <content type="html"><![CDATA[<p>在<a href="/blog/2014/09/11/webrong-qi-zhong-tong-guo-springtian-jia-jobren-wu/">Web容器中通过Spring添加Job任务</a>一文中，
已经提过在spring中增加例行任务。只是当时提交的任务仅限于间隔一段时间后执行，比如每分钟执行一次，因此使用
<code>period</code> 和 <code>delay</code>两个参数就够了。</p>

<p>这次新遇到的需求是要求定点执行，比如固定在夜间23:30启动，这时候就需要cron了。好在Spring 4.0版
开始已经支持cron，配置起来也很简洁。</p>

<p>首先，在<code>spring-mvc.xml</code>中增加要定期执行的类作为bean，作用是把要定期执行的类交给spring扫描</p>

<p><code>xml
&lt;bean id="LastDayDevicePackorderlogRefreshTaskExecutor" class="com.sanss.toolbar.job.LastDayDevicePackorderlogRefreshTaskExecutor"&gt;
&lt;/bean&gt;
</code></p>

<p>其次，在这个类上使用标注<code>@EnableScheduling</code>，让spring意识到这是一个定期调度启动的任务。</p>

<p>```java
@EnableScheduling
public class LastDayDevicePackorderlogRefreshTaskExecutor implements Runnable {</p>

<p>}
```</p>

<p>最后，是在具体要启动的method上标注<code>@Scheduled(cron = "0 * * * * *")</code>，以此给出具体的执行安排。<br/>
标注中cron的具体含义可以见下面的注释。</p>

<p>```java</p>

<pre><code>/*
 * 一个cron表达式有至少6个（也可能7个）有空格分隔的时间元素。
 *
 * 按顺序依次为 秒（0~59）
 *
 * 分钟（0~59）
 *
 * 小时（0~23）
 *
 * 天（月）（0~31，但是你需要考虑你月的天数）
 *
 * 月（0~11）
 *
 * 天（星期）（1~7 1=SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT）
 *
 * 7.年份（1970－2099）
 */
@Scheduled(cron = "0 * * * * *")
public void run() {
    // TODO Auto-generated method stub
    // doit();
    logger.info("定期触发");
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx 处理Spring 静态资源的配置]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/10/14/nginx-chu-li-spring-jing-tai-zi-yuan-de-pei-zhi/"/>
    <updated>2014-10-14T13:19:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/10/14/nginx-chu-li-spring-jing-tai-zi-yuan-de-pei-zhi</id>
    <content type="html"><![CDATA[<p>用Nginx处理静态资源是挺常见的一个事情，自从使用了Spring，也经常直接利用Spring的处理静态文件的功能，也能打上Etag。避免流量传输。
但是近来发现，Spring处理静态资源后，对静态文件获取的请求浏览器还是会发起，只是每次都是返回304。所以想继续借助Nginx给Spring的静态资源打上expire的标记。</p>

<p>需求也算简单：</p>

<ol>
<li>基于app toolbar的动态请求转发给java</li>
<li>gif,png，js等nginx直接处理，并加expire 3h；</li>
<li>部分.js请求如t.js还是转给java，有效期为0；</li>
<li>敏感文件不会被nginx处理，如web.xml无法被nginx转走</li>
</ol>


<p>因为目前Spring的静态资源单独存放在和WEB-INF并排的目录下，所以利用Nginx配置就大为简单了，只要限制路径名称即可。</p>

<p>```</p>

<pre><code>    location /toolbar {
        root   html;
        proxy_pass http://192.168.203.198:8080;
    }
    location ~ /toolbar/static {
        root   html;
        if (-f $request_filename) {
            expires 1d;
            break;
        }
    }
    location = /toolbar/enter/t.js {
        root   html;
        proxy_pass http://192.168.202.72:8080;
    }
</code></pre>

<p>```</p>

<p>然后在nginx的html目录下建立目录<code>toolbar</code>，并在其增加一个符号连接<code>ln -s /home/web/apache-tomcat-7.0.56/webapps/toolbar/static static</code>，就可以实现上述要求了。</p>

<p>这里面用到了几种Nginx的配置。</p>

<ol>
<li><code>location /toolbar</code>，这是最基本的匹配字符串的表达方式，优先级一般情况下也最低，然而<code>^~</code>是一个例外，它的优先级比下面的正则要高。</li>
<li><code>location ~ /toolbar/static</code>，这个是用到了正则表达式的匹配，优先级要高于基础的只比较字符。</li>
<li><code>location = /toolbar/enter/t.js</code>，这是优先级最高的匹配符，要求uri完全相等。</li>
</ol>


<p>如果需要使用正则表达式匹配，则必须使用<code>~</code>或者<code>~*</code>，其中后者和前者的区别是不区分大小写。</p>

<p>整个匹配顺序是：</p>

<ol>
<li>对<code>=</code>进行匹配，有相符的就停止；</li>
<li>对所有的非正则表达式（为使用~ 和 ~*）进行匹配，如果遇到<code>^~</code>则也停止，否则全部比对完毕后，最接近的匹配将被选用作为候选，随后进入3匹配正则表达式；</li>
<li>正则表达式按定义的顺序进行匹配，有匹配的则停止，即可选用刚刚匹配的正则表达式，如没有匹配的正则，则选用2中得到的结果。</li>
</ol>


<p>因此对静态资源的选择，可以加上<code>~</code>，也可以不加。但为了避免今后配置的冲突，还是让静态资源的优先级高一些来的好。</p>

<p>随后，可以使用下面的链接进行测试，看看是否满足需求：</p>

<p>http://192.168.203.198/toolbar/enter/t.js,<br/>
http://192.168.203.198/toolbar/static/images/logo1.png,<br/>
http://192.168.203.198/toolbar/WEB-INF/web.xml</p>

<p>前面两个应该得到返回内容，最后一个应该获得报错。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web容器中通过Spring添加Job任务]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/09/11/webrong-qi-zhong-tong-guo-springtian-jia-jobren-wu/"/>
    <updated>2014-09-11T21:59:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/09/11/webrong-qi-zhong-tong-guo-springtian-jia-jobren-wu</id>
    <content type="html"><![CDATA[<p>实际投入使用的Web站点总有很多例行任务要做，习惯的做法是利用操作系统的crontab定期执行脚本或者Java程序。
在更早的时候，曾经试过quartz，但后来因为quartz创建的线程属于JVM而不是Web容器，导致停止或
重新部署应用时线程并未终止，因此后来跑java程序例行任务的话，主要就
是单独运行jar文件。</p>

<p>时过境迁，了解到Spring已经接管了定时任务的线程处理，之前在
Web容器里跑多线程任务的最大隐患已经不存在了，所以尝试了一下在
Spring中使用例行更新。</p>

<p>这样做最大的好处当然就是代码集中，容易维护也容易部署。</p>

<h3>功能说明</h3>

<p>整个功能并不复杂，需要对redis中的设备号列表进行遍历，对每一个
号码调用远程接口获取该号码的一些动态变化的信息。取得后，这些信息
的时效时间是6小时，在失效前的10分钟内，需要再次调用远程接口刷新缓存。</p>

<p>因为整个功能的瓶颈在于远程调用，为了提高并发，
调用远程接口采取多线程的方式。而遍历的性能极好，使用单线程就够了。</p>

<h3>使用组件</h3>

<p>采用Java中线程的Executors实现起来最简单直接。Executors实质上就是一个
线程池，每塞给一个号码，就调用派发一个线程进行处理。如果没有线程可派，
则放入队列中，如队列满了则会依据设置再增加线程数量。</p>

<p><code>java
private TaskExecutor taskExecutor
</code></p>

<p>Executor确实是一个比较好的多线程编程方式，融合了Actor模式和队列，
使用起来也比较方便。</p>

<p>Executors可以由spring进行注入，在这个任务里比较合适的是采用ThreadPool*</p>

<p>```xml</p>

<pre><code>&lt;bean id="taskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"&gt;
    &lt;property name="corePoolSize" value="5" /&gt;
    &lt;property name="maxPoolSize" value="10" /&gt;
    &lt;property name="queueCapacity" value="2500" /&gt;
&lt;/bean&gt;
</code></pre>

<p>```
corePoolSize是例行打开的线程数，queueCapacity是在没有core线程处理时的排队数量，
当超过这个数量时，会再启动线程直到maxPoolSize。如果都使用完毕，则可指定溢出时的抛弃处理方式。</p>

<p>派发任务由<code>taskExecutor.execute(new PollItInterfaceTask(mdn))</code>表达，
要同步的数据通过mdn传入。</p>

<p>此外，因为遍历的线程执行速度快，而workers可能需要更长时间才能完成队列中的任务，
为防止重复提交设置了一个多线程会并发访问的集合<code>private Set&lt;String&gt; mdnInQueue = new ConcurrentSkipListSet&lt;String&gt;(); //用于记录已安排执行但还未执行的号码</code>
。整个代码的情况如下:</p>

<p>```java
package com.sanss.toolbar.job;</p>

<p>import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.TimerTask;
import java.util.concurrent.ConcurrentSkipListSet;</p>

<p>import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.junit.Assert;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.task.TaskExecutor;</p>

<p>import com.sanss.toolbar.service.CacheItInterfaceQueryService;</p>

<p>/<em>多线程发起的、向IT抓取用户套餐信息的线程池执行者，由spring中触发，根据接口run()</em>/
public class PollItInterfaceTaskExecutor  implements Runnable {</p>

<pre><code>private static Log logger = LogFactory.getLog(PollItInterfaceTaskExecutor.class);
private Set&lt;String&gt; mdnInQueue = new ConcurrentSkipListSet&lt;String&gt;(); //用于记录已安排执行但还未执行的号码
@Autowired
CacheItInterfaceQueryService cacheItInterfaceQueryService;

/*实际被多线程执行的任务,获取在队列中存放的mdn*/
private class PollItInterfaceTask implements Runnable {
    private String mdn;
    public PollItInterfaceTask(String mdn) {
        this.mdn = mdn;
    }

    public void run() {
        cacheItInterfaceQueryService.setCacheFlux(mdn);
        mdnInQueue.remove(mdn);
        Thread currentThread = Thread.currentThread();  // 获得当前的线程  
        String threadName = currentThread.getName();  
        logger.debug(threadName + ": 刷新下面号码的cache: " + mdn);
    }
}

private TaskExecutor taskExecutor;

public PollItInterfaceTaskExecutor(TaskExecutor taskExecutor) {
    this.taskExecutor = taskExecutor;

}

//任务出发后，被run自动执行的任务。首先获得所有需要提前取得IT流量信息的hashkey集合，随后遍历集合分别取出相关的一系列mdn，
//之后根据mdn检查ttl信息，发现小于500秒就安排Executor执行任务。
public void doit() {
    Set&lt;String&gt; tlbKeys = cacheItInterfaceQueryService.getAllTlbsetQueryList();
    int total = 0; //号码列表总数
    int count = 0; //本轮需要刷新的
    for (String hshkey : tlbKeys) {
        Map&lt;String, String&gt; mdns = cacheItInterfaceQueryService.getAllFieldsByAKey(hshkey);
        for(String mdn : mdns.keySet()) {
            long ttl = cacheItInterfaceQueryService.ttlFlux(mdn);
            if (ttl &lt; 500 ) {
                if (!mdnInQueue.contains(mdn)) {
                    mdnInQueue.add(mdn);
                    taskExecutor.execute(new PollItInterfaceTask(mdn));
                    count++;
               }
            }
            total++;
        }
    }
    logger.info("本轮刷新"+count+"个记录, 共有"+total+"个记录");
}

@Override
public void run() {
    // TODO Auto-generated method stub
 System.out.format("开始执行 %s ...%n", new Date());  
    doit();
}
</code></pre>

<p>}</p>

<p>```</p>

<p>CacheItInterfaceQueryService是项目中的一个服务模块，负责具体设置缓存。</p>

<p>```xml</p>

<!-- 定期去IT接口轮训的部署 -->


<pre><code>&lt;bean id="taskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"&gt;
    &lt;property name="corePoolSize" value="5" /&gt;
    &lt;property name="maxPoolSize" value="10" /&gt;
    &lt;property name="queueCapacity" value="2500" /&gt;
&lt;/bean&gt;

  &lt;bean id="pollItInterfaceTaskExecutor" class="com.sanss.toolbar.job.PollItInterfaceTaskExecutor"&gt;
       &lt;constructor-arg ref="taskExecutor" /&gt;
 &lt;/bean&gt;

&lt;bean id="springScheduleExecutorTask"  
    class="org.springframework.scheduling.concurrent.ScheduledExecutorTask"&gt;  

    &lt;property name="runnable" ref="pollItInterfaceTaskExecutor" /&gt;  

    &lt;property name="delay" value="1000" /&gt;  
    &lt;!-- 每次任务间隔 一分钟--&gt;  
    &lt;property name="period" value="60000" /&gt;  
&lt;/bean&gt;  

 &lt;bean id="springScheduledExecutorFactoryBean"  
    class="org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean"&gt;  
    &lt;property name="scheduledExecutorTasks"&gt;  
        &lt;list&gt;  
            &lt;ref bean="springScheduleExecutorTask" /&gt;  
        &lt;/list&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;  
</code></pre>

<p><code>``
避免不了的配置如上，</code>taskExecutor<code>已经在前面描述过，第二段的</code>pollItInterfaceTaskExecutor<code>就是把线程池执行者
作为参数传给自己编写的任务的构造函数，然后第三段定义一个周期执行的任务，设置好执行的间隔，runnable要提供自己编写的业务类（第二段中的内容），
最后第四步把这个周期任务交给Spring的</code>ScheduledExecutorFactoryBean`工厂来负责管理。
需要注意的是，ScheduledExecutorFactoryBean是spring4中的写法，在spring3中还是另一套描述方式，虽然功能差不多。
但在版本升级时，这是一个不大不小的坑。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSP中的EL表达式和Helper]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/06/12/jspzhong-de-elbiao-da-shi-he-helper/"/>
    <updated>2014-06-12T19:05:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/06/12/jspzhong-de-elbiao-da-shi-he-helper</id>
    <content type="html"><![CDATA[<h2>JSP中的代码</h2>

<h3>传统的老三样</h3>

<p>长久以来的Java Web开发，在jsp层面进行读取或逻辑控制等行为时主要有<strong>Scriptlet</strong>、<strong>Helper</strong>和<strong>标签</strong>三种方式。</p>

<p>其中，Scriptlet是最不受推荐的方式，最为推荐的是用 <strong>标签</strong> 的方式，而Helper因为免不了会使用Scriptlet，所以流传的也不广。而标签方式中，不单有相对通用的JSTL（JSP Standard Tag Library，JSP标准标签库)，每个框架往往还有自己的标签库。</p>

<p>如struts1的：</p>

<p><code>&lt;bean:write name="spRinglib" property="down_cnt"/&gt;</code></p>

<p>struts2的：</p>

<p><code>&lt;s:property value="r.department" /&gt;</code></p>

<p>jstl的：</p>

<p><code>&lt;c:out value="${user.company}" escapeXml=="false"/&gt;</code></p>

<p>这种方式的一大特点就是冗长和啰嗦。信息的表达力很差。上述还只是用于输出的，一旦碰到条件判断等，标签的表现更是只能用拙劣二字来加以形容。同时，每个框架各搞一套，给程序员也会带来很大的负担，对项目维护也带来更多的成本。</p>

<p>然而，对于程序员而言，输出内容、流程控制等原本有着更直接和通用的描述方式： 编写代码。比如Java程序员自然用Java编写代码，Ruby的则自然用Ruby。
如果这些重新发明的标签，具有比语言更好的表达和组织能力，那么显然大家应该放弃语言本身，比如不使用java，而在MVC的各个部分都
使用标签。但既然这个没有发生，说明标签在大部分时候并不合适。</p>

<h3>新的变化-EL表达式的出现</h3>

<p>好在随着EL表达式的推出，情况逐步有所改观。比如同样是上面的输出，EL的写法可以是 <code>${r.department}</code>，调用数组也可以是<code>${list[0].name}</code> 。不过EL目前还没有支持逻辑控制，所以逻辑控制还是要用jstl的标签。</p>

<p>但至少在老三样之外提供了新的一种方式，并且使得使用<strong>Helper</strong>模式可以不需要必须用Scriptlet。</p>

<h2>EL中使用Helper</h2>

<p>说的简单点，其实就是在jsp页面中，通过EL表达式可以调用Java实现的方法。获得类似<code>${helper.getflow(userInfo.bendiAndNationFlux[2][0])}</code> 。 其中，getflow是一个用Java写的静态方法。</p>

<p>而使用Scriptlet配合helper，则会出现下面的代码：</p>

<p>```java
&lt;%
UserInfo userInfo = (UserInfo) request.getAttribute("userInfo");
long flow = (long[] )(userInfo.getBendiAndNationFlux().get(2))[0];
SheetAttendAction helper = (com.sanss.richtone.web.action.request.SheetAttendAction )request.getAttribute("helper");
%></p>

<p>&lt;%=  helper.cpSelectHelper(requestSheetForm.getManager(), spInfo.getCpCode(), spInfo.getCpName()) %>
```</p>

<p>光写出来的代码方面，不使用EL时已经要长很多了，明明只是一个调用取值显示的操作，却要先声明一系列的东西。同时，这些类型还要在jsp
的头上import进来。而IDE对jsp的import Class支持的并不好。所以确实相当麻烦。</p>

<p>对比一下可以发现，EL能够调用方法的话，可以带来多大的方便。使用Helper方法时，无论是Scriptlet还是EL表达式，在Controller层面，做
的事情都是类似的。</p>

<p>```java
//在controller里定义方法
  public static String getflow(long flow) {</p>

<pre><code>DecimalFormat format = new DecimalFormat("###0.0");
long tmpFlow = flow / 1024;
double df = 0;
if (tmpFlow &lt; 1) {
  return flow + "K";
} else if (tmpFlow &lt; 1024.0) {
  df = flow / 1024.0;

  return format.format(df) + "M";
} else {
  df = flow / 1024.0 / 1024;
  return format.format(df) + "G";
}
</code></pre>

<p>  }</p>

<p>  //在action中，注入属性
  @RequestMapping(value = "myflow", method = RequestMethod.GET)
  public String myflow(Model model, @ModelAttribute("mdn") String mdn, @ModelAttribute("userInfo") UserInfo userInfo) {</p>

<pre><code>model.addAttribute("helper", this);
return "nubia/myflow";
</code></pre>

<p>  }
```</p>

<p>这样一来，定义自己的方法和使用这个方法就极为简便了。需要指出的是，EL表达式里面可以调用方法，即支持el里面带()调用，是<strong>直到
servlet3.0标</strong>准出现才成形的，只有在tomcat7使用，即便是<del>tomcat6也不支持</del>这种调用方式。从中，可以看出EL越来越强大趋势。
但也反过来可以证明过去方法之错误。</p>

<h2>EL难道就不是Scriptlet？</h2>

<p>如果使用过其他Web开发语言的话，可以发现EL表达式和在页面模板里写脚本语言很类似。比如 <code>${r.department}</code> 和 <code>&lt;%= r.department%&gt;</code>
除了把${}换成了&lt;%=%>实在没有其他区别， <code>${helper.getflow(userInfo.bendiAndNationFlux[2][0])}</code> 可能是写成了 <code>&lt;%= getflow(userInfo.bendiAndNationFlux[2][0])%&gt;</code> 。</p>

<p>实际上，目前的EL，除了没有逻辑判断的能力之外，已经具备了很多Scriptlet的特性。那么区别在哪里呢？</p>

<p>我觉得最关键的区别在于语言本身。所谓Scriptlet其实是Java Scriptlet，需要一系列的声明才能使用。强类型编译语言有很多的好处，但在页面
显示方面，并非其所长。所以，不得不发明一套新语言来走Scriptlet的路子。 而对于另外一些本身就是脚本的语言，重新发明一套EL就显得没有必要了。</p>

<p>EL的Scriptlet和Java的Scriptlet完全是两码事情，倒是和ruby的Scriptlet几乎没有区别。
EL的支持来的有点慢，但好歹还是来了！</p>

<h3>对EL未来的期盼</h3>

<p>作为一个开发者，十分期望未来的EL能够再走一步，增加对 <code>if</code> <code>for</code>的原生支持，而不再需要使用麻烦的标签。能否发生这样的变化，就只有
再看发展了。</p>

<h3>标签适用的情况</h3>

<p>标签其实也有其存在的价值，至少包括：</p>

<ol>
<li>分页等相对组件化的元素；</li>
<li>风格一致的表单。</li>
</ol>


<p>对于那些有组件化特征的东西，标签还是很适用的。</p>

<p>而在EL有了调用method的能力后，helper模式可以做的更多，很多页面逻辑可以放到helper中去完成，即把<code>if</code> <code>for</code>封装在helper里面。
这应该是目前最值得推崇的一种页面代码模式了。</p>
]]></content>
  </entry>
  
</feed>
