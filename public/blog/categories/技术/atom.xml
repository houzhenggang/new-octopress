<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: 技术 | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/技术/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2014-10-14T14:22:59+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Nginx 处理Spring 静态资源的配置]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/10/14/nginx-chu-li-spring-jing-tai-zi-yuan-de-pei-zhi/"/>
    <updated>2014-10-14T13:19:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/10/14/nginx-chu-li-spring-jing-tai-zi-yuan-de-pei-zhi</id>
    <content type="html"><![CDATA[<p>用Nginx处理静态资源是挺常见的一个事情，自从使用了Spring，也经常直接利用Spring的处理静态文件的功能，也能打上Etag。避免流量传输。
但是近来发现，Spring处理静态资源后，对静态文件获取的请求浏览器还是会发起，只是每次都是返回304。所以想继续借助Nginx给Spring的静态资源打上expire的标记。</p>

<p>需求也算简单：</p>

<ol>
<li>基于app toolbar的动态请求转发给java</li>
<li>gif,png，js等nginx直接处理，并加expire 3h；</li>
<li>部分.js请求如t.js还是转给java，有效期为0；</li>
<li>敏感文件不会被nginx处理，如web.xml无法被nginx转走</li>
</ol>


<p>因为目前Spring的静态资源单独存放在和WEB-INF并排的目录下，所以利用Nginx配置就大为简单了，只要限制路径名称即可。</p>

<p>```</p>

<pre><code>    location /toolbar {
        root   html;
        proxy_pass http://192.168.203.198:8080;
    }
    location ~ /toolbar/static {
        root   html;
        if (-f $request_filename) {
            expires 1d;
            break;
        }
    }
    location = /toolbar/enter/t.js {
        root   html;
        proxy_pass http://192.168.202.72:8080;
    }
</code></pre>

<p>```</p>

<p>然后在nginx的html目录下建立目录<code>toolbar</code>，并在其增加一个符号连接<code>ln -s /home/web/apache-tomcat-7.0.56/webapps/toolbar/static static</code>，就可以实现上述要求了。</p>

<p>这里面用到了几种Nginx的配置。</p>

<ol>
<li><code>location /toolbar</code>，这是最基本的匹配字符串的表达方式，优先级一般情况下也最低，然而<code>^~</code>是一个例外，它的优先级比下面的正则要高。</li>
<li><code>location ~ /toolbar/static</code>，这个是用到了正则表达式的匹配，优先级要高于基础的只比较字符。</li>
<li><code>location = /toolbar/enter/t.js</code>，这是优先级最高的匹配符，要求uri完全相等。</li>
</ol>


<p>如果需要使用正则表达式匹配，则必须使用<code>~</code>或者<code>~*</code>，其中后者和前者的区别是不区分大小写。</p>

<p>整个匹配顺序是：</p>

<ol>
<li>对<code>=</code>进行匹配，有相符的就停止；</li>
<li>对所有的非正则表达式（为使用~ 和 ~*）进行匹配，如果遇到<code>^~</code>则也停止，否则全部比对完毕后，最接近的匹配将被选用作为候选，随后进入3匹配正则表达式；</li>
<li>正则表达式按定义的顺序进行匹配，有匹配的则停止，即可选用刚刚匹配的正则表达式，如没有匹配的正则，则选用2中得到的结果。</li>
</ol>


<p>因此对静态资源的选择，可以加上<code>~</code>，也可以不加。但为了避免今后配置的冲突，还是让静态资源的优先级高一些来的好。</p>

<p>随后，可以使用下面的链接进行测试，看看是否满足需求：</p>

<p>http://192.168.203.198/toolbar/enter/t.js,<br/>
http://192.168.203.198/toolbar/static/images/logo1.png,<br/>
http://192.168.203.198/toolbar/WEB-INF/web.xml</p>

<p>前面两个应该得到返回内容，最后一个应该获得报错。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web容器中通过Spring添加Job任务]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/09/11/webrong-qi-zhong-tong-guo-springtian-jia-jobren-wu/"/>
    <updated>2014-09-11T21:59:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/09/11/webrong-qi-zhong-tong-guo-springtian-jia-jobren-wu</id>
    <content type="html"><![CDATA[<p>实际投入使用的Web站点总有很多例行任务要做，习惯的做法是利用操作系统的crontab定期执行脚本或者Java程序。
在更早的时候，曾经试过quartz，但后来因为quartz创建的线程属于JVM而不是Web容器，导致停止或
重新部署应用时线程并未终止，因此后来跑java程序例行任务的话，主要就
是单独运行jar文件。</p>

<p>时过境迁，了解到Spring已经接管了定时任务的线程处理，之前在
Web容器里跑多线程任务的最大隐患已经不存在了，所以尝试了一下在
Spring中使用例行更新。</p>

<p>这样做最大的好处当然就是代码集中，容易维护也容易部署。</p>

<h3>功能说明</h3>

<p>整个功能并不复杂，需要对redis中的设备号列表进行遍历，对每一个
号码调用远程接口获取该号码的一些动态变化的信息。取得后，这些信息
的时效时间是6小时，在失效前的10分钟内，需要再次调用远程接口刷新缓存。</p>

<p>因为整个功能的瓶颈在于远程调用，为了提高并发，
调用远程接口采取多线程的方式。而遍历的性能极好，使用单线程就够了。</p>

<h3>使用组件</h3>

<p>采用Java中线程的Executors实现起来最简单直接。Executors实质上就是一个
线程池，每塞给一个号码，就调用派发一个线程进行处理。如果没有线程可派，
则放入队列中，如队列满了则会依据设置再增加线程数量。</p>

<p><code>java
private TaskExecutor taskExecutor
</code></p>

<p>Executor确实是一个比较好的多线程编程方式，融合了Actor模式和队列，
使用起来也比较方便。</p>

<p>Executors可以由spring进行注入，在这个任务里比较合适的是采用ThreadPool*</p>

<p>```xml</p>

<pre><code>&lt;bean id="taskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"&gt;
    &lt;property name="corePoolSize" value="5" /&gt;
    &lt;property name="maxPoolSize" value="10" /&gt;
    &lt;property name="queueCapacity" value="2500" /&gt;
&lt;/bean&gt;
</code></pre>

<p>```
corePoolSize是例行打开的线程数，queueCapacity是在没有core线程处理时的排队数量，
当超过这个数量时，会再启动线程直到maxPoolSize。如果都使用完毕，则可指定溢出时的抛弃处理方式。</p>

<p>派发任务由<code>taskExecutor.execute(new PollItInterfaceTask(mdn))</code>表达，
要同步的数据通过mdn传入。</p>

<p>此外，因为遍历的线程执行速度快，而workers可能需要更长时间才能完成队列中的任务，
为防止重复提交设置了一个多线程会并发访问的集合<code>private Set&lt;String&gt; mdnInQueue = new ConcurrentSkipListSet&lt;String&gt;(); //用于记录已安排执行但还未执行的号码</code>
。整个代码的情况如下:</p>

<p>```java
package com.sanss.toolbar.job;</p>

<p>import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.TimerTask;
import java.util.concurrent.ConcurrentSkipListSet;</p>

<p>import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.junit.Assert;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.task.TaskExecutor;</p>

<p>import com.sanss.toolbar.service.CacheItInterfaceQueryService;</p>

<p>/<em>多线程发起的、向IT抓取用户套餐信息的线程池执行者，由spring中触发，根据接口run()</em>/
public class PollItInterfaceTaskExecutor  implements Runnable {</p>

<pre><code>private static Log logger = LogFactory.getLog(PollItInterfaceTaskExecutor.class);
private Set&lt;String&gt; mdnInQueue = new ConcurrentSkipListSet&lt;String&gt;(); //用于记录已安排执行但还未执行的号码
@Autowired
CacheItInterfaceQueryService cacheItInterfaceQueryService;

/*实际被多线程执行的任务,获取在队列中存放的mdn*/
private class PollItInterfaceTask implements Runnable {
    private String mdn;
    public PollItInterfaceTask(String mdn) {
        this.mdn = mdn;
    }

    public void run() {
        cacheItInterfaceQueryService.setCacheFlux(mdn);
        mdnInQueue.remove(mdn);
        Thread currentThread = Thread.currentThread();  // 获得当前的线程  
        String threadName = currentThread.getName();  
        logger.debug(threadName + ": 刷新下面号码的cache: " + mdn);
    }
}

private TaskExecutor taskExecutor;

public PollItInterfaceTaskExecutor(TaskExecutor taskExecutor) {
    this.taskExecutor = taskExecutor;

}

//任务出发后，被run自动执行的任务。首先获得所有需要提前取得IT流量信息的hashkey集合，随后遍历集合分别取出相关的一系列mdn，
//之后根据mdn检查ttl信息，发现小于500秒就安排Executor执行任务。
public void doit() {
    Set&lt;String&gt; tlbKeys = cacheItInterfaceQueryService.getAllTlbsetQueryList();
    int total = 0; //号码列表总数
    int count = 0; //本轮需要刷新的
    for (String hshkey : tlbKeys) {
        Map&lt;String, String&gt; mdns = cacheItInterfaceQueryService.getAllFieldsByAKey(hshkey);
        for(String mdn : mdns.keySet()) {
            long ttl = cacheItInterfaceQueryService.ttlFlux(mdn);
            if (ttl &lt; 500 ) {
                if (!mdnInQueue.contains(mdn)) {
                    mdnInQueue.add(mdn);
                    taskExecutor.execute(new PollItInterfaceTask(mdn));
                    count++;
               }
            }
            total++;
        }
    }
    logger.info("本轮刷新"+count+"个记录, 共有"+total+"个记录");
}

@Override
public void run() {
    // TODO Auto-generated method stub
 System.out.format("开始执行 %s ...%n", new Date());  
    doit();
}
</code></pre>

<p>}</p>

<p>```</p>

<p>CacheItInterfaceQueryService是项目中的一个服务模块，负责具体设置缓存。</p>

<p>```xml</p>

<!-- 定期去IT接口轮训的部署 -->


<pre><code>&lt;bean id="taskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"&gt;
    &lt;property name="corePoolSize" value="5" /&gt;
    &lt;property name="maxPoolSize" value="10" /&gt;
    &lt;property name="queueCapacity" value="2500" /&gt;
&lt;/bean&gt;

  &lt;bean id="pollItInterfaceTaskExecutor" class="com.sanss.toolbar.job.PollItInterfaceTaskExecutor"&gt;
       &lt;constructor-arg ref="taskExecutor" /&gt;
 &lt;/bean&gt;

&lt;bean id="springScheduleExecutorTask"  
    class="org.springframework.scheduling.concurrent.ScheduledExecutorTask"&gt;  

    &lt;property name="runnable" ref="pollItInterfaceTaskExecutor" /&gt;  

    &lt;property name="delay" value="1000" /&gt;  
    &lt;!-- 每次任务间隔 一分钟--&gt;  
    &lt;property name="period" value="60000" /&gt;  
&lt;/bean&gt;  

 &lt;bean id="springScheduledExecutorFactoryBean"  
    class="org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean"&gt;  
    &lt;property name="scheduledExecutorTasks"&gt;  
        &lt;list&gt;  
            &lt;ref bean="springScheduleExecutorTask" /&gt;  
        &lt;/list&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;  
</code></pre>

<p><code>``
避免不了的配置如上，</code>taskExecutor<code>已经在前面描述过，第二段的</code>pollItInterfaceTaskExecutor<code>就是把线程池执行者
作为参数传给自己编写的任务的构造函数，然后第三段定义一个周期执行的任务，设置好执行的间隔，runnable要提供自己编写的业务类（第二段中的内容），
最后第四步把这个周期任务交给Spring的</code>ScheduledExecutorFactoryBean`工厂来负责管理。
需要注意的是，ScheduledExecutorFactoryBean是spring4中的写法，在spring3中还是另一套描述方式，虽然功能差不多。
但在版本升级时，这是一个不大不小的坑。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[被低估的JS： 「Pro JavaScript Techniques」读后感]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/07/23/pro-javascript-techniques/"/>
    <updated>2014-07-23T16:13:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/07/23/pro-javascript-techniques</id>
    <content type="html"><![CDATA[<p>作为一个Web开发者，无法绕开的一个点就是JavaScript。而对于经过C/Java训练出来的计算机专业人员而言，是很容易轻视JS，从而使得在这方面往往要经过很长的时间和经历，才能体会到
JS的与众不同及其能力。C或者Java同JS的不同已经不用多言，而同为脚本语言的Ruby Php Perl Python 同 JS的差别也是巨大的。有一定编程基础的人，学习其他大众性的语言，比如最常用的10种语言，
一般都是比较快的。但是，JS是如此的和其他语言不一样，以至于学习起来真的费一番功夫。</p>

<p>不过，直到读了John Resig的「Pro JavaScript Techniques」，终于令我豁然开朗。Resig是大名鼎鼎的JQuery的创始人，这本书中很多主要的API可以说就是介绍了JQuery是怎么实现的。包括Id的选择，
ajax方法等。最重要的，如他所说，就是第二章面向对象的JavaScript，或者说如何从其他编程语言来理解JavaScript。</p>

<p>笔记的流水账：</p>

<h1>第一章 现代化的JS</h1>

<p>JS和它的队友：</p>

<ul>
<li>Core Javascript 1.5</li>
<li>XML2（DOM）</li>
<li>XMLHttpRequest</li>
<li>CSS（style）</li>
<li>事件</li>
</ul>


<p>```javascript</p>

<h1>注意通过prototype定义公共函数的模式</h1>

<p>function Lecture(name, teacher) {</p>

<pre><code>this.name = name;
this.teacher = teacher;
</code></pre>

<p>}</p>

<p>// 实例method
Lecture.prototype.display = function() {</p>

<pre><code>return this.teacher  + " is teaching " + this.name;
</code></pre>

<p>}</p>

<p>function Schedule(lectures) {</p>

<pre><code>this.lectures = lectures;
</code></pre>

<p>}</p>

<p>Schedule.prototype.display = function() {</p>

<pre><code>var str = "";
for (var i = 0; i &lt; this.lectures.length; i++) {
     str += this.lectures[i].display;
}       
return str;
</code></pre>

<p>}</p>

<p>var mySchedule = new Schedule([</p>

<pre><code>new Lecture("Gym", "Mr. Smith");
new Lecture("Math", "Mrs. Jones");
new Lecture("English", "TBD");
</code></pre>

<p>]);</p>

<p>alert(mySchedule.display());
```</p>

<h1>第二章 面向对象的JS( javascript的精髓)</h1>

<h3>引用</h3>

<p>引用指向的是具体的对象，引用是一个变量。
JS中的引用不会指向引用，<code>var b = a;</code>的作用永远是让b指向a表示的实际对象</p>

<h3>参数类型检查和函数重载</h3>

<p><code>if (typeof msg == 'undefined') {}</code></p>

<p>以及js对象都有的属性：构造子</p>

<p><code>if (str.constructor == String) {}</code></p>

<p>后者能够找出具体的构造对象的函数，前者对通过函数构造的对象返回的也是'object'。</p>

<p>js在每个函数里面，有一个隐含属性 <code>arguments</code> ，这是一个伪数组，可以遍历、有.length属性，但不能被修改。可以通过复制遍历变成标准数组。</p>

<p>```javascript
function sendMessage(msg, obj) {</p>

<pre><code>if ( arguments.length == 2) 
      ojb.handleMsg(msg);
else
     alert( msg );
</code></pre>

<p>}
```</p>

<h3>作用域(Scope)</h3>

<p>js通过函数来划分作用域，而不是通过代码块</p>

<p>没有var声明的，则变成全局变量</p>

<h3>闭包</h3>

<p>闭包允许内层函数引用外围函数内的变量，即便外层函数已经终止。</p>

<p>```javascript
function delayedAlert( msg, time ) {</p>

<pre><code>setTimeoute( function() {
     alert(msg); // msg就是外围函数中的变量
}, time);
</code></pre>

<p>}
```</p>

<p>curry化： 利用函数生成函数</p>

<p>```javascript
function addGenerator(num) {</p>

<pre><code> return function( toAdd) {
    return num + toAdd;
 };
</code></pre>

<p>}</p>

<p>var addFive = addGenerator(5);
alert(addFive(4)==9);
```</p>

<h3>上下文对象</h3>

<p>通过<code>this</code>表示，永远指向当前代码所处的对象中。
是调用时确定的对象。</p>

<p>function都有call和apply两个方法，可以用于指定this是什么</p>

<p>```javascript
function changeColor( color ) {</p>

<pre><code>this.style.color = color;
</code></pre>

<p>}</p>

<p>changeColor.call(main, "black");</p>

<p>function setBodyColor() {</p>

<pre><code> changeColor.apply(main, arguments); //传入隐含的全部参数
</code></pre>

<p>}
setBodyColor( "black" );
```</p>

<h2>原型式继承</h2>

<p><code>javascript
User.prototype = new Person();
</code>
其效果是每次 new User()时同时执行了new Person，且user对象就这样拥有了person的全部方法</p>

<h2>类似继承</h2>

<p>Douglas Crockford创造的<code>method</code>, <code>inherits</code>, <code>swiss</code> 三个方法。</p>

<p>```javascript
User.inherits(Person);
User.method( 'getName', function(){
  return "My name is: " + this.uber('getName');
});</p>

<p>```</p>

<h2>Base 库</h2>

<h2>Prototype库</h2>

<p>就是rails原先自带的库</p>

<h2>命名空间</h2>

<p><code>$.</code>其实就是命名空间。
```javascript
var YAHOO = {};
YAHOO.util = {};
YAHOO.util.Event = {</p>

<pre><code>addEventListner: function() {}
</code></pre>

<p>};
YAHOO.util.Event.addEventListener(...);
```</p>

<h2>清理代码</h2>

<p><code>!=</code> 和<code>==</code> 会对变量进行求值，即把对象变成false或true后进行比较，
js中， null false 0 undefined 求值后都是false</p>

<p>js一行一行地写可以不用分号，但是一旦被压缩后，换行符号都将取消，此时没有分号就不行了。鉴于js的使用场景，还行建议每行都加上分号。</p>

<p>压缩代码的三种方式:
1. 只取出空白和注释
2. 压缩变量
3. both</p>

<p>IE 是不灵的，在调试方面</p>

<p>Firefox的调试是最好的，尤其搭配firebug和 View Rendered Source，Venkman也是一个ff的扩展</p>

<p>Safari还在迅速变化发展中，Chrome与之类似</p>

<h2>测试套件</h2>

<ul>
<li>JSUnit: 老牌的</li>
<li>J3Unit: 稍新的，通Java集成的更好</li>
<li>Test.Simple , Test.More</li>
</ul>


<h1>第三章 分离式的JavaScript</h1>

<p>DOM(Document Object Model)是表达XML文档的标准，并不是唯一的方式，但确实是应用最广泛的方式。这一点和js能统一浏览器的原因一致，就是因为被广泛使用了。</p>

<p>DOM的模型：
DOM是一个树结构，根节点是html，
下属节点分为元素和文本两种类型。
每个节点包括5个指针:
1. 父节点parentNode
2. 兄节点(previousSibling)
3. 弟节点(nextSibling)
4. 第一个子节点(firstChild)
5. 最后一个子节点(lastChild）</p>

<p>整个的遍历和渲染其实都是基于DOM模型的。</p>

<h2>DOM的加载</h2>

<ul>
<li>html解析完毕</li>
<li>src中的脚本和css加载完毕</li>
<li>脚本在文档内解析并执行（此时dom并未构造起来）</li>
<li>Html DOM完全构造起来</li>
<li><p>图片和外部内容加载</p></li>
<li><p>等待整个页面的加载，基于window对象的load事件，速度最慢，因为是在图片下载之后</p></li>
</ul>


<p><code>javascript
addEvent(window, "load", function (){
  net( id("everywhere") ).style.background = 'blue';
});
</code></p>

<ol>
<li><p>把script标签放置在页面的最后，这样确保执行的时候dom已建立</p></li>
<li><p>监听DOM的加载状态，实现复杂。
jquery实现的方法，$或者说domReady，其主要原理是检查document是否已存在，document.getElementsByTagName和document.getElementById两个函数是否已存在，以及document.body是否已存在。搭配setInterval不停地检查，检查到位后就清楚timer</p></li>
</ol>


<h2>在HTML中寻找元素</h2>

<p>cssQuery， jQuery
主要是css选择器和xpath选择器</p>

<h2>获取元素的内容</h2>

<ol>
<li>获取文本 text</li>
<li>获取 html</li>
</ol>


<h2>操作元素的属性(attribute)</h2>

<p>一旦元素加载到DOM中，元素会有一个管理数组，</p>

<p><code>javascript
formElem.attributes = {
  name: "myForm",
  action: "/test.cgi",
  method: "POST"
};
</code></p>

<p>实际提供了attr方法</p>

<h2>修改DOM</h2>

<ol>
<li><p>创建节点
createElement</p></li>
<li><p>插入到DOM中<br/>
insertBefore： 在子元素前插入
<code>parentOfNode.insertBefore(nodeToInsert, beforeNode)
appendChild: 插入一个父节点中最后一个子节点，</code>parenElem.appendChild(nodeToInsert);`</p></li>
</ol>


<h2>异步与事件处理</h2>

<h3>异步事件与线程</h3>

<h3>事件阶段</h3>

<p>捕获和冒泡，捕获是由外向内，冒泡是由内向外</p>

<p>是否能停止冒泡？</p>

<p>通过对按键事件的处理，停止textarea的正常响应
```html
<html>
<head></p>

<p></head></p>

<p><body></p>

<p><textarea rows="4" cols="50">
At w3schools.com you will learn how to</p>

<p>make a website. We offer free tutorials</p>

<p>in all web development technologies.
</textarea></p>

<script>
document.getElementsByTagName

("textarea")[0].onkeypress = function(e) 

{ 
e = e || window.event;
return true;

};
</script>


<p></body>
```</p>

<p>上面的e是事件对象</p>

<p><code>this</code>作为一种指代，可以泛化成各类元素，使得js的编写变得简单</p>

<p>```javascript
var li = document.getElemensByTagName("li");
for (var i = 0; i &lt; li.length; i++) {
  li[i].onclick = handleClik;
}</p>

<p>function handleClick() {
   this.style.backgroundColor = "blue";
   this.style.color = "white";
}
```</p>

<h3>取消冒泡（重载浏览器的事件处理）</h3>

<p>```javascript
function stopBubble(e) {
  //如果传入了事件对象，那么就是非IE浏览器
  if ( e &amp;&amp; e.stopPropagation ）</p>

<pre><code> e.stopPropagation();
</code></pre>

<p>  else // 否则使用IE的方式来取消事件冒泡</p>

<pre><code> window.event.cancelBubble = true;
</code></pre>

<p>}</p>

<p>```</p>

<h3>取消浏览器的默认行为（重载）</h3>

<p>```javascript
function stopDefault(e) {
  if (e &amp;&amp; e.preventDefault)</p>

<pre><code>e.preventDefault();
</code></pre>

<p>  else //windows 特供</p>

<pre><code>window.event.returnValue = false;
</code></pre>

<p>  return false;
}</p>

<p>li.onclick = function(e) {</p>

<pre><code>iframe.src = this.href
return stopDefault(e);
</code></pre>

<p>}
```</p>

<h2>绑定事件的3中方法</h2>

<ol>
<li>传统方法</li>
</ol>


<p><code>javascript
windo.onload = function() {};
</code></p>

<p>好处在于简单稳定，处理事件时可以使用this关键字；
坏处是事件只在冒泡时运行，捕获时不运行。且一个元素一次只能绑定一个处理函数，即onload=func2会替换前面已经注册过的函数。同时ie中，还不能得到事件对象e。</p>

<ol>
<li>W3C</li>
</ol>


<p>```javascript
window.addEventListener('load', function(){}, false);</p>

<p>```
相对于第一种，好处是第三个参数指明了哪个阶段处理事件：false（冒泡）或true(捕获)；事件对象可以通过处理函数的第一个参数获取；不会覆盖之前已绑定的事件。缺点就是老的ie不支持。</p>

<ol>
<li>IE绑定</li>
</ol>


<p><code>javascript
window.attachEvent('onload', function(){});
</code></p>

<p>粗看起来和w3c的类似，但细节有很多不同：
* 仅支持冒泡阶段
* this关键字指向了window对象
* 事件对象存在于window.event中
* 事件必须以ontype的形式命名，如onload而非load</p>

<ol>
<li>facade的addEvent和removeEvent</li>
</ol>


<p>```javascript
addEvent( window, "load", function() {</p>

<p>});
```</p>

<p>唯一的缺点是仅能工作在冒泡阶段</p>

<h2>事件类型</h2>

<ul>
<li>鼠标</li>
<li>键盘</li>
<li>UI，focus，blur</li>
<li>表单事件</li>
<li>加载和错误</li>
</ul>


<h2>分离式的javascript</h2>

<p>就是不在html里绑定怎么处理js，是的href可以是有意义的，使得js禁用时系统依然可以使用</p>

<h2>访问CSS属性</h2>

<h2>位置 尺寸和可见性</h2>

<h3>位置</h3>

<p>4种定位</p>

<p>position: static; //top和left不起作用，顺序排版
position: relative; //top和left相对于static进行偏移
position: absolute; //相对于它的第一个非静态定位的祖先元素而展示，如没有这样的祖先元素，就是相对于整个文档
position: fixed; //相对于浏览器窗口
top: 0px;
left: 0px;
right: ;
bottom: ;</p>

<h3>元素的可见性</h3>

<ul>
<li>visibility: hidden, visible</li>
<li>diplay: none, block, inline, ''</li>
<li>opacity:

<ul>
<li>filter: 'alpah(opacity='50)</li>
<li>opacity: 50/100</li>
</ul>
</li>
</ul>


<h2>动画效果</h2>

<p>1秒执行20帧动画</p>

<p>```javascript
for ( var i = 0; i &lt;= 100; i += 5 ） {</p>

<pre><code> (function(){
     var pos = i;
     setTimeout(function(){

        elem.style.height = (pos/100)*h + "px";
     }, (pos+1)*10);

 })();
</code></pre>

<p>}</p>

<p>```</p>

<h2>viewport是视口，就是浏览器滚动条内的一切东西</h2>

<p><code>window.scrollTo(0, 0)</code>可以移动浏览器窗口位置</p>

<h2>拖放功能</h2>

<p>使用拖放库可以</p>

<p>P145的悬停真是写的漂亮</p>

<h1>第四章 Ajax</h1>

<p>这部分其实主要就是举例ajax的例子，来做了综合的应用。</p>

<p>responseXML和responseText是xhttprequest的主要返回对象
其中，xml是响应头的content-type为xml时有效</p>

<p>一个$.ajax的实现，代码真精妙</p>

<p>返回响应的种类：</p>

<ul>
<li>xml</li>
<li>json</li>
<li>html ，可以直接注入html</li>
<li>script</li>
</ul>


<p>pageHeight(判断整个页面又多高)，scrollY(获知当前视口的顶部滚动到了哪里)，
windowHeight(获知视口有多高)</p>

<p>四步法：</p>

<ol>
<li>DOM操作</li>
<li>获取数据</li>
<li>事件监测</li>
<li>发起ajax请求</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tomcat7 采用 redis作为session store]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/07/14/tomcat7-cai-yong-rediszuo-wei-session-store/"/>
    <updated>2014-07-14T15:57:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/07/14/tomcat7-cai-yong-rediszuo-wei-session-store</id>
    <content type="html"><![CDATA[<p>有个项目部署了几套Tomcat，而前置分发又不是按ip映射的，所以无法象往常一样继续使用内存作为session存放的介质。
同时，业务主要由使用移动互联网的手机来访问，ip也存在随时切换的可能，所以按ip进行映射在此场景下并不是一个好的办法。因此，最终决定使用redis来作为公共的session存储空间，实现session的共享。</p>

<p>主要用到的工具包:</p>

<ul>
<li><a href="https://github.com/jcoleman/tomcat-redis-session-manager#readme">tomcat-redis-session-manager</a></li>
<li>jedis</li>
<li>commons-pool</li>
</ul>


<p>需要注意的是，这个session manager已经有挺长时间停止开发了，从issues来看，表现还算基本稳定。目前也已经支持tomcat6和tomcat7，jdk也是6和7均支持。但是，上述几个包却存在着特定的版本依赖。必须为：</p>

<ol>
<li>tomcat-redis-session-manager-1.2-tomcat-7.jar</li>
<li>jedis-2.0.0.jar</li>
<li>commons-pool-1.3.jar<br/>
尤其是最后一个，千万马虎不得。上述三个包必须放入tomcat的lib目录下。</li>
</ol>


<p>然后，再在应用的context.xml,可以是应用的该文件也可以是tomcat/conf目录下的该文件，加入下列配置即可：</p>

<p>```xml
<Valve className="com.radiadesign.catalina.session.RedisSessionHandlerValve" />
&lt;Manager className="com.radiadesign.catalina.session.RedisSessionManager"</p>

<pre><code>     host="192.168.203.198" 
     port="6379" 
     database="1" 
     maxInactiveInterval="600" /&gt; 
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开发语言还真是一个问题]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/07/04/kai-fa-yu-yan-huan-zhen-shi-%5B%3F%5D-ge-wen-ti/"/>
    <updated>2014-07-04T22:22:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/07/04/kai-fa-yu-yan-huan-zhen-shi-[?]-ge-wen-ti</id>
    <content type="html"><![CDATA[<p>使用Node.js开发Express框架的的牛人TJ Holowaychuk宣布
<a href="https://medium.com/code-adventures/farewell-node-js-4ba9e7f3e52b">退出使用Node.js</a>。
这个效果有点类似于如果DHH宣布不再使用Ruby进行开发。</p>

<p>此牛希望开发分布式的系统，但受不了Node倾向于性能而忽略
使用的便利性（usability）和鲁棒性（robustness）。
而他使用Go语言开发的分布式系统，则坚固，表现的也更好，代码也更易维护。
他也提到了同步式的代码比异步式的还是容易测试及理解。</p>

<p>从我个人的经历而言，有一阵子仔细研究过Node，我的硕士毕业论文中Node是最重要的一个组成部分。
也开发了一个不错的HTTP分发系统。但是，最终我并没有采用Node在生产系统中。
原因在于，尽管Node的基于事件的并发模式很易于处理大并发的慢速请求，
但除非去做云计算级别的分发，不然Java的NIO已足够应付性能方面的需要。</p>

<p>而在Node的web开发方面，Node及Express提供的基础设施比Rails差的很远，开发效率和体验都是不能比的。
所以，看来看去在服务端并没有很适用Node.js的场景。
至少，在Java和Ruby可以作为选择的场合下，没有Node的发挥空间。</p>

<p>至于Go为什么适合分布式开发，则需要进一步了解。不过以前看见go编译输出的是<code>a.out</code>就很让人有使用的欲望。</p>

<p>Node的崛起很大程度上托V8引擎性能优异的福，在脚本语言中，Node的运行性能就是独一无二的。
但和编译型语言比起来，Node就没什么优势了。只是有一阵子大家都相信脚本语言天生可以比编译型开发的更有
效率些，所以万众瞩目于Node。很多受Ruby运行性能之苦的开发者，也转到了Node开发服务。随后，
移动引用的兴盛使得JSON成为一种标准的传输形式，也由此Node成为了很多接口服务的开发选择。</p>

<p>然而，对此我还是秉承我的观点，仅仅开发接口的话，Java的开发效率也不低，性能一般也不会成为瓶颈。
而Node的开发还是不如Java方便，人才和教育的基础二者差距就更大了。Javascript只有在浏览器中才是王者。
因为浏览器的单线程，以及等待事件发生，才是天生适合他的。而且，世上浏览器那么多，所有的浏览器都只认可
Javascript。
至于服务端，只有在特定的少数的场合，
Node才具备突出的优势。</p>

<p>Ruby和Rails的优势是在于开发效率以及让人快乐，性能始终是不让人满意的一个环节。<br/>
Java的优势是大量的人才基础和教育基础，强大的性能和稳定性。也因为人才众多，所以才有足够的人力来打造像Spring这样的
开发工具。对很多语言来讲，如果像Java那样啰嗦，是很难得到足够多的产出的。<br/>
Javascript，还是在浏览器中发挥威力吧。</p>
]]></content>
  </entry>
  
</feed>
