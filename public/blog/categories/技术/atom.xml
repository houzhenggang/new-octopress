<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: 技术 | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/技术/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2016-04-21T17:09:25+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[openwrt n56u 和iptv]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2016/04/05/openwrt-n56u-he-iptv/"/>
    <updated>2016-04-05T12:14:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2016/04/05/openwrt-n56u-he-iptv</id>
    <content type="html"><![CDATA[<p>四年以前写的<a href="/blog/2012/02/20/the-way-to-link-to-iptv-in-shanghai-through-vlan/">上海电信IPTV的VLAN ID和通过交换机连接两路IPTV</a>，而由于4k高清IPTV机顶盒的推广，
当时的内容已经有些不合时宜。尽管，用一个交换机还是可以实现连接两路iptv。</p>

<p>区别主要在于新的4k高清机顶盒同小红等盒子一样，需要双平面才能跑得起来。所谓双平面就是在专网之外机顶盒也要能够连接公网。
这个变化其实是带来一大好处的，即通过一个路由设备接光猫的一个口子，也可以让iptv和公网业务同时跑起来。下面记录一下操作过程。</p>

<h3>openwrt</h3>

<p>首先，这么灵活的配法，当前asus netgear等原厂的固件是不支持此种功能的，所以需要第三方固件，如openwrt dd-wrt。我选择了openwrt，是因为其官网支持asus-n56u路由器。
<a href="https://wiki.openwrt.org/toh/asus/rt-n56u">官方链接</a> ，可以从前面这个链接获得操作过程和固件。注意下载<code>squashfs-factory.bin</code>，不要下载chaos版。我就误下了chaos版，导致只能采用reset的办法重新装回了华硕的固件。openwrt很贴心的一点就是在网页里提供了恢复固件的操作步骤</p>

<p><code>sh
Download &amp; Install the asus "Firmware Restoration" from asus website
Download the factory image from asus
Enter Recovery Mode
Unplug Router
Hold Reset Button and Plug in Router
Release button when front LED flashes slowly
Use the following to set up your TCP/IP settings:IP address: 192.168.1.x Subnet mask: 255.255.255.0
Select firmware *.trx and upload
</code></p>

<p>要点是把本机的ip设置成192.168.1.2,而且如果本机有多块网卡（包括虚拟网卡）则只保留一个连接路由器lan口的网口活跃。这样华硕的固件才
明确会打开这个网口并同已进入恢复模式的路由器相连。有了这个恢复模式存在，意味着asus的这款路由器基本是刷不死的。</p>

<p>安装完openwrt，设置好基本的wan口，我是采用的dhcp方式获取wan地址，就可以进入配置iptv vlan的过程了。</p>

<h3>关于4k高清机顶盒获取公网和专网IP的流程</h3>

<p>参考<a href="https://www.ydkfblog.com/?m=201602">上海电信光猫一体机配合Openwrt拨号正常使用OTT 4K IPTV</a>，
找到了iptv dhcp的流程
<img src="/images/openwrt/4kiptvdhcp.png" alt="image" /></p>

<p>看清流程后，就可以知道：
1. 要先让4k iptv机顶盒接入公网<br/>
2. 路由器要支持DHCP-Option：125<br/>
3. 路由器要支持vlan 85的进出</p>

<p>公网配置是基础，剩余两点的配置可以归纳为</p>

<blockquote><ol>
<li><p>接在自备路由器上时，将路由器WAN口、CPU口、接IPTV的口 一起新建一个VLAN 85，3个端口全部为tagged</p></li>
<li><p><code>/etc/dnsmasq.conf</code>中要加入<code>dhcp-option-force=125,00:00:00:00:1b:02:06:48:47:57:2d:43:54:03:05:48:47:32:32:31:0a:02:20:00:0b:02:00:55:0d:02:00:2e</code> ,即对Option 125的支持</p></li>
</ol>
</blockquote>

<p>做完这些之后，至少目前中兴的机顶盒是全面支持了。</p>

<p>配置附录</p>

<p>/etc/config/network
```
config switch</p>

<pre><code>    option name 'switch0'                                                                                                                                                        
    option reset '1'                                                                                                                                                             
    option enable_vlan '1'                                                                                                                                                       
    option enable_vlan4k '1'                                                                                                                                                     
</code></pre>

<p>config switch_vlan</p>

<pre><code>    option device 'switch0'                                                                                                                                                      
    option vlan '1'                                                                                                                                                              
    option ports '0 1 2 3 8t'                                                                                                                                                    
</code></pre>

<p>config switch_vlan</p>

<pre><code>    option device 'switch0'                                                                                                                                                      
    option vlan '2'                                                                                                                                                              
    option ports '4 8t'                                                                                                                                                          
</code></pre>

<p>config switch_vlan</p>

<pre><code>    option device 'switch0'                                                                                                                                                      
    option vlan '85'                                                                                                                                                             
    option vid '85'                                                                                                                                                              
    option ports '1t 2t 4t 8t'    
</code></pre>

<p>```</p>

<p>/etc/dnsmasq.conf
```</p>

<h1>cname=bertand,bert</h1>

<p>dhcp-option-force=125,00:00:00:00:1b:02:06:48:47:57:2d:43:54:03:05:48:47:32:32:31:0a:02:20:00:0b:02:00:55:0d:02:00:2e
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文艺的HashMap初始化]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/11/23/wen-yi-de-hashmapchu-shi-hua/"/>
    <updated>2015-11-23T20:33:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/11/23/wen-yi-de-hashmapchu-shi-hua</id>
    <content type="html"><![CDATA[<p>多年以来，受制于java没有初始设置<code>hash</code>对-值的方法，例如js有：</p>

<p><code>javascript
var obj = {
  a: 1, b: 2
};
</code></p>

<p>ruby在借鉴js的文法之前，有著名的rocket标注</p>

<p><code>ruby
obj = {:a=&gt;1, :b=:2}
</code></p>

<p>而java则只能继续使用过程定义来描述</p>

<p><code>java
Map&lt;String, integer&gt; map = new HashMap&lt;String, integer&gt;();
map.put("a", 1);
map.put("b", 2);
</code></p>

<p>而最近发现了一种文艺一些的写法：</p>

<p>```java
Map&lt;String, integer> map = new HashMap&lt;String, integer>(){
  {</p>

<pre><code>put("a", 1);
put("b", 2);
</code></pre>

<p>  }
}</p>

<p>```</p>

<p>此种写法是利用了创建一个匿名类的文法，该匿名类直接继承自HashMap，而第二套花括弧则是实例初始化。</p>

<p>实例初始化是对应于静态初始化，后者属于整个类，而前者属于某个对象初始化时进行。</p>

<p>```java
public class demo {
  static {</p>

<pre><code>do sth of class
</code></pre>

<p>  }</p>

<p>  {</p>

<pre><code>do sth of instance
</code></pre>

<p>  }
}
```</p>

<p>其实这种写法的代码行数并不少，但是语意，主要是段落的分割清楚了许多。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring的@SessionAttributes和@ModelAttribute在Redirect时的特殊表现]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/11/14/springde-at-sessionattributeshe-at-modelattribute/"/>
    <updated>2015-11-14T22:50:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/11/14/springde-at-sessionattributeshe-at-modelattribute</id>
    <content type="html"><![CDATA[<p><code>@ModelAttribute</code> 在Spring中有两个地方可以填写：</p>

<ul>
<li><p>Controller的Action method的参数前标注，提示需要设置该值<br/>
```java
@ModelAttribute
public void getUser(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {</p>

<p>...
model.addAttribute("mdn", mdn);
model.addAttribute("userInfo", userInfo);
model.addAttribute("helper", new HomeHelper(userInfo));</p></li>
</ul>


<p>}
```</p>

<ul>
<li>Controller中单独的方法前标注，该方法通常不是action，但加注<code>@ModelAttribute</code>后会在Action method执行前被调用<br/>
<code>java
@RequestMapping(value = "/addDiy", method = RequestMethod.GET)
public ModelAndView addDiy(@ModelAttribute("operator") String operator) {
...
}
</code></li>
</ul>


<p>使用效果来讲就是确保第一种情况下，action method的参数会被设置，而设置的根据主要是以下4种：</p>

<ol>
<li>来自<code>@SessionAttributes</code>使用中被设置在session中的<code>ModelAttribute</code></li>
<li>上面提到的第二个使用的方法中产生的对象</li>
<li>基于URI的模板变量+type converter</li>
<li>直接new的，即默认的构建方法</li>
</ol>


<p>```java
@Controller
@RequestMapping(value = "/home")
@SessionAttributes({"operator" })
public class HomeController {</p>

<pre><code>...
/*登陆验证，成功后转至home action，验证失败则继续显示login页面*/
@RequestMapping(value="login", method = RequestMethod.POST)
public String loginPost(HttpSession session, Model model, String username, String password, String yzm, RedirectAttributes redirectAttributes) {
    redirectAttributes.addFlashAttribute("username", username);
    redirectAttributes.addFlashAttribute("password", password);

    /*检测验证码是否正确*/
    if (!StringUtils.equals((String) session.getAttribute("rand"), yzm)) {
        redirectAttributes.addFlashAttribute("errorMessage", "验证码不正确，请输入正确的验证码");
        return "redirect:/home/login";
    }

    CInterfaceOper ciop = null;
    String status = null;
    try {
        ciop = new CInterfaceOper(username, password);
        status = ciop.getUserStatus();
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

    if (StringUtils.equals(status, ConstVar.Status.Normal)) { //用户业务状体正常


        //由modelattribute获取operator时使用
        // redirect的情况下，加在model里面不会被sessionAttributes处理到session中
        //model.addAttribute("operator", operator);
        redirectAttributes.addFlashAttribute("operator", username);

        String lastUri = (String)session.getAttribute(ConstVar.REQUEST_URI);
        if (StringUtils.isEmpty(lastUri)) {
            return "redirect:/home";
        } else {
            return "redirect:"+lastUri;
        }

    } else {
        redirectAttributes.addFlashAttribute("errorMessage", "登录失败，请检查用户名和密码");
        return "redirect:/home/login";
    }
}
</code></pre>

<p>}</p>

<p>```</p>

<p>在<code>Controller</code>类前标注的<code>@sessionAttributes</code>就可以把action中的model包含的同名属性固化在session中。
但是，因为整个action的返回不是直接渲染jsp，而是使用了<code>redirect:/home</code>这样的重定向语句，所以起初并没有奏效。
而是要把<code>operator</code>放在<code>redirectAttributes</code>中，才会被固化。这说明spring选择固化属性是当且仅当
在渲染页面前。</p>

<p>在需要使用该session的属性action处，直接使用下面代码即可。</p>

<p>```java
@RequestMapping(value = "/addDiy", method = RequestMethod.GET)
public ModelAndView addDiy(@ModelAttribute("operator") String operator) {
  ModelAndView mav = new ModelAndView();</p>

<pre><code>List&lt;RingRequest&gt; ringrequest=ConstVar.DIV_LIST;
RingRequest ringrequest1=null;
if(ringrequest!=null&amp;&amp;ringrequest.size()&gt;0){
   ringrequest1=lingyingdiyService.add(ringrequest.get(0), operator);
}
</code></pre>

<p>  mav.setViewName("webapp/ringDiy/lingyindiy4");
  mav.addObject("ringrequest", ringrequest1);
  return mav;
}
```</p>

<p>在Session范围内使用注入的逻辑还是很清晰的，只是需要注意一下redirect带来的坑。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安卓开发初体验]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/10/18/an-zhuo-kai-fa-chu-ti-yan/"/>
    <updated>2015-10-18T17:08:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/10/18/an-zhuo-kai-fa-chu-ti-yan</id>
    <content type="html"><![CDATA[<p>鉴于项目形势所迫，对一个安卓的demo只能自己直接来了。
也算半逼之下入门了安卓开发。以下面这张图来论，</p>

<p><img src="../images/androidmap.jpg" alt="安卓学习路线图" /></p>

<p>基础部分基本上java web开发工程师都是具备的，入门部分大致跟着google的开发
文档做完第一个例子也就都接触到了。
高级主题里面倒是碰了百度地图和Webview这两个必须接触的东西。</p>

<p>就入门而言，学习资料很丰富，尤其是安卓的开发文档还是很全面的，比大部分开源软件的
教程要强许多，毕竟是有正经的商业公司全面支持的。</p>

<p>就编程而言，全部基于Java的，不像Web开发要再切换到Javascript，整个体系的一致性
更好，编写起来还是轻松愉快的。而传递参数方面，摆脱了必须从客户端到服务端，如果是在
界面中跳转其实要比Web方便。这其实也是一个进程间、线程间通信的事情，而作为App，
其通信的方式还是很丰富的。从最基础的Intent，到手机上各应用系统的彼此调用，
以及Json传递会服务端等，可以玩的花样很多。</p>

<p>对于任何写过界面的Java程序员，上手安卓应用开发应该还都是挺轻松的。
毕竟大部分需要的技能有重合，而体系上安卓也更适合学习。当然，学安卓也有特定的痛苦，
比如屏幕尺寸及比例、API升级快导致节奏混乱。不过在手机端确实是个值得投入的东西。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于OAuth的API Token生成]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/07/22/ji-yu-oauthde-api-tokensheng-cheng/"/>
    <updated>2015-07-22T16:00:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/07/22/ji-yu-oauthde-api-tokensheng-cheng</id>
    <content type="html"><![CDATA[<p>基本思路是对方要先注册一下，<strong>注册的时候提供回调地址</strong>，服务平台生成一个<strong>id</strong>给该用户。</p>

<p>然后，用户用这个id来访问平台公开的认证链接，平台生成<strong>code</strong>并通过注册时提供的<strong>回调地址</strong>发送给对方。</p>

<p>对方最后根据code到<strong>token</strong>获取地址拿到实际的token内容：</p>

<p><code>
{
  "access_token":"01234567-89ab-cdef-0123-456789abcdef",
  "expires_in":28799,
  "refresh_token":"01234567-89ab-cdef-0123-456789abcdef",
  "token_type":"Bearer",
  "user_id":"01234567-89ab-cdef-0123-456789abcdef",
  "session_nonce":"2bf3ec81701ec291"
}
</code></p>
]]></content>
  </entry>
  
</feed>
