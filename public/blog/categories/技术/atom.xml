<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: 技术 | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/技术/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2014-12-11T23:12:23+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[并发的ab测试和校验码对并发状况处理的盲区]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/12/11/bing-fa-de-abce-shi-he-xiao-yan-ma-dui-bing-fa-zhuang-kuang-chu-li-de-mang-qu/"/>
    <updated>2014-12-11T21:55:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/12/11/bing-fa-de-abce-shi-he-xiao-yan-ma-dui-bing-fa-zhuang-kuang-chu-li-de-mang-qu</id>
    <content type="html"><![CDATA[<p>某个报障称我们的短信轰炸拦截无效，听到后感觉比较奇怪，因为此限制已经加上并且经过测试验证。
但提供的素材上，单个用户确实同时收到了多条短信。于是又检查了一遍代码，发现问题可能出在并发上。</p>

<p>限制的过程是这样的：</p>

<ol>
<li>取出session中的校验码并与请求中的参数进行比较，通过的进入第2步，如失败则直接进入第3步；</li>
<li>发送短信；</li>
<li>刷新校验码。</li>
</ol>


<p>而如果扫描软件获取验证码后，同时交给多个线程并发发起请求，因为第一步执行的速度较快，而下发短信的请求处理较慢，
极其可能在执行第3步之前，另外几个请求也都通过了第一步的检查，从而可以进行第二步。</p>

<p>然后就是要验证这种猜测是否成立。由于扫描软件并不是我的，所以需要自己模拟这个请求，而又由于一些陷阱，导致整个验证也
颇费了一番周折。</p>

<h3>第一个坑： ! 和 &amp;都是shell的特殊字符</h3>

<p>最简单的模拟无非就是ab测试（ApacheBench），</p>

<p><code>ab -c 5 -n 10  http://xxx.com/portal/get\!validate.action?user_id=1xxxx\&amp;verfiyCode=5614</code></p>

<p>但是，一开始并没有在!和&amp;前面加上转移符号，所以运行失败</p>

<h3>第二个坑： 需要提前放入session</h3>

<p>一开始并没有搞清楚shell执行ab失败只是因为缺乏转义符号，于是尝试使用编写客户端代码解决。首先使用了Java的Jersey，
因为手头一个项目最近使用这个也比较顺手。运行之后发现每次都是返回404的错误。而在浏览器中，即使验证码不对，也会显示
正确的jsp。换了一台机器后，发现自己犯了个低级错误，因为验证码是存放在session里面的，而Jersey的普通请求不会
带cookie上去，因此就得到了错误的响应。</p>

<p>于是想着给Jersey的请求加上cookie消息头。一番考察后，被告知Jersey原生态并不支持直接加cookie，于是决定还是换用
ruby的rest-client。</p>

<p>```ruby
require 'rest-client'</p>

<p>jsp = "http://xxx.com/portal/";
passportUrl = "xxx.com!validate.action?user_id=1xxxxxx&amp;verfiyCode=9813';</p>

<p>def s
  response = RestClient.get(jsp)
  @cookies = response.cookies</p>

<p>  @cookies['JSESSIONID'] = '74113695C0FB915393AE69DD63EAE088'
  p @cookies
  #puts response.body</p>

<p>  5.times do |n|</p>

<pre><code> response = RestClient.get(passportUrl, cookies: @cookies)
</code></pre>

<p>  end
  puts response.body
end</p>

<p>s()
```</p>

<p>手工填入浏览器中的校验码，运行正常。但ruby的单线程运行方式下，
模拟不出并发的效果，所以还是需要回到ab测试上。</p>

<p>最后的结果倒是很简单，给路径加上转义并添加cookie头即可：</p>

<p><code>ab -c 5 -n 10 -H "Cookie: JSESSIONID=74113695C0FB915393AE69DD63EAE088;" http://xxx.com/portal/get\!validate.action?user_id=1xxxx\&amp;verfiyCode=5614</code></p>

<p>这条命令基本上可收到5条短信，因为并发是5个。</p>

<h3>得到的教训</h3>

<p>部分业务逻辑在设计和实现时必须考虑并发的情况，尽管这个确实有点难度。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tomcat7 采用 Redis作为session Store - 2]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/11/19/tomcat7-cai-yong-rediszuo-wei-session-store-2/"/>
    <updated>2014-11-19T15:57:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/11/19/tomcat7-cai-yong-rediszuo-wei-session-store-2</id>
    <content type="html"><![CDATA[<p>在<a href="/blog/2014/07/14/tomcat7-cai-yong-rediszuo-wei-session-store/">Tomcat7 采用 Redis作为session Store</a>中，使用了redis作为tomcat的session共享。
在打过几个补丁后，基本也算运作正常。只是偶尔总是有些null的session需要定期清理。而当时的作者已经近2年没再处理相关的pull request，所以我提交到了另外一个库中。</p>

<p>上个月发现作者又回来了，接受处理了一系列的pull request并且还增加了一些新的配置。于是做了一下更新。</p>

<p>原本提过需要3个包：</p>

<ol>
<li><del>tomcat-redis-session-manager-1.2-tomcat-7.jar</del></li>
<li><del>jedis-2.0.0.jar</del></li>
<li><del>commons-pool-1.3.jar</del></li>
</ol>


<p>这次作者终于在readme中也加以了描述，并且更新了版本：</p>

<ol>
<li>tomcat-redis-session-manager-VERSION.jar</li>
<li>jedis-2.5.2.jar</li>
<li>commons-pool2-2.2.jar</li>
</ol>


<p>在context.xml中的配法也做了一些调整，主要是类名发生了变化，
```xml
<Valve className="com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve" />
&lt;Manager className="com.orangefunction.tomcat.redissessions.RedisSessionManager"</p>

<pre><code>     host="localhost" &lt;!-- optional: defaults to "localhost" --&gt;
     port="6379" &lt;!-- optional: defaults to "6379" --&gt;
     database="0" &lt;!-- optional: defaults to "0" --&gt;
     maxInactiveInterval="60" &lt;!-- optional: defaults to "60" (in seconds) --&gt;
     sessionPersistPolicy="ALWAYS" &lt;!-- optional: defaults to "DEFAULT" --&gt; /&gt;
     sessionPersistPolicies="PERSIST_POLICY_1,PERSIST_POLICY_2,.." &lt;!-- optional --&gt;
     sentinelMaster="SentinelMasterName" &lt;!-- optional --&gt;
     sentinels="sentinel-host-1:port,sentinel-host-2:port,.." &lt;!-- optional --&gt;
    connectionPoolMaxIdle="20"
     connectionPoolMaxTotal="500" 
</code></pre>

<p> /></p>

<p>```</p>

<p>另外就是增加了sessionPersistPolicies，建议选择<code>SAVE_ON_CHANGE</code>，如果选择<code>ALWAYS_SAVE_AFTER_REQUEST</code>，更容易诱发写竞争。而且有些场合，如果在request结束之后再写入，
中间的状态可能时间会拖得太长。如果真的对竞争情况很敏感的场合，就需要自己手动设置锁。</p>

<h3>github上把原作者的提交合并到自己的库中</h3>

<p>同把自己的修改贡献给对方类似，只不过这种pull request需要换成base是自己的库，而head则是原作者库，然后新建pull request，github就会列出发生过的变化。
这时候又会产生两种结局，其一是github可以自动合并，则再点击按钮即可，另一种是自动合并失败，会提示在本机先建分支，再pull原作者的分支，冲突解决（修改完毕）后合并回自己的主分支，
然后再push到github。push成功后，github会自动关闭这个pull request。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx 处理Spring 静态资源的配置]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/10/14/nginx-chu-li-spring-jing-tai-zi-yuan-de-pei-zhi/"/>
    <updated>2014-10-14T13:19:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/10/14/nginx-chu-li-spring-jing-tai-zi-yuan-de-pei-zhi</id>
    <content type="html"><![CDATA[<p>用Nginx处理静态资源是挺常见的一个事情，自从使用了Spring，也经常直接利用Spring的处理静态文件的功能，也能打上Etag。避免流量传输。
但是近来发现，Spring处理静态资源后，对静态文件获取的请求浏览器还是会发起，只是每次都是返回304。所以想继续借助Nginx给Spring的静态资源打上expire的标记。</p>

<p>需求也算简单：</p>

<ol>
<li>基于app toolbar的动态请求转发给java</li>
<li>gif,png，js等nginx直接处理，并加expire 3h；</li>
<li>部分.js请求如t.js还是转给java，有效期为0；</li>
<li>敏感文件不会被nginx处理，如web.xml无法被nginx转走</li>
</ol>


<p>因为目前Spring的静态资源单独存放在和WEB-INF并排的目录下，所以利用Nginx配置就大为简单了，只要限制路径名称即可。</p>

<p>```</p>

<pre><code>    location /toolbar {
        root   html;
        proxy_pass http://192.168.203.198:8080;
    }
    location ~ /toolbar/static {
        root   html;
        if (-f $request_filename) {
            expires 1d;
            break;
        }
    }
    location = /toolbar/enter/t.js {
        root   html;
        proxy_pass http://192.168.202.72:8080;
    }
</code></pre>

<p>```</p>

<p>然后在nginx的html目录下建立目录<code>toolbar</code>，并在其增加一个符号连接<code>ln -s /home/web/apache-tomcat-7.0.56/webapps/toolbar/static static</code>，就可以实现上述要求了。</p>

<p>这里面用到了几种Nginx的配置。</p>

<ol>
<li><code>location /toolbar</code>，这是最基本的匹配字符串的表达方式，优先级一般情况下也最低，然而<code>^~</code>是一个例外，它的优先级比下面的正则要高。</li>
<li><code>location ~ /toolbar/static</code>，这个是用到了正则表达式的匹配，优先级要高于基础的只比较字符。</li>
<li><code>location = /toolbar/enter/t.js</code>，这是优先级最高的匹配符，要求uri完全相等。</li>
</ol>


<p>如果需要使用正则表达式匹配，则必须使用<code>~</code>或者<code>~*</code>，其中后者和前者的区别是不区分大小写。</p>

<p>整个匹配顺序是：</p>

<ol>
<li>对<code>=</code>进行匹配，有相符的就停止；</li>
<li>对所有的非正则表达式（为使用~ 和 ~*）进行匹配，如果遇到<code>^~</code>则也停止，否则全部比对完毕后，最接近的匹配将被选用作为候选，随后进入3匹配正则表达式；</li>
<li>正则表达式按定义的顺序进行匹配，有匹配的则停止，即可选用刚刚匹配的正则表达式，如没有匹配的正则，则选用2中得到的结果。</li>
</ol>


<p>因此对静态资源的选择，可以加上<code>~</code>，也可以不加。但为了避免今后配置的冲突，还是让静态资源的优先级高一些来的好。</p>

<p>随后，可以使用下面的链接进行测试，看看是否满足需求：</p>

<p>http://192.168.203.198/toolbar/enter/t.js,<br/>
http://192.168.203.198/toolbar/static/images/logo1.png,<br/>
http://192.168.203.198/toolbar/WEB-INF/web.xml</p>

<p>前面两个应该得到返回内容，最后一个应该获得报错。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web容器中通过Spring添加Job任务]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/09/11/webrong-qi-zhong-tong-guo-springtian-jia-jobren-wu/"/>
    <updated>2014-09-11T21:59:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/09/11/webrong-qi-zhong-tong-guo-springtian-jia-jobren-wu</id>
    <content type="html"><![CDATA[<p>实际投入使用的Web站点总有很多例行任务要做，习惯的做法是利用操作系统的crontab定期执行脚本或者Java程序。
在更早的时候，曾经试过quartz，但后来因为quartz创建的线程属于JVM而不是Web容器，导致停止或
重新部署应用时线程并未终止，因此后来跑java程序例行任务的话，主要就
是单独运行jar文件。</p>

<p>时过境迁，了解到Spring已经接管了定时任务的线程处理，之前在
Web容器里跑多线程任务的最大隐患已经不存在了，所以尝试了一下在
Spring中使用例行更新。</p>

<p>这样做最大的好处当然就是代码集中，容易维护也容易部署。</p>

<h3>功能说明</h3>

<p>整个功能并不复杂，需要对redis中的设备号列表进行遍历，对每一个
号码调用远程接口获取该号码的一些动态变化的信息。取得后，这些信息
的时效时间是6小时，在失效前的10分钟内，需要再次调用远程接口刷新缓存。</p>

<p>因为整个功能的瓶颈在于远程调用，为了提高并发，
调用远程接口采取多线程的方式。而遍历的性能极好，使用单线程就够了。</p>

<h3>使用组件</h3>

<p>采用Java中线程的Executors实现起来最简单直接。Executors实质上就是一个
线程池，每塞给一个号码，就调用派发一个线程进行处理。如果没有线程可派，
则放入队列中，如队列满了则会依据设置再增加线程数量。</p>

<p><code>java
private TaskExecutor taskExecutor
</code></p>

<p>Executor确实是一个比较好的多线程编程方式，融合了Actor模式和队列，
使用起来也比较方便。</p>

<p>Executors可以由spring进行注入，在这个任务里比较合适的是采用ThreadPool*</p>

<p>```xml</p>

<pre><code>&lt;bean id="taskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"&gt;
    &lt;property name="corePoolSize" value="5" /&gt;
    &lt;property name="maxPoolSize" value="10" /&gt;
    &lt;property name="queueCapacity" value="2500" /&gt;
&lt;/bean&gt;
</code></pre>

<p>```
corePoolSize是例行打开的线程数，queueCapacity是在没有core线程处理时的排队数量，
当超过这个数量时，会再启动线程直到maxPoolSize。如果都使用完毕，则可指定溢出时的抛弃处理方式。</p>

<p>派发任务由<code>taskExecutor.execute(new PollItInterfaceTask(mdn))</code>表达，
要同步的数据通过mdn传入。</p>

<p>此外，因为遍历的线程执行速度快，而workers可能需要更长时间才能完成队列中的任务，
为防止重复提交设置了一个多线程会并发访问的集合<code>private Set&lt;String&gt; mdnInQueue = new ConcurrentSkipListSet&lt;String&gt;(); //用于记录已安排执行但还未执行的号码</code>
。整个代码的情况如下:</p>

<p>```java
package com.sanss.toolbar.job;</p>

<p>import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.TimerTask;
import java.util.concurrent.ConcurrentSkipListSet;</p>

<p>import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.junit.Assert;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.task.TaskExecutor;</p>

<p>import com.sanss.toolbar.service.CacheItInterfaceQueryService;</p>

<p>/<em>多线程发起的、向IT抓取用户套餐信息的线程池执行者，由spring中触发，根据接口run()</em>/
public class PollItInterfaceTaskExecutor  implements Runnable {</p>

<pre><code>private static Log logger = LogFactory.getLog(PollItInterfaceTaskExecutor.class);
private Set&lt;String&gt; mdnInQueue = new ConcurrentSkipListSet&lt;String&gt;(); //用于记录已安排执行但还未执行的号码
@Autowired
CacheItInterfaceQueryService cacheItInterfaceQueryService;

/*实际被多线程执行的任务,获取在队列中存放的mdn*/
private class PollItInterfaceTask implements Runnable {
    private String mdn;
    public PollItInterfaceTask(String mdn) {
        this.mdn = mdn;
    }

    public void run() {
        cacheItInterfaceQueryService.setCacheFlux(mdn);
        mdnInQueue.remove(mdn);
        Thread currentThread = Thread.currentThread();  // 获得当前的线程  
        String threadName = currentThread.getName();  
        logger.debug(threadName + ": 刷新下面号码的cache: " + mdn);
    }
}

private TaskExecutor taskExecutor;

public PollItInterfaceTaskExecutor(TaskExecutor taskExecutor) {
    this.taskExecutor = taskExecutor;

}

//任务出发后，被run自动执行的任务。首先获得所有需要提前取得IT流量信息的hashkey集合，随后遍历集合分别取出相关的一系列mdn，
//之后根据mdn检查ttl信息，发现小于500秒就安排Executor执行任务。
public void doit() {
    Set&lt;String&gt; tlbKeys = cacheItInterfaceQueryService.getAllTlbsetQueryList();
    int total = 0; //号码列表总数
    int count = 0; //本轮需要刷新的
    for (String hshkey : tlbKeys) {
        Map&lt;String, String&gt; mdns = cacheItInterfaceQueryService.getAllFieldsByAKey(hshkey);
        for(String mdn : mdns.keySet()) {
            long ttl = cacheItInterfaceQueryService.ttlFlux(mdn);
            if (ttl &lt; 500 ) {
                if (!mdnInQueue.contains(mdn)) {
                    mdnInQueue.add(mdn);
                    taskExecutor.execute(new PollItInterfaceTask(mdn));
                    count++;
               }
            }
            total++;
        }
    }
    logger.info("本轮刷新"+count+"个记录, 共有"+total+"个记录");
}

@Override
public void run() {
    // TODO Auto-generated method stub
 System.out.format("开始执行 %s ...%n", new Date());  
    doit();
}
</code></pre>

<p>}</p>

<p>```</p>

<p>CacheItInterfaceQueryService是项目中的一个服务模块，负责具体设置缓存。</p>

<p>```xml</p>

<!-- 定期去IT接口轮训的部署 -->


<pre><code>&lt;bean id="taskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"&gt;
    &lt;property name="corePoolSize" value="5" /&gt;
    &lt;property name="maxPoolSize" value="10" /&gt;
    &lt;property name="queueCapacity" value="2500" /&gt;
&lt;/bean&gt;

  &lt;bean id="pollItInterfaceTaskExecutor" class="com.sanss.toolbar.job.PollItInterfaceTaskExecutor"&gt;
       &lt;constructor-arg ref="taskExecutor" /&gt;
 &lt;/bean&gt;

&lt;bean id="springScheduleExecutorTask"  
    class="org.springframework.scheduling.concurrent.ScheduledExecutorTask"&gt;  

    &lt;property name="runnable" ref="pollItInterfaceTaskExecutor" /&gt;  

    &lt;property name="delay" value="1000" /&gt;  
    &lt;!-- 每次任务间隔 一分钟--&gt;  
    &lt;property name="period" value="60000" /&gt;  
&lt;/bean&gt;  

 &lt;bean id="springScheduledExecutorFactoryBean"  
    class="org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean"&gt;  
    &lt;property name="scheduledExecutorTasks"&gt;  
        &lt;list&gt;  
            &lt;ref bean="springScheduleExecutorTask" /&gt;  
        &lt;/list&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;  
</code></pre>

<p><code>``
避免不了的配置如上，</code>taskExecutor<code>已经在前面描述过，第二段的</code>pollItInterfaceTaskExecutor<code>就是把线程池执行者
作为参数传给自己编写的任务的构造函数，然后第三段定义一个周期执行的任务，设置好执行的间隔，runnable要提供自己编写的业务类（第二段中的内容），
最后第四步把这个周期任务交给Spring的</code>ScheduledExecutorFactoryBean`工厂来负责管理。
需要注意的是，ScheduledExecutorFactoryBean是spring4中的写法，在spring3中还是另一套描述方式，虽然功能差不多。
但在版本升级时，这是一个不大不小的坑。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[被低估的JS： 「Pro JavaScript Techniques」读后感]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/07/23/pro-javascript-techniques/"/>
    <updated>2014-07-23T16:13:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/07/23/pro-javascript-techniques</id>
    <content type="html"><![CDATA[<p>作为一个Web开发者，无法绕开的一个点就是JavaScript。而对于经过C/Java训练出来的计算机专业人员而言，是很容易轻视JS，从而使得在这方面往往要经过很长的时间和经历，才能体会到
JS的与众不同及其能力。C或者Java同JS的不同已经不用多言，而同为脚本语言的Ruby Php Perl Python 同 JS的差别也是巨大的。有一定编程基础的人，学习其他大众性的语言，比如最常用的10种语言，
一般都是比较快的。但是，JS是如此的和其他语言不一样，以至于学习起来真的费一番功夫。</p>

<p>不过，直到读了John Resig的「Pro JavaScript Techniques」，终于令我豁然开朗。Resig是大名鼎鼎的JQuery的创始人，这本书中很多主要的API可以说就是介绍了JQuery是怎么实现的。包括Id的选择，
ajax方法等。最重要的，如他所说，就是第二章面向对象的JavaScript，或者说如何从其他编程语言来理解JavaScript。</p>

<p>笔记的流水账：</p>

<h1>第一章 现代化的JS</h1>

<p>JS和它的队友：</p>

<ul>
<li>Core Javascript 1.5</li>
<li>XML2（DOM）</li>
<li>XMLHttpRequest</li>
<li>CSS（style）</li>
<li>事件</li>
</ul>


<p>```javascript</p>

<h1>注意通过prototype定义公共函数的模式</h1>

<p>function Lecture(name, teacher) {</p>

<pre><code>this.name = name;
this.teacher = teacher;
</code></pre>

<p>}</p>

<p>// 实例method
Lecture.prototype.display = function() {</p>

<pre><code>return this.teacher  + " is teaching " + this.name;
</code></pre>

<p>}</p>

<p>function Schedule(lectures) {</p>

<pre><code>this.lectures = lectures;
</code></pre>

<p>}</p>

<p>Schedule.prototype.display = function() {</p>

<pre><code>var str = "";
for (var i = 0; i &lt; this.lectures.length; i++) {
     str += this.lectures[i].display;
}       
return str;
</code></pre>

<p>}</p>

<p>var mySchedule = new Schedule([</p>

<pre><code>new Lecture("Gym", "Mr. Smith");
new Lecture("Math", "Mrs. Jones");
new Lecture("English", "TBD");
</code></pre>

<p>]);</p>

<p>alert(mySchedule.display());
```</p>

<h1>第二章 面向对象的JS( javascript的精髓)</h1>

<h3>引用</h3>

<p>引用指向的是具体的对象，引用是一个变量。
JS中的引用不会指向引用，<code>var b = a;</code>的作用永远是让b指向a表示的实际对象</p>

<h3>参数类型检查和函数重载</h3>

<p><code>if (typeof msg == 'undefined') {}</code></p>

<p>以及js对象都有的属性：构造子</p>

<p><code>if (str.constructor == String) {}</code></p>

<p>后者能够找出具体的构造对象的函数，前者对通过函数构造的对象返回的也是'object'。</p>

<p>js在每个函数里面，有一个隐含属性 <code>arguments</code> ，这是一个伪数组，可以遍历、有.length属性，但不能被修改。可以通过复制遍历变成标准数组。</p>

<p>```javascript
function sendMessage(msg, obj) {</p>

<pre><code>if ( arguments.length == 2) 
      ojb.handleMsg(msg);
else
     alert( msg );
</code></pre>

<p>}
```</p>

<h3>作用域(Scope)</h3>

<p>js通过函数来划分作用域，而不是通过代码块</p>

<p>没有var声明的，则变成全局变量</p>

<h3>闭包</h3>

<p>闭包允许内层函数引用外围函数内的变量，即便外层函数已经终止。</p>

<p>```javascript
function delayedAlert( msg, time ) {</p>

<pre><code>setTimeoute( function() {
     alert(msg); // msg就是外围函数中的变量
}, time);
</code></pre>

<p>}
```</p>

<p>curry化： 利用函数生成函数</p>

<p>```javascript
function addGenerator(num) {</p>

<pre><code> return function( toAdd) {
    return num + toAdd;
 };
</code></pre>

<p>}</p>

<p>var addFive = addGenerator(5);
alert(addFive(4)==9);
```</p>

<h3>上下文对象</h3>

<p>通过<code>this</code>表示，永远指向当前代码所处的对象中。
是调用时确定的对象。</p>

<p>function都有call和apply两个方法，可以用于指定this是什么</p>

<p>```javascript
function changeColor( color ) {</p>

<pre><code>this.style.color = color;
</code></pre>

<p>}</p>

<p>changeColor.call(main, "black");</p>

<p>function setBodyColor() {</p>

<pre><code> changeColor.apply(main, arguments); //传入隐含的全部参数
</code></pre>

<p>}
setBodyColor( "black" );
```</p>

<h2>原型式继承</h2>

<p><code>javascript
User.prototype = new Person();
</code>
其效果是每次 new User()时同时执行了new Person，且user对象就这样拥有了person的全部方法</p>

<h2>类似继承</h2>

<p>Douglas Crockford创造的<code>method</code>, <code>inherits</code>, <code>swiss</code> 三个方法。</p>

<p>```javascript
User.inherits(Person);
User.method( 'getName', function(){
  return "My name is: " + this.uber('getName');
});</p>

<p>```</p>

<h2>Base 库</h2>

<h2>Prototype库</h2>

<p>就是rails原先自带的库</p>

<h2>命名空间</h2>

<p><code>$.</code>其实就是命名空间。
```javascript
var YAHOO = {};
YAHOO.util = {};
YAHOO.util.Event = {</p>

<pre><code>addEventListner: function() {}
</code></pre>

<p>};
YAHOO.util.Event.addEventListener(...);
```</p>

<h2>清理代码</h2>

<p><code>!=</code> 和<code>==</code> 会对变量进行求值，即把对象变成false或true后进行比较，
js中， null false 0 undefined 求值后都是false</p>

<p>js一行一行地写可以不用分号，但是一旦被压缩后，换行符号都将取消，此时没有分号就不行了。鉴于js的使用场景，还行建议每行都加上分号。</p>

<p>压缩代码的三种方式:
1. 只取出空白和注释
2. 压缩变量
3. both</p>

<p>IE 是不灵的，在调试方面</p>

<p>Firefox的调试是最好的，尤其搭配firebug和 View Rendered Source，Venkman也是一个ff的扩展</p>

<p>Safari还在迅速变化发展中，Chrome与之类似</p>

<h2>测试套件</h2>

<ul>
<li>JSUnit: 老牌的</li>
<li>J3Unit: 稍新的，通Java集成的更好</li>
<li>Test.Simple , Test.More</li>
</ul>


<h1>第三章 分离式的JavaScript</h1>

<p>DOM(Document Object Model)是表达XML文档的标准，并不是唯一的方式，但确实是应用最广泛的方式。这一点和js能统一浏览器的原因一致，就是因为被广泛使用了。</p>

<p>DOM的模型：
DOM是一个树结构，根节点是html，
下属节点分为元素和文本两种类型。
每个节点包括5个指针:
1. 父节点parentNode
2. 兄节点(previousSibling)
3. 弟节点(nextSibling)
4. 第一个子节点(firstChild)
5. 最后一个子节点(lastChild）</p>

<p>整个的遍历和渲染其实都是基于DOM模型的。</p>

<h2>DOM的加载</h2>

<ul>
<li>html解析完毕</li>
<li>src中的脚本和css加载完毕</li>
<li>脚本在文档内解析并执行（此时dom并未构造起来）</li>
<li>Html DOM完全构造起来</li>
<li><p>图片和外部内容加载</p></li>
<li><p>等待整个页面的加载，基于window对象的load事件，速度最慢，因为是在图片下载之后</p></li>
</ul>


<p><code>javascript
addEvent(window, "load", function (){
  net( id("everywhere") ).style.background = 'blue';
});
</code></p>

<ol>
<li><p>把script标签放置在页面的最后，这样确保执行的时候dom已建立</p></li>
<li><p>监听DOM的加载状态，实现复杂。
jquery实现的方法，$或者说domReady，其主要原理是检查document是否已存在，document.getElementsByTagName和document.getElementById两个函数是否已存在，以及document.body是否已存在。搭配setInterval不停地检查，检查到位后就清楚timer</p></li>
</ol>


<h2>在HTML中寻找元素</h2>

<p>cssQuery， jQuery
主要是css选择器和xpath选择器</p>

<h2>获取元素的内容</h2>

<ol>
<li>获取文本 text</li>
<li>获取 html</li>
</ol>


<h2>操作元素的属性(attribute)</h2>

<p>一旦元素加载到DOM中，元素会有一个管理数组，</p>

<p><code>javascript
formElem.attributes = {
  name: "myForm",
  action: "/test.cgi",
  method: "POST"
};
</code></p>

<p>实际提供了attr方法</p>

<h2>修改DOM</h2>

<ol>
<li><p>创建节点
createElement</p></li>
<li><p>插入到DOM中<br/>
insertBefore： 在子元素前插入
<code>parentOfNode.insertBefore(nodeToInsert, beforeNode)
appendChild: 插入一个父节点中最后一个子节点，</code>parenElem.appendChild(nodeToInsert);`</p></li>
</ol>


<h2>异步与事件处理</h2>

<h3>异步事件与线程</h3>

<h3>事件阶段</h3>

<p>捕获和冒泡，捕获是由外向内，冒泡是由内向外</p>

<p>是否能停止冒泡？</p>

<p>通过对按键事件的处理，停止textarea的正常响应
```html
<html>
<head></p>

<p></head></p>

<p><body></p>

<p><textarea rows="4" cols="50">
At w3schools.com you will learn how to</p>

<p>make a website. We offer free tutorials</p>

<p>in all web development technologies.
</textarea></p>

<script>
document.getElementsByTagName

("textarea")[0].onkeypress = function(e) 

{ 
e = e || window.event;
return true;

};
</script>


<p></body>
```</p>

<p>上面的e是事件对象</p>

<p><code>this</code>作为一种指代，可以泛化成各类元素，使得js的编写变得简单</p>

<p>```javascript
var li = document.getElemensByTagName("li");
for (var i = 0; i &lt; li.length; i++) {
  li[i].onclick = handleClik;
}</p>

<p>function handleClick() {
   this.style.backgroundColor = "blue";
   this.style.color = "white";
}
```</p>

<h3>取消冒泡（重载浏览器的事件处理）</h3>

<p>```javascript
function stopBubble(e) {
  //如果传入了事件对象，那么就是非IE浏览器
  if ( e &amp;&amp; e.stopPropagation ）</p>

<pre><code> e.stopPropagation();
</code></pre>

<p>  else // 否则使用IE的方式来取消事件冒泡</p>

<pre><code> window.event.cancelBubble = true;
</code></pre>

<p>}</p>

<p>```</p>

<h3>取消浏览器的默认行为（重载）</h3>

<p>```javascript
function stopDefault(e) {
  if (e &amp;&amp; e.preventDefault)</p>

<pre><code>e.preventDefault();
</code></pre>

<p>  else //windows 特供</p>

<pre><code>window.event.returnValue = false;
</code></pre>

<p>  return false;
}</p>

<p>li.onclick = function(e) {</p>

<pre><code>iframe.src = this.href
return stopDefault(e);
</code></pre>

<p>}
```</p>

<h2>绑定事件的3中方法</h2>

<ol>
<li>传统方法</li>
</ol>


<p><code>javascript
windo.onload = function() {};
</code></p>

<p>好处在于简单稳定，处理事件时可以使用this关键字；
坏处是事件只在冒泡时运行，捕获时不运行。且一个元素一次只能绑定一个处理函数，即onload=func2会替换前面已经注册过的函数。同时ie中，还不能得到事件对象e。</p>

<ol>
<li>W3C</li>
</ol>


<p>```javascript
window.addEventListener('load', function(){}, false);</p>

<p>```
相对于第一种，好处是第三个参数指明了哪个阶段处理事件：false（冒泡）或true(捕获)；事件对象可以通过处理函数的第一个参数获取；不会覆盖之前已绑定的事件。缺点就是老的ie不支持。</p>

<ol>
<li>IE绑定</li>
</ol>


<p><code>javascript
window.attachEvent('onload', function(){});
</code></p>

<p>粗看起来和w3c的类似，但细节有很多不同：
* 仅支持冒泡阶段
* this关键字指向了window对象
* 事件对象存在于window.event中
* 事件必须以ontype的形式命名，如onload而非load</p>

<ol>
<li>facade的addEvent和removeEvent</li>
</ol>


<p>```javascript
addEvent( window, "load", function() {</p>

<p>});
```</p>

<p>唯一的缺点是仅能工作在冒泡阶段</p>

<h2>事件类型</h2>

<ul>
<li>鼠标</li>
<li>键盘</li>
<li>UI，focus，blur</li>
<li>表单事件</li>
<li>加载和错误</li>
</ul>


<h2>分离式的javascript</h2>

<p>就是不在html里绑定怎么处理js，是的href可以是有意义的，使得js禁用时系统依然可以使用</p>

<h2>访问CSS属性</h2>

<h2>位置 尺寸和可见性</h2>

<h3>位置</h3>

<p>4种定位</p>

<p>position: static; //top和left不起作用，顺序排版
position: relative; //top和left相对于static进行偏移
position: absolute; //相对于它的第一个非静态定位的祖先元素而展示，如没有这样的祖先元素，就是相对于整个文档
position: fixed; //相对于浏览器窗口
top: 0px;
left: 0px;
right: ;
bottom: ;</p>

<h3>元素的可见性</h3>

<ul>
<li>visibility: hidden, visible</li>
<li>diplay: none, block, inline, ''</li>
<li>opacity:

<ul>
<li>filter: 'alpah(opacity='50)</li>
<li>opacity: 50/100</li>
</ul>
</li>
</ul>


<h2>动画效果</h2>

<p>1秒执行20帧动画</p>

<p>```javascript
for ( var i = 0; i &lt;= 100; i += 5 ） {</p>

<pre><code> (function(){
     var pos = i;
     setTimeout(function(){

        elem.style.height = (pos/100)*h + "px";
     }, (pos+1)*10);

 })();
</code></pre>

<p>}</p>

<p>```</p>

<h2>viewport是视口，就是浏览器滚动条内的一切东西</h2>

<p><code>window.scrollTo(0, 0)</code>可以移动浏览器窗口位置</p>

<h2>拖放功能</h2>

<p>使用拖放库可以</p>

<p>P145的悬停真是写的漂亮</p>

<h1>第四章 Ajax</h1>

<p>这部分其实主要就是举例ajax的例子，来做了综合的应用。</p>

<p>responseXML和responseText是xhttprequest的主要返回对象
其中，xml是响应头的content-type为xml时有效</p>

<p>一个$.ajax的实现，代码真精妙</p>

<p>返回响应的种类：</p>

<ul>
<li>xml</li>
<li>json</li>
<li>html ，可以直接注入html</li>
<li>script</li>
</ul>


<p>pageHeight(判断整个页面又多高)，scrollY(获知当前视口的顶部滚动到了哪里)，
windowHeight(获知视口有多高)</p>

<p>四步法：</p>

<ol>
<li>DOM操作</li>
<li>获取数据</li>
<li>事件监测</li>
<li>发起ajax请求</li>
</ol>

]]></content>
  </entry>
  
</feed>
