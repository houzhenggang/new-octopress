<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: 技术 | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/技术/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2015-11-14T23:06:49+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring的@SessionAttributes和@ModelAttribute在Redirect时的特殊表现]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/11/14/springde-at-sessionattributeshe-at-modelattribute/"/>
    <updated>2015-11-14T22:50:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/11/14/springde-at-sessionattributeshe-at-modelattribute</id>
    <content type="html"><![CDATA[<p><code>@ModelAttribute</code> 在Spring中有两个地方可以填写：</p>

<ol>
<li>Controller的Action method的参数前标注，提示需要设置该值</li>
<li>Controller中单独的方法前标注，改方法通常不是action，但加注<code>@ModelAttribute</code>后会在Action method执行前被调用</li>
</ol>


<p>使用效果来讲就是确保第一种情况下，action method的参数会被设置，而设置的根据主要是以下4种：</p>

<ol>
<li>来自<code>@SessionAttributes</code>使用中被设置在session中的<code>ModelAttribute</code></li>
<li>上面提到的第二个使用的方法中产生的对象</li>
<li>基于URI的模板变量+type converter</li>
<li>直接new的，即默认的构建方法</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安卓开发初体验]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/10/18/an-zhuo-kai-fa-chu-ti-yan/"/>
    <updated>2015-10-18T17:08:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/10/18/an-zhuo-kai-fa-chu-ti-yan</id>
    <content type="html"><![CDATA[<p>鉴于项目形势所迫，对一个安卓的demo只能自己直接来了。
也算半逼之下入门了安卓开发。以下面这张图来论，</p>

<p><img src="../images/androidmap.jpg" alt="安卓学习路线图" /></p>

<p>基础部分基本上java web开发工程师都是具备的，入门部分大致跟着google的开发
文档做完第一个例子也就都接触到了。
高级主题里面倒是碰了百度地图和Webview这两个必须接触的东西。</p>

<p>就入门而言，学习资料很丰富，尤其是安卓的开发文档还是很全面的，比大部分开源软件的
教程要强许多，毕竟是有正经的商业公司全面支持的。</p>

<p>就编程而言，全部基于Java的，不像Web开发要再切换到Javascript，整个体系的一致性
更好，编写起来还是轻松愉快的。而传递参数方面，摆脱了必须从客户端到服务端，如果是在
界面中跳转其实要比Web方便。这其实也是一个进程间、线程间通信的事情，而作为App，
其通信的方式还是很丰富的。从最基础的Intent，到手机上各应用系统的彼此调用，
以及Json传递会服务端等，可以玩的花样很多。</p>

<p>对于任何写过界面的Java程序员，上手安卓应用开发应该还都是挺轻松的。
毕竟大部分需要的技能有重合，而体系上安卓也更适合学习。当然，学安卓也有特定的痛苦，
比如屏幕尺寸及比例、API升级快导致节奏混乱。不过在手机端确实是个值得投入的东西。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于OAuth的API Token生成]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/07/22/ji-yu-oauthde-api-tokensheng-cheng/"/>
    <updated>2015-07-22T16:00:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/07/22/ji-yu-oauthde-api-tokensheng-cheng</id>
    <content type="html"><![CDATA[<p>基本思路是对方要先注册一下，<strong>注册的时候提供回调地址</strong>，服务平台生成一个<strong>id</strong>给该用户。</p>

<p>然后，用户用这个id来访问平台公开的认证链接，平台生成<strong>code</strong>并通过注册时提供的<strong>回调地址</strong>发送给对方。</p>

<p>对方最后根据code到<strong>token</strong>获取地址拿到实际的token内容：</p>

<p><code>
{
  "access_token":"01234567-89ab-cdef-0123-456789abcdef",
  "expires_in":28799,
  "refresh_token":"01234567-89ab-cdef-0123-456789abcdef",
  "token_type":"Bearer",
  "user_id":"01234567-89ab-cdef-0123-456789abcdef",
  "session_nonce":"2bf3ec81701ec291"
}
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HttpSession在Spring中的配法和问题]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/05/19/httpsessionzai-springzhong-de-pei-fa-he-wen-ti/"/>
    <updated>2015-05-19T17:22:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/05/19/httpsessionzai-springzhong-de-pei-fa-he-wen-ti</id>
    <content type="html"><![CDATA[<p>最早出于使用struts2的习惯，在Spring中如果需要使用<code>HttpSession</code>，做法是把这个对象作为整个类的一个实例对象。</p>

<p>1</p>

<p>```java
public class TestController {</p>

<p>  private static final Log logger = LogFactory.getLog(TestController.class);</p>

<p>  @Autowired
  HttpSession session;</p>

<p>  ...
}
```</p>

<p>后来因为担心Controller在Spring中是单例的（在struts2中是多例的），怕引出线程安全问题，于是把<code>session</code>放入了method中进行注入。</p>

<p>2</p>

<p>```java
@ResponseBody
  @RequestMapping(method = RequestMethod.GET,  produces = MediaTypes.TEXT_HTML_UTF_8)
  public String testSession(HttpServletRequest request, HttpServletResponse response, Model model, HttpSession session) {</p>

<pre><code>int hashCode = session.hashCode();

int i = 0  ;
if (session.getAttribute("val")!=null) {
  i = (int)session.getAttribute("val");
  i++;
} 

session.setAttribute("val", i%3);

logger.info("hashCode: " + hashCode);

return ""+hashCode + ": " + i;
</code></pre>

<p>  }
```</p>

<p>近日在学习Spring in Action的过程中，发现其实第一种方式下使用了<code>proxy 模式</code>, 实际被注入的类是<code>session  $Proxy38</code>这样的代理类，
类似于避免反复调用<code>createEntityManager</code>的做法，该代理类会寻找实际对应的session并进行操作,只是给controller注入了一个壳。</p>

<p>而第2种方法中，注入的则是标准的容器session: <code>org.apache.catalina.session.StandardSessionFacade</code></p>

<p>3</p>

<p>此外，受到推崇的是第三种写法，</p>

<p><code>java
@Component
@Scope(proxyMode=ScopedProxyMode.TARGET_CLASS, value="session")
public class ShoppingCart implements Serializable{
}
</code></p>

<p>这种写法将整个购物车变成一个scope属于session的bean，由spring注入并负责保存。</p>

<p>但这种写法我个人感觉有点过于抛离了web开发。尽管Spring的一大好处是取消对容器的依赖，从而做到测试的方便。但完全和Web容器隔离，变得不像Web开发也不是什么好的策略。
毕竟Session的概念几乎每个Web开发者都有，而scope=session则反而会增加沟通的难度。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQLMAP手记]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/03/06/sqlmapshou-ji/"/>
    <updated>2015-03-06T16:37:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/03/06/sqlmapshou-ji</id>
    <content type="html"><![CDATA[<p><a href="http://sqlmap.org/">SQLMAP</a>确实是一个神器，而<a href="http://www.binarytides.com/sqlmap-hacking-tutorial/">这篇文章</a>则从判断是什么库开始，
历经获取dbs，获取单个db中的tables，获取单个table里面的字段，直至获取每个记录每个字段的数据，做了一步一步细致的讲解。</p>

<p>其实SQLMAP的用法真的挺暴力的。基本通过穷举的办法，根据页面返回内容的变与不变来判断输入的条件是否成立，以此来断定某些信息是否存在。
很脏很暴力的做法。</p>
]]></content>
  </entry>
  
</feed>
