<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: 技术 | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/技术/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2014-03-02T10:13:03+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[锥轮、液压传动和CVT]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/02/15/zhui-lun-ye-ya-chuan-dong-he-cvt/"/>
    <updated>2014-02-15T11:21:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/02/15/zhui-lun-ye-ya-chuan-dong-he-cvt</id>
    <content type="html"><![CDATA[<h3>锥轮</h3>

<p>锥轮其实就是两个圆锥形的转筒，细细的皮带（钢带）每时刻的转动都类似在做圆周运动，但累计的变化多了，圆形就逐步缩小了。所以这种东西的长处在于可以动态地改变转圈的比例。皮带在哪个部位滚动，则是通过液压圆盘的前后移动来实现，类似于抽取出来。</p>

<p>CVT变速箱就是用了两个锥轮，两个锥轮一个是主动轮，接发动机的输出；另一个是接轮胎传动一头的，由主动轮带动，称为从动轮。主动轮和从动轮的液压盘向一个方向运动，从而使得皮带的长度不会被牵拉或缩短。而锥头到锥底之间的各种圆，就提供了连续的转圈比例。相对AT是跳跃式的，CVT就这样实现连续了。</p>

<p>这个截图很好的说明了他们之间的关系。</p>

<h3>液压传动</h3>

<p>液压传动则是很多AT包括CVT使用的技术。其特点是化手动的硬结合为软结合。通过液体的流动实现涡轮和导轮之间的动力传递。从而可以实现从静止到低速的平稳起步，因为这本身就是一个软的过程，不像手动的离合器就是直接接上了。在加速过程中，也可以相对平稳地增加输出。</p>

<h3>行星齿轮和AT</h3>

<p>其实对于AT来讲，核心的东西是行星齿轮，这个东西确实挺酷的，但也是第一次了解有这种神器存在。行星齿轮有点用多项式来模拟锥轮这种连续曲线的转速比的意思，4AT模拟4个点，6AT 8AT一路可以模拟的更多，再多一些就也能实现基本连续的变速了。连续的好处是动力损失小，而AT本身的优势是档位切换快速、技术也成熟。相对而言，锥轮最大的问题就是皮带打滑，不如4AT这样那么成熟了。</p>

<p>AT的技术较CVT成熟，6AT以上的效率损失就不高了。但是，档位越多的AT体积越大、重量也越重、制造成本也高，所以比起8AT，CVT反而是廉价的技术了。另外就是CVT无法适应大功率的发动机。所以3.0以上排量的用的就比较少了。大排量上还用CVT的主要就是日产公司了，CVT也可以说是日产的一张王牌。不过日产现在高级的CVT变速箱里面，也加了行星齿轮，严格的说是行星齿轮和锥轮结合的产物。大众奥迪在A4和A6上使用CVT也挺常见，但高功率版本的就是双离合和手自一体的天下了。</p>

<h3>变速箱的意义</h3>

<p>说一千道一万，变速箱提供了转速比的灵活，使得油耗、传动能适应多种情况。现实中，起步、低速、高速、倒车时确实需要不同的发动机工作效率和传动比例。如果是定一个转速比的话，额外的开销就有点大了。</p>

<p>从作用上来说，汽车的变速箱就是高级自行车上的飞。其实一般的平车都是不带飞的，链条链接的圈圈的尺寸是固定的。这一来是自行车这么开开也确实够了，而且自行车本身就不需要支持倒档。高档的比赛自行车为了获取最佳的性能，也才增加了变速系统。但汽车的质量和时速都和自行车差别太大，所以变速系统基本是标配的了。</p>

<h3>为什么超车需要降档</h3>

<p>主观感觉上，要提速应该放在高档。但实际上因为高档的传动比是低的，输出到轮胎上的力矩并不大。而加速主要需要增加加速度，即需要输出更高的力矩。而高速降档后，发动机的转速会迅速提高，比如从1500转提高到3000转，此时输出的力矩增加。而一般情况下要求的降档降速是为了让发动机慢下来。但如果此时反而加大油门，则发动机转速会进一步上升，输出力矩会进一步加大，也就可以获得更高的输出力矩从而获得加速度。</p>

<p>所以，降档有利于增加加速度，缺点是油耗会比高档位提速来的高。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下的虚拟化技术]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/08/17/linuxxia-de-xu-ni-hua-ji-zhu/"/>
    <updated>2013-08-17T20:59:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/08/17/linuxxia-de-xu-ni-hua-ji-zhu</id>
    <content type="html"><![CDATA[<p>因为要在一台Linux系统中虚拟化一个系统，于是这周接触了一下Linux下虚拟机的内容。<br/>
公司以前一直用的redhat的linux，我所知的虚拟技术仅限于xen和kvm，而且根据一些反馈用的并不是很好。主要体现在资源占用过大，硬盘和内存的消耗都很大，当然公司的服务器硬件配置也有点不够平衡。</p>

<p>然而，在接触了ubuntu的虚拟化后，一下子有茅塞顿开的感觉。首先，windows下我常用的virtualbox就可以在ubuntu下使用。xen和kvm当然ubuntu也是支持的。同时这几种虚拟化技术都可以按命令行的方式使用。其次，ubuntu在安装虚拟化套件方面是十分方便的。主要原因在于它的包要比redhat的时新的多。还有一点，ubuntu比起redhat还是很小巧的。这点在虚拟化的时候显得比较重要。毕竟一台主机的时候，只会安装一个os，如果大2GB那也就只是2GB。一旦云化后，一台主机往往就要4+1个操作系统，在磁盘不富裕的情况下，os的臃肿会成比例的放大。这时候小巧的os就显示出了优势。<br/>
所以我倾向于采用ubuntu server作为云化的主力os。至少应该是虚机的主体。</p>

<p>接下来就是选择何种东西虚拟化了。主要下面3种：</p>

<ul>
<li>xen: 国内用的最多，因为历史最长，也有商业化的支持</li>
<li>kvm：半虚拟化技术，做在kernel里面，redhat和ubuntu大力支持</li>
<li>virtualbox: 是的，其实这可能是最好用的linux虚机软件</li>
</ul>


<p>性能方面，根据<a href="http://www.liangsuilong.info/?p=675">kvm vs Virtualbox</a> 和 <a href="http://server.zol.com.cn/257/2575328.html">Ubuntu11.10 Xen Kvm Virtualbox比拼</a>，总体而言kvm的性能最佳，大文件比virtualbox有所不如。而且从未来规划来看，redhat和ubuntu普遍倾向于支持kvm。但是，virtualbox有两大优势：1.使用是图形化的界面，很简单； 2.与kvm和xen都专注于cpu性能不同，virtualbox的图形化性能要比另外两个都强许多。不过vbox实际上是基于qemu改进的，kvm-qemu也是一个组合。所以，普通用用的情况下可以直接上virtualbox。</p>

<p>顺手又了解了一些vnc的内容。vnc其实只是一个传送图形界面的协议，经典的client和server端模型，但具体的GUI还需要由其他东西实现。可选的有<code>xfce4</code>和<code>ubuntu-desktop</code>，前者小巧不少大约200MB，后者如果是server上安装则要1GB以上了。总体而言不如ssh方便，占用资源也多不少，不过在必须使用图形化界面的时候，都还是不错的选择。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure is really pesky]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/07/09/clojure-is-really-pesky/"/>
    <updated>2013-07-09T22:07:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/07/09/clojure-is-really-pesky</id>
    <content type="html"><![CDATA[<p>最早知道clojure，是在Heroku宣布<a href="https://blog.heroku.com/archives/2011/7/5/clojure_on_heroku">支持</a><a href="http://devcenter.heroku.com/articles/clojure">它</a>，这是Heroku支持的第三种语言。知道彼时这个东西挺火。应该和闭包什么的有关联。</p>

<p>这次看七周七语言，终于得以一睹真容。知道了clojure其实就是Lisp的一个JVM实现。
不过今天试用了一下clojure，感觉这个东西不太灵。
基于JVM的设计思路听上去不错，但仔细想想JVM的lib真有那么大的意义吗？答案是否定的。我不太相信用惯了其他语言的人会喜欢在新语言中继续调用java的内容。在ruby中，我不会有兴趣去调用java。一旦用惯了clojure也不太可能再接受调用java的api。对比起来，scala倒是和java结合的挺紧密。</p>

<p>变成jvm的一部分，一大恶果就是启动变慢，从而作为脚本功能来跑很不美。毕竟一个jvm启动的时间很长，内存消耗也很大，对于处理任务极其简单的情况下，jvm启动的时间和内存开销显然过大了。
其次，融入jvm中，意味着需要ide的配合。无论哪种ide，都是很重的，因此很是麻烦。
叠加起来，就是导致这种基于jvm模式的开发是不令人愉快的。</p>

<p>而Lisp程序员似乎都喜欢用emacs，emacs和ide兼容，呵呵，这是在开什么玩笑。注定这东西的推广在开发层面会存在很大的障碍。</p>

<p>当然，天下英雄用java做clojure scala甚至jruby也不是没原因的。Jvm的性能确实很好，底层的库也很齐全，安装clojure也比较方便，但clojure又引入了leinxxx。不过Java的开发效率毕竟比C高，基于java开发新的语言大概也容易一些。另外就是需要连接数据库等组件都是现成的。这就使得在java上涌现出了很多二次开发的语言。可能，这才是那么多Java实现的根本原因。</p>

<p>但是，个人不太看好就因为用java实现，这些新语言就会被java开发的主流程接纳。道理很简单，混在jvm里面只是有利于复用已有jvm的机器（这点其实也不太重要），好歹部署还算方便，然而对开发而言完全是另学一套，而同时加上的枷锁和限制却更多了。</p>

<p>真的要给java注入活力，最直接了当的办法是让java中调用ruby clojure等，而且是要方便地调用。   伟大语言才会诞生伟大的框架和lib，而现在这种只解决新语言中调用java lib，其实是不利于java王者归来的。只是这条路这些年已经无人深入了。</p>

<p>除了和JVM跳舞令人哭笑不得外，Clojure自身的语法也很难让人爱。基本就是Lisp那套，写啥都已左右括号为主，这样的感觉其实是不太棒的。特别好这口的人除外。这个不是通过教育就能改变的。</p>

<p>所以看了一圈clojure的内容后，觉得这个语言目前还是浅尝辄止为好。</p>

<p>最后，需要提一下的是，这个语言的性能也比较普通。比普通脚本语言快，但比JS V8慢。相较于Scala Haskell，Clojure还是弱了一些。 <br/>
<img src="/images/screen_print/programming_performance.jpg" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prolog]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/06/16/prolog/"/>
    <updated>2013-06-16T22:46:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/06/16/prolog</id>
    <content type="html"><![CDATA[<p>七周七语言看完了Ruby，又继续看了Io，这是一个prototype的语言，确实和js很像，也挺有启发。不过决定还是
好好去学javascript吧。其实<a href="http://www.w3school.com.cn/js/index.asp">w3school</a>的这份js教程很棒，
相当言简意赅。入门是最重要的。入门之后才能走的更远。很多时候究竟有多远看的还是基础，但没有摸起来，那
基本功就无从发挥了。</p>

<p>随后看了<a href="http://www.gprolog.org">Prolog</a>，其实是<strong>gprolog</strong>。
这个语言跟我过去学习的语言都很不一样。完全抛弃了过程语言所拥有的能力，全部都集中在了逻辑判断上。实际上其组成结构是这样的：</p>

<ul>
<li>事实。就是自己先设定一些前提，指定一些事实，比如<code>likes(wallace, cheese).</code></li>
<li>规则。规则就是关于一些事实的推论。比如<code>friend(X, Y) :- \+(X = Y), likes(X, Z), likes(Y, Z).</code>，这个规则由3个条件构成，

<ul>
<li>第一个是X！=Y</li>
<li>第二个和第三个是X和Y都喜欢Z，然后他们就符合friend这条规则</li>
</ul>
</li>
<li>查询。查询就是使用时给出问题，然后让prolog根据规则库（<strong>事实</strong>+<strong>规则</strong>）循环访问得出结果或判断出结果。</li>
</ul>


<p>本质上，应该是用过程语言写了一系列的判断和分析语句（<strong>引擎</strong>）,这样使用时使得编码行为就完全不一样了。</p>

<h3>最大的启发</h3>

<p>最大的启发在于，这一门应该算是我首次学的不是过程式的编程语言。当然，前提是HTML和CSS不能算编程语言。其他的，如C、C++、Java、Ruby、Python、Javascript乃至shell等，虽然有的是纯过程式的，有的是面向对象的，但实际上都<strong>包含了过程式</strong> 的风格。</p>

<h3>试用体验</h3>

<p>还是有点别扭的。它的语法确实很古老，而且很不顺手，这点和<code>erlang</code>有的一拼。
不过确实是只要树立规则，就能输出结果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sass and Compass]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/03/16/sass-and-compass/"/>
    <updated>2013-03-16T21:29:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/03/16/sass-and-compass</id>
    <content type="html"><![CDATA[<p>Sass 和　Compass闻名已久，也接触过一些，不过始终没有仔细学过。这次因为要做移动互联页面的东西，又开始接触这部分内容。
看了下《Pragmatic Guide to Sass》, 理清了一下脉络。
顺便提一句，这本书是在kindle上看的，出版社和作者提供了epub的版本。  这可以算是第一本在kindle上看完的计算机技术类书籍。虽然效果还可以，
但是看了下原书的pdf版本，发现其版本也深受“小书”，小版面，的影响。这可能是未来计算机书籍的一个趋势吧。不过kindle还是最适合纯文字，
用来阅读计算机技术书籍的体验还是很一般。</p>

<p>Sass是最基础的，类似coffeeScript对Css的改写，当然引入的内容要多的多。毕竟js本身也是一种语言，但css很难算的上是一门编程语言。
Sass有自己的运行命令，由ruby实现，可以把scss文件编译成css文件，也能convert回去。</p>

<p>Compass则是sass的库和扩展，在sass的基础上提供了更丰富的样式、函数和变量以及模式。其本身也有了一套命令，也更适合于建项目。Sass如果是java，
那么compass就是J2EE+Eclipse。</p>

<p>如果不想安装那么多东西，那么可以直接使用scout这个GUI工具，工具本身集成了sass和compass的能力，只是又提供了图形化的集成界面。该界面可能是基于
Adobe的桌面技术编写的。如果要推荐美工使用sass，那么可以从scout入手。</p>

<p>compass是很神奇的，而它的spriting堪称神奇中的神奇。</p>

<p>但我发觉设计也是有天赋和术业专攻的。我们的美工完全不用这些东西，也很快就能搞出一个各种android上面看过去还不错的版本，我用这些东西去写出来的还是感觉很累。但至少比没有要好多了。</p>
]]></content>
  </entry>
  
</feed>
