<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: 技术 | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/技术/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2015-03-28T23:07:07+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SQLMAP手记]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/03/06/sqlmapshou-ji/"/>
    <updated>2015-03-06T16:37:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/03/06/sqlmapshou-ji</id>
    <content type="html"><![CDATA[<p><a href="http://sqlmap.org/">SQLMAP</a>确实是一个神器，而<a href="http://www.binarytides.com/sqlmap-hacking-tutorial/">这篇文章</a>则从判断是什么库开始，
历经获取dbs，获取单个db中的tables，获取单个table里面的字段，直至获取每个记录每个字段的数据，做了一步一步细致的讲解。</p>

<p>其实SQLMAP的用法真的挺暴力的。基本通过穷举的办法，根据页面返回内容的变与不变来判断输入的条件是否成立，以此来断定某些信息是否存在。
很脏很暴力的做法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[静态文件的url后缀md5化]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/01/22/jing-tai-wen-jian-de-urlhou-zhui-md5hua/"/>
    <updated>2015-01-22T09:55:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/01/22/jing-tai-wen-jian-de-urlhou-zhui-md5hua</id>
    <content type="html"><![CDATA[<p>长久以来，在jsp中引入css和JavaScript都是手工硬编的:</p>

<p>```jsp
<link href='http://octopresszhangyu.herokuapp.com/toolbar/static/orderFlow/css/reset.css' rel="stylesheet" type="text/css" /></p>

<script src="http://octopresszhangyu.herokuapp.com/toolbar/static/jquery/jquery.min.js" charset="utf-8"></script>


<p>```</p>

<p>好处很明显，最接近实际生成的html，很直观。坏处在于重复性高，而且无法控制后台生成的随机数，这样不太利于nginx等处理静态资源的缓存。终极方案莫过于在后缀上加上md5指纹信息，这样既可以让nginx等通知浏览器长期缓存，而一旦文件发生变化也必然可以让浏览器再次发起请求获得css和JavaScript。最终生成的页面信息达到下面的效果：</p>

<p>```jsp</p>

<script src="http://octopresszhangyu.herokuapp.com/toolbar/static/jquery/toolbar.js?2dc0cb76e7faa4c150fca76981cbcd20" charset="utf-8"></script>


<p>```</p>

<p>实现包含两部分，一方面需要可以计算出静态文件的md5值，另一方面则是可以在jsp中调用并生成上述html。多番比较后，发现jsp中还是使用标签比较合适，所以继续写tag文件：</p>

<p>style.tag
<code>jsp
&lt;%@ tag pageEncoding="UTF-8" import="com.sanss.toolbar.hepler.BaseHelper" %&gt;
&lt;%@ attribute name="file" type="java.lang.String" required="true" %&gt;
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;c:set var="ctx" value="${pageContext.request.contextPath}" /&gt;
&lt;link href='${ctx}&lt;%=BaseHelper.rtg(file) %&gt;' rel="stylesheet" type="text/css" /&gt;
</code></p>

<p>javascript.tag
```jsp
&lt;%@tag pageEncoding="UTF-8" import="com.sanss.toolbar.hepler.BaseHelper"%>
&lt;%@ attribute name="file" type="java.lang.String" required="true"%>
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
&lt;c:set var="ctx" value="${pageContext.request.contextPath}" /></p>

<script src="${ctx}<%=BaseHelper.rtg(file) %>" charset="utf-8"></script>


<p>```</p>

<p>其中使用到了BaseHelper里面的生成md5后缀级链接的方法<code>rtg(filepath)i</code></p>

<p>```java
/<em>* 生成静态文件链接的公共方法，加上md5后缀或者时间戳。
   * @param resource
   * @return
   </em>/
  public static String rtg(String resource) {</p>

<pre><code>String fileMd5 = fileMD5s.get(resource);
if (StringUtils.isEmpty(fileMd5)) {
  System.out.println(System.getProperty("user.dir"));
  fileMd5 = getFileMD5("../webapps/toolbar/static/"+resource);
  if (StringUtils.isEmpty(fileMd5)) {
    fileMd5 = timestamp;
  }
  fileMD5s.put(resource, fileMd5);
}

return "/static/"+resource+"?"+fileMd5;
</code></pre>

<p>  }
```</p>

<p>最不济的情况下，也能给文件加上启动日期的时间戳。</p>

<p>而在布局或者其他需要引入css和js的页面，直接使用这种代码即可:</p>

<p><code>jsp
&lt;tags:style file="styles/css1.css" /&gt;
&lt;tags:javascript file="jquery/jquery.min.js" /&gt;
&lt;tags:javascript file="jquery/tl.js" /&gt;
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Safari不支持第三方cookie引起的session改造]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/01/21/safaribu-zhi-chi-di-san-fang-cookieyin-qi-de-sessiongai-zao/"/>
    <updated>2015-01-21T13:48:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/01/21/safaribu-zhi-chi-di-san-fang-cookieyin-qi-de-sessiongai-zao</id>
    <content type="html"><![CDATA[<p>近日的一个项目中，经常出现部分浏览器的session无法写入的事情。观察一番后，发现这些浏览器大都属于iPhone的Safari浏览器，尤其以iOS7版本居多。
问题本身并不难猜，应该就是cookie无法写入引起的。奇怪的是，部分同版本的Safari又是可以写入session的，所以这个问题很让人困惑。
反复查找，最后明白原因是：首先，对于第三方cookie，Safari升级后确实有禁止写入cookie的特性；其次，但是对于已存在cookie的情况，则尽管是第三方cookie依然还会写入。</p>

<p>就是因为其次这个因素存在，所以之前进行测试的一些手机照样可以写入session了。</p>

<p>问题是找到了，但怎么解决呢？Java中最简单就是让url中带入jsessionid，只是这个方式确实有好多年没有使用过了。虽然是第三方cookie，但因为测试时有过session了，所以还能继续写入。</p>

<p><code>response.encodeURL(url)</code></p>

<p>-- 查文档，这个api的含义是对于如果是可以用cookie追踪sessionid的则不会在url后加入jsessionid，而对于不支持cookie追踪的则会在url中写入id。<br/>
这引发了我的好奇心，只有response怎么能判断cookie是否能追踪呢？</p>

<p>一看Tomcat的源码，实现倒也简单，就是根据当前session的id是否从cookie中获取的来决定的。如果首次访问网站，此时不会有sessionid，则自然不是从cookie追踪的，于是生成的url都有jsessionid。
二次请求上来，如果是cookie中读取的，则不再写入了。如果不是从cookie中读取的，则继续写入jsessionid。也就是说，<strong>不管是不是支持cookie写入，第一笔encodeURL的调用都会加上jessionid</strong>。</p>

<p>例如，第一次访问都会生成这样的链接 <code>http://192.168.202.72:8080/toolbar/home/nav;jsessionid=EFC1A53F48CC5BC9BE58F50830296FBB</code>, 如果再次访问就是<code>http://192.168.202.72:8080/toolbar/home/nav</code>.</p>

<p>这个东西的缺点公开的说法有如下两点：</p>

<ol>
<li>sessionid暴露在url链接中并不安全；</li>
<li>sessionid这样子会保存在地址栏中，容易引发保存后歧义，因为sessionid其实每一次都会是不一样的。</li>
</ol>


<p>简而言之就是这样的链接不好看外加安全性有一定的问题。</p>

<p>不过这个安全性问题如果从网络的角度来看有点勉强。因为http头也是明文传输的，只是浏览器中不显示罢了。以机器的角度来看，jsessionid放在header还是uri中的区别并不大。鉴于业务需要，还是采用吧。于是引发这种写法最大的毛病，需要在jsp中每个自己的链接都加上<code>&lt;%=response.encodeURL(url)%&gt;</code> 。此时不免想起如果都像<code>link_to</code>那样生成链接的话，改起来就方便多了。</p>

<p>Java Web的开发至今没有很方便的helper机制，能用用的还是tags的办法，于是写一个hrefto.tag放到tags下面。</p>

<p>hrefto.tag
```jsp
&lt;%@tag pageEncoding="UTF-8"%>
&lt;%@ attribute name="uri" type="java.lang.String" required="true"%></p>

<p>&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%></p>

<p>&lt;% String ctx = request.getContextPath(); %>
&lt;%= response.encodeURL(ctx + uri) %>
```</p>

<p>在jsp中的应用主要是两句话，第一是引入，第二是调用</p>

<p><code>jsp
&lt;%@ taglib prefix="tags" tagdir="/WEB-INF/tags"%&gt; &lt;!--hrefto.tag存放的位置--&gt;
&lt;a id="help" href='&lt;tags:hrefto uri="/home" /&gt;' target="_blank"&gt;&lt;/a&gt;
</code>
其中<code>&lt;tags:hrefto uri="/home" /&gt;</code>就会调用hrefto.tag中的内容，生成链接。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[笔记本加了SSD]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/01/15/bi-ji-ben-jia-liao-ssd/"/>
    <updated>2015-01-15T23:05:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/01/15/bi-ji-ben-jia-liao-ssd</id>
    <content type="html"><![CDATA[<p>在13年8月拿到工作用的Dell E6430时，就有自己加一块SSD硬盘的想法。只是当时拿到之后发现原装的win7-64bit pro
也不错，使用了几个礼拜后也就不想再重装折腾了。另一个原因则是当时SSD的价格还略高，彼时我一心想的还是256GB的SSD。</p>

<p>半年多以前，给家里的台式机更换了浦科特的256-M6S之后，感觉台式机比几年前新配的时候更<strong>新</strong>了。半年下来，随意用用
256GB也就用了四五十GB，而我的mbp用了大半年也还剩余200GB以上。所以经过实际经历，表明在有机械硬盘的情况下128GB也是
有大量富余的。再考虑到128GB现在的价格已经非常亲民了，于是决定加一个SSD做系统盘并且重装机器。同时也是因为工作用的机器
也一年半了，性能有了较大的下降，也值得重装一下。</p>

<p>在得知建兴有一款性价比很高的128GB SSD之后，毫无犹豫地入了一款。</p>

<p><img src="/images/ssd/1.jpg" alt="建兴ssd" />
<img src="/images/ssd/2.jpg" alt="ssd文字" /></p>

<p>为了让原装的750GB机械硬盘继续发挥作用，加20块买了个光驱位的SATA接口的硬盘支架，两样东西合计399元。</p>

<p><img src="/images/ssd/3.jpg" alt="硬盘支架" /></p>

<p>上面这幅图里面是已经把机械硬盘装进去之后的效果了。</p>

<p>同时再拆下原装光驱的面板和扳手，下面这幅图是二者的对比。
<img src="/images/ssd/4.jpg" alt="光驱和硬盘支架" /></p>

<p>扳手
<img src="/images/ssd/5.jpg" alt="扳手" /></p>

<p>安装过程中唯一有点麻烦的就是SSD插入原本的HDD位置时，由于SSD偏薄，所以要让SSD尽量卡在两个原配的黑色橡皮支架上面一点，这样
才能确保SATA接口衔接上，否则是认不出SSD硬盘的。</p>

<p>硬件安装完成之后，就是OS的安装。OS安装完成之后，因为有了xxxx软件管家，使得装一些常用的应用简单了许多。
而经过一番忙(ze)碌(teng)之后，从启动时间上来讲，由几分钟缩短到了20秒左右；
<img src="/images/ssd/6.jpg" alt="image" /></p>

<p>从Tomcat启动Spring应用来讲，启动时间由30秒减小到了7秒钟；打开各色应用也自然更快了。
效果可谓立竿见影且始终会用到。</p>

<p>跑分的结果
<img src="/images/ssd/7.jpg" alt="image" /></p>

<p>SSD终于到了可以普及的一天了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[独一无二者计数问题（ count-distinct）]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/12/17/du-%5B%3F%5D-wu-er-zhe-ji-shu-wen-ti-%28-count-distinct%29/"/>
    <updated>2014-12-17T16:14:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/12/17/du-[?]-wu-er-zhe-ji-shu-wen-ti-(-count-distinct)</id>
    <content type="html"><![CDATA[<p>最近分析一个大日志文件，9亿条记录近300GB的数据。终于体会到一点大数据处理的意思。</p>

<p>之前根据日志，统计出里面各个域名的pv还算简单。为了开发方便，利用了Redis，开10个java线程，分别扫描不同的行，并把domain做关键字写入redis并不断计数，最后从中读出全部的值并排序。
整个过程主要开销在扫描方面。此时瓶颈出在redis上，基本上5个java线程可以把redis的cpu性能榨干。</p>

<p>9亿条数据分析出来了七十几万个域名，而redis处理70w个key，消耗的内存在100MB以内，所以整个运行跑上几个小时就能得到想要的结果了。</p>

<p>但是，客户进一步提出要分析每个domain下独立访问的用户数量是多少。这下子可就犯难了。
因为按照传统的做法，碰到需要计算独立用户的需求会建立一个集合，然后把标识往里push，最后获取一下这个set的大小，就可以得到独立用户的数量。
然而，如果对70w个域名都分别建立一张访问用户的set，则存储的开销实在太大。这意味着key-value的数量将是70w的几千甚至几万倍。
然后看了一下redis新增加的数据结构类型，发现redis中的hyperloglogs是为此种任务而生的。</p>

<h2>HyperLogLog和count-distinct problem</h2>

<p>建立一个集合并把数据放入，最后计算集合的大小是一种精确的求值方式。而HyperLogLog则是一种会损失一些细节但可以获得很好的近似值的估算方式。</p>

<p>这种算法的核心思想就是MD5+Bitmap。通过某种Hash算法，比如MD5，可以把千变万化的取值收敛成有限的值，而因为这些值也很大，所以可以认为重复的比例会很低。然后，应用Bitmap来表示这些映射结果是否已存在，最后就是计算这个Bitmap中已存在值的数量。尽管损失一些细节，也不是完全精确，但结果是足够准确了。而经过Hash的收敛，再经过Bitmap的收敛，对空间的需求就会变得少了许多许多，也就可以应用于更多关键字的计数。</p>

<p>以我自己对某个域名按两种方式都运行后得到的结果，分别对比如下：</p>

<p>精确的：1687，估计的：1685<br/>
精确的：93869，估计的：94097<br/>
精确的：305084，估计的：305281</p>

<p>而这种方式最大的好处，自然就是对count-distinct这类问题统计起来毫无压力了,同时得到的数据也足够好用了。</p>
]]></content>
  </entry>
  
</feed>
