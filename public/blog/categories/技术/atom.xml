<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: 技术 | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/技术/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2013-07-09T22:36:03+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Clojure is really pesky]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/07/09/clojure-is-really-pesky/"/>
    <updated>2013-07-09T22:07:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/07/09/clojure-is-really-pesky</id>
    <content type="html"><![CDATA[<p>试用了一下clojure，感觉这个东西不太灵。最早知道clojure，是在Heroku宣布<a href="http://devcenter.heroku.com/articles/clojure">支持它</a>，知道彼时这个东西挺火。应该和闭包什么的有关联。</p>

<p>这次看七周七语言，终于得以一睹真容。知道了clojure其实就是Lisp的一个JVM实现。这个设计思路听上去不错，但仔细想想JVM的lib真有那么大的意义吗？答案是否定的。我不太相信用惯了其他语言的人会喜欢在新语言中继续调用java的内容。如果，在ruby中，我不会有兴趣去调用java。一旦用惯了clojure也不太可能再接受调用java的api。对比起来，scala倒是和java结合的挺紧密。</p>

<p>变成jvm的一部分，一大恶果就是启动变慢，从而作为脚本功能来跑很不美。毕竟一个jvm启动的时间很长，内存消耗也很大，对于处理任务极其简单的情况下，jvm启动的时间和内存开销显然过大了。
其次，融入jvm中，意味着需要ide的配合了。无论哪种ide，都是很重的，因此很是麻烦。
叠加起来，就是导致这种基于jvm模式的开发是不令人愉快的。</p>

<p>当然，天下英雄用java做clojure scala甚至jruby也不是没原因的。Jvm的性能确实很好，底层的库也很齐全，java的开发效率毕竟也比C高，所以基于java开发新的语言首先开发是脚容易一些，另外就是需要连接数据库等组件都是现成的。</p>

<p>但是，真的要给java注入活力，最直接了当的办法是让java中调用ruby clojure等方便。伟大语言才会诞生伟大的框架和lib，而现在这种只解决新语言中调用java lib，其实是不利于java王者归来的。只是这条路这家年已经无人深入了。</p>

<p>除了依赖JVM这个不好不坏的一点，Clojure自身的语法也很难让人爱。基本就是Lisp那套，写啥都已左右括号为主，这样的感觉其实是不太棒的。</p>

<p>所以看了一圈clojure的内容后，觉得这个语言现在还是别搀和了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prolog]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/06/16/prolog/"/>
    <updated>2013-06-16T22:46:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/06/16/prolog</id>
    <content type="html"><![CDATA[<p>七周七语言看完了Ruby，又继续看了Io，这是一个prototype的语言，确实和js很像，也挺有启发。不过决定还是
好好去学javascript吧。其实<a href="http://www.w3school.com.cn/js/index.asp">w3school</a>的这份js教程很棒，
相当言简意赅。入门是最重要的。入门之后才能走的更远。很多时候究竟有多远看的还是基础，但没有摸起来，那
基本功就无从发挥了。</p>

<p>随后看了<a href="http://www.gprolog.org">Prolog</a>，其实是<strong>gprolog</strong>。
这个语言跟我过去学习的语言都很不一样。完全抛弃了过程语言所拥有的能力，全部都集中在了逻辑判断上。实际上其组成结构是这样的：</p>

<ul>
<li>事实。就是自己先设定一些前提，指定一些事实，比如<code>likes(wallace, cheese).</code></li>
<li>规则。规则就是关于一些事实的推论。比如<code>friend(X, Y) :- \+(X = Y), likes(X, Z), likes(Y, Z).</code>，这个规则由3个条件构成，

<ul>
<li>第一个是X！=Y</li>
<li>第二个和第三个是X和Y都喜欢Z，然后他们就符合friend这条规则</li>
</ul>
</li>
<li>查询。查询就是使用时给出问题，然后让prolog根据规则库（<strong>事实</strong>+<strong>规则</strong>）循环访问得出结果或判断出结果。</li>
</ul>


<p>本质上，应该是用过程语言写了一系列的判断和分析语句（<strong>引擎</strong>）,这样使用时使得编码行为就完全不一样了。</p>

<h3>最大的启发</h3>

<p>最大的启发在于，这一门应该算是我首次学的不是过程式的编程语言。当然，前提是HTML和CSS不能算编程语言。其他的，如C、C++、Java、Ruby、Python、Javascript乃至shell等，虽然有的是纯过程式的，有的是面向对象的，但实际上都<strong>包含了过程式</strong> 的风格。</p>

<h3>试用体验</h3>

<p>还是有点别扭的。它的语法确实很古老，而且很不顺手，这点和<code>erlang</code>有的一拼。
不过确实是只要树立规则，就能输出结果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sass and Compass]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/03/16/sass-and-compass/"/>
    <updated>2013-03-16T21:29:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/03/16/sass-and-compass</id>
    <content type="html"><![CDATA[<p>Sass 和　Compass闻名已久，也接触过一些，不过始终没有仔细学过。这次因为要做移动互联页面的东西，又开始接触这部分内容。
看了下《Pragmatic Guide to Sass》, 理清了一下脉络。
顺便提一句，这本书是在kindle上看的，出版社和作者提供了epub的版本。  这可以算是第一本在kindle上看完的计算机技术类书籍。虽然效果还可以，
但是看了下原书的pdf版本，发现其版本也深受“小书”，小版面，的影响。这可能是未来计算机书籍的一个趋势吧。不过kindle还是最适合纯文字，
用来阅读计算机技术书籍的体验还是很一般。</p>

<p>Sass是最基础的，类似coffeeScript对Css的改写，当然引入的内容要多的多。毕竟js本身也是一种语言，但css很难算的上是一门编程语言。
Sass有自己的运行命令，由ruby实现，可以把scss文件编译成css文件，也能convert回去。</p>

<p>Compass则是sass的库和扩展，在sass的基础上提供了更丰富的样式、函数和变量以及模式。其本身也有了一套命令，也更适合于建项目。Sass如果是java，
那么compass就是J2EE+Eclipse。</p>

<p>如果不想安装那么多东西，那么可以直接使用scout这个GUI工具，工具本身集成了sass和compass的能力，只是又提供了图形化的集成界面。该界面可能是基于
Adobe的桌面技术编写的。如果要推荐美工使用sass，那么可以从scout入手。</p>

<p>compass是很神奇的，而它的spriting堪称神奇中的神奇。</p>

<p>但我发觉设计也是有天赋和术业专攻的。我们的美工完全不用这些东西，也很快就能搞出一个各种android上面看过去还不错的版本，我用这些东西去写出来的还是感觉很累。但至少比没有要好多了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[patch and diff]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/02/05/patch-and-diff/"/>
    <updated>2013-02-05T10:52:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/02/05/patch-and-diff</id>
    <content type="html"><![CDATA[<p>patch和diff确实是个神奇的东西，用来对现有版本的升级是最好不过了。
好处在于一来不用停业务，二来可以明确到底改了多少东西。</p>

<h3>diff</h3>

<p>首先来说说diff，毕竟patch是从此处产生。</p>

<p>```
diff -ruNa src dest  > a.patch</p>

<p>-r 针对整个目录<br/>
-u 以合并的方式来显示文件内容的不同
-N 新文件做空白文件
-a 包含二进制内容，如jar包，class等
```</p>

<p>据说这个东西是perl的发明者创建的工具，主要用于比较源码，通常不带<code>-a</code>。</p>

<h3>patch</h3>

<p>patch就比较强大了。如果是更改一个目录下面，最常见的做法是进入该目录，然后执行</p>

<p><code>
patch -p1 &lt; ../a.patch
</code></p>

<p>随后，两个目录就会变得一模一样了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Every language will implement a lisp interpreter in itself]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/02/03/every-language-will-implement-a-lisp-interpreter-in-itself/"/>
    <updated>2013-02-03T12:48:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/02/03/every-language-will-implement-a-lisp-interpreter-in-itself</id>
    <content type="html"><![CDATA[<p>H&amp;P里面这句话起初还有点琢磨不过来，后来看了下jstl等东西，这不就是表达式在java中的一个实现么。</p>

<p>从头开始讲的话，需要从web开发讲起。Web中最耗开发时间的是页面的开发，因为在这个环节一切编程的好东西都是没有引入的。比如C的头文件有include检察，
而css依然一团乱；其他语言有的各类引用机制，到了页面全部木有。而在页面上的代码，主要有下面两种模式：</p>

<ul>
<li><code>&lt;% %&gt;</code> <code>&lt;%= %&gt;</code>这样的代码嵌入</li>
<li>代码标签及各类膜拜，如jstl标签，struts2标签，velocity模板等</li>
</ul>


<p>仔细观察，可以发现第二种代码标签和模板其实就是实现了一套语言解析器。往往Java的就用Java实现，有些语言就用自己的实现。
正好印证了Paul的话。为了应付实际的表达困难，表达力弱一些的语言不得不自建一套<strong>类Lisp的语言表达解释器</strong>。</p>

<p>所以，表达力越差（可以理解成
啰嗦、信息量低）的语言，其搭配的解释器可能越五花八门，因为<code>&lt;% %&gt;</code>是很难适应这类语言嵌入在Html中的需求的。而能力强的语言，则模板就要少许多，
因为语言本身的表达力强大，使得再造一套标签显得很没有必要，自然也就无人发明此类模板。</p>

<p>从表达力而言，Java确实较次些。按Paul的理论那就Ruby更接近Lisp。</p>
]]></content>
  </entry>
  
</feed>
