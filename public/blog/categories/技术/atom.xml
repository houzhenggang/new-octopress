<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: 技术 | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/技术/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2014-05-09T15:38:32+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Atom和Node-Webkit]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/05/07/atomhe-node-webkit/"/>
    <updated>2014-05-07T16:21:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/05/07/atomhe-node-webkit</id>
    <content type="html"><![CDATA[<p><a href="http://atom.io">Atom</a>是Github投入开发的一个<strong>新编辑器</strong>。 目前只有Mac版，我在mbp上使用之后感觉还可以。基本可以认为是一个结合了Textmate和Vi插件的产物。
比如，看界面很像Textmate，但又有Textmat始终也没有支持的Ctrl-P插件。初步使用下来唯一不满的就是软件包太大，170MB对于一个文本编辑器而言是很大了。毕竟Eclipse这样的IDE也只在200MB的规模。</p>

<p>在使用体验方面，比较起来，和Textmate更接近些，但扩展应该方便很多。而比起vi的话，主要优势在于是GUI的，支持command+s保存，也支持鼠标选取文本，对中文输入而言明显要比
vi更合适。高亮、快捷等简单用用差别并不大，美观度当然都可以配置的不错。</p>

<p>而在昨天，Atom进一步把他们的核心模块开源了，另外提到了他们是基于<a href="https://github.com/rogerwang/node-webkit/wiki">Node-Webkit</a> 开发的这款工具。</p>

<p>这个组合就让我有点费解了。因为webkit是一个当代浏览器的引擎，safari chrome chromium等都使用了webkit，可以理解webkit就是一个浏览器。而node是指的
Node.js，一个可以在服务器端编写javascript的平台，提供了很多的js库。而这么一个组合，干文本编辑器什么事情？在我开来，文本编辑器应该是很原生的一种应用软件。</p>

<p>仔细阅读了一下Node-Webkit的官方介绍以及一些其他材料，尤其是这篇<a href="http://blog.whattoc.com/2013/12/16/node-webkit01/">你所不知道的Node-webkit</a>
，忽然明白了所谓跑起来的Atom，其实就是运行了一个浏览器。只是这个浏览器里面的输入元素都是用HTML5编写的，而这个浏览器就是chromium，chrome的免安装的一个分支的名称。然后Atom又加了很多事件响应处理的注册代码段在里面。整个编辑类似于在线编辑，只是保存是在本地的。也因此，这个东西要往Linux和Windows迁移是轻而易举的。因为chromium和Node.js本来就是跨平台的。</p>

<p>然而，一旦有那么美好的事情，这个世界上就有银弹了。而历史的经验告诉我们，世上是没有银弹的。</p>

<p>Atom之所以在mbp上使用的体验还不错，主要是因为mbp搭载了大内存、ssd硬盘以及性能走在前列的x86处理器，所以并没有<strong>卡</strong>。而一旦这些条件不具备，情况就不是那么回事情了。这种类似phonegap，用浏览器来模拟原生应用的最大<strong>弱点</strong>无疑是性能差以及开销大。因此会有人提出打开大文件的效果不堪想象。<br/>
从口味上来讲，个人不太喜欢编辑器也Web化。虽然内存cpu的发展依然迅速，Atom的性能问题可能是可以被硬件性能的提升弥补的，但这种做法还是有其先天的缺陷。</p>

<p>所以，如果是脚本的开发，可能还是要继续用vi编写。如果是输入大量中文的话，Atom可以优先考虑。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openssl and fIPC]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/05/06/openssl-and-fipc/"/>
    <updated>2014-05-06T14:27:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/05/06/openssl-and-fipc</id>
    <content type="html"><![CDATA[<p>Openssl还是一个关联很多的基础组件。自从爆出心血漏洞后，给自己的虚机也重新编译了一个新的openssl，
但是在编译ruby 2.1.1时却发现了新的问题。</p>

<p>第一个问题，是编译时老是认不出已经安装的openssl。可能因为openssl是从源码手工安装，而没有使用
apt-get intall，原因在于apt-get是失败的。</p>

<p>为解决这个问题，就在<code>/usr/loca/openssl-1.0.1g</code> 下独立编译生成了一个openssl。然后ruby再编译时可以识别openssl组件了。
但是，编译到一半，会报错</p>

<p><code>
linking shared-object digest/md5.solibcrypto.a(md5_dgst.o): relocation R_X86_64_PC32 against undefined symbol
</code></p>

<p>错误具体是连接报错。建议是要编译时加上 <code>-fIPC</code> 的选项。初看起来有点摸不着头脑，到底是给ruby编译时加上还是给openssl加上呢？</p>

<p>这里就是遇到的第二个问题，连接共享库失败。</p>

<p>于是检查这个选项是什么意思。查下来后，我大致的理解是：</p>

<ol>
<li><code>fIPC</code>使得编译出来的库文件(.a, .so等)地址都是相对地址；</li>
<li>相对地址的好处是适合共享使用，但在装载时不同的进程可能会装载多次这个共享库；</li>
<li>如果没有此选项，则是按绝地地址来编译，好处是内存中只有一份。</li>
</ol>


<p>了解了fIPC是什么东西，上述报错就好理解了，是需要在openssl编译时加上此选项。</p>

<p><code>./config --prefix=/usr/local/openssl-1.0.1g -shared -fPIC</code> 然后<code>make &amp;&amp; make install</code></p>

<p>再在ruby安装包里执行</p>

<p><code>./configure --prefix=/home/user/.rbenv/versions/ruby-2.1.1 --disable-install-doc --with-openssl-dir=/usr/local/openssl-1.0.1g</code> , 然后 <code>make &amp;&amp; make install &amp;&amp; rbenv rehash</code></p>

<p>这样就装好了。</p>

<p>其实，我还有一点疑问，就是如何让openssl静态且又能找到。
估计又是一个属于和ubuntu紧密相关的问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IT系统架构的模式]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/04/12/itxi-tong-jia-gou-de-mo-shi/"/>
    <updated>2014-04-12T16:18:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/04/12/itxi-tong-jia-gou-de-mo-shi</id>
    <content type="html"><![CDATA[<p>近日终于得以拜读了Martin Fowler的大作《The Patterns of Enterprise Application Architecture》。</p>

<p>最早了解这本书是从robbin那里，在距今很多年前的一个Java书单里。彼时他对这本书的评价大意是适合要自己动手开发框架的人看，对应用开发没什么直接的帮助。同时，他认为读下来并没有太多感觉。而回过头来看，读过这本书的中国程序员应该是不少的，但真的从中汲取营养做出东西来的人几乎没有。从这也可以看出中国工程师在动手和创新方面确实有些先天不足。</p>

<p>然而，这本书对于DHH、对于Rails则可以说是一切的开端。对这本书贯彻的最到位、突破的最有力的，非DHH用Ruby开创Rails莫属。本书成书于2002年，彼时企业应用这个称呼比较时髦，按作者的说法，他的本意是IT系统的架构，而这也符合后来软件架构所适用的范围。如病人记录、订单跟踪、信用系统、保险、汇率兑换，这些都是IT系统，也就是企业应用。而文字处理、电梯控制、交换机、编译器、操作系统、游戏则基本不能算作企业应用。只是，2002年之后，企业应用这个名字被用的烂了，反而成了大慢笨的代表，导致07/08年的时候，甚至有不少人认为Rails不适合做企业应用。但彼时我感觉Rails对这些简单的所谓企业应用才是大杀器，毕竟大部分企业应用其实就是重度的CRUD应用，而这方面Rails堪比马克沁机枪对单兵的作战效果。至于互联网类的Web应用，交互、设计是占大头的，Rails投入使用的实际效果反而不如企业应用那么明显。</p>

<p>这本书确实是rails的设计指南，或者说是rails的设计文档。但DHH的突破和创新之处还是很明显的：</p>

<ol>
<li>本书是基于.Net 和 Java的，但提及了Python和Ruby，而作者更多的应该只是一种不抱希望的假设罢了，然而DHH真的用Ruby把这本书实作了出来。</li>
<li>虽然ActiveRecord取自于本书，然而作者本身并不是把这种模式看成一种自动化的ORM方案。广义的ORM，可以包含Dao(Table Gateway)、Data Transfer Object（json，xml）以及datamapper这些把记录化作内存对象所有模式，但狭义来看ORM是仅包含datamapper的。ActiveRecord在Fowler处其实只是一种Dao的变种。而DHH直接将ActiveRecord升格成了更高度自动化的ORM模式。</li>
<li>在视图层，坚决使用了Helper模式，未加入标签也未停留在scriplet阶段。</li>
</ol>


<p>对我而言，遗憾的一点是很晚才真的读了这本书，不知是喜是优的是因为晚读所以对这本书的内容很认可，而聊以自我安慰的是如果早读了说不定我也能
创造点什么东西，当然，最后一点纯属自娱自乐。<br/>
不过，这本书以及Rails，确实定义了过去10年Web开发的发展方向。因为Rails框架实际上已经成为了Web后台框架的一个标杆，
例如Spring MVC现在走的也是类似的道路。所以，这本书确实深深影响了Web应用的开发。</p>

<p>还有一点值得一提，就是这本书是真的基于Web总结的。很多模式的书籍，其实来源于客户端界面程序，比如从做菜单中提取出来的那些模式，而本书
是基于Web的，这就使得它和很多模式的书籍很不一样了。也因此，它才可以作为Rails的设计蓝图。而所有这些模式，大都来自于实践。实际上，
至今Rails也是Web开发优秀实践的最佳代表。而且Web开发的实践模式也不止书中提到的这些，实际上了解这些模式最好的方法就是接触Rails。虽然现在的模式比本书包含的更多了，本书依然很值得推荐阅读。</p>

<h2>笔记整理</h2>

<p>业务逻辑其实是业务反逻辑： complex business illogic</p>

<h3>分层的坏处</h3>

<ol>
<li>级联变更（Cascading Changes），就是改了一个地方往往要改n个地方</li>
<li>性能损害</li>
</ol>


<p>三层模型之所以能够流行，也是因为Web的流行。Client-Server工具中，是很难实现三层配置使用的。不过如今的App开发，好像也是三层模式。<br/>
但总体而言三层模型的流行是Web和Java等崛起的后果。</p>

<h3>常见的业务代码组织形式</h3>

<ul>
<li>Transaction Script</li>
<li>Domain Module , OO对TS的改变</li>
<li>Service层</li>
</ul>


<h3>会话状态</h3>

<ul>
<li>客户端 Cookie</li>
<li>服务端（内存）</li>
<li>共享服务端（数据库 Redis Memcache 共享文件夹）</li>
</ul>


<h3>分布式</h3>

<p>i
* 不要把不同的功能（对象）组件放在不同的服务器上，这样性能有问题
* 进程间只能尽量使用粗粒度接口，如N+1一次性读取同时返回很多信息
* 同一台服务器内部使用细粒度调用，远程外观模式<br/>
* Data Transfer Object ，传输对象，上面的那种是调用方法
* 同步的接口为主
* 异步的基于消息的处理方式
* 推动你思考而不是代替你思考，最终享受乐趣的是你，承担痛苦的也是你</p>

<h3>锁的种类</h3>

<ol>
<li>乐观锁，比如自己建立版本号；</li>
<li>悲观锁，就是常见的for lock；</li>
<li>粗颗粒（coarse-grainned)锁，就是一堆对象映射成一个入口，在入口处实施加锁；</li>
<li>隐含锁，把锁加到框架里，由Lock Manager和Lock Mapper来实现<strong>模板方法</strong>。</li>
</ol>


<h3>Stub和Mock</h3>

<p>Stub：用一个类直接替换某接口的实现，在测试或开发过程中使用这个替换类<br/>
Mock：用一个服务的重写来模拟某服务</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[锥轮、液压传动和CVT]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2014/02/15/zhui-lun-ye-ya-chuan-dong-he-cvt/"/>
    <updated>2014-02-15T11:21:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2014/02/15/zhui-lun-ye-ya-chuan-dong-he-cvt</id>
    <content type="html"><![CDATA[<h3>锥轮</h3>

<p>锥轮其实就是两个圆锥形的转筒，细细的皮带（钢带）每时刻的转动都类似在做圆周运动，但累计的变化多了，圆形就逐步缩小了。所以这种东西的长处在于可以动态地改变转圈的比例。皮带在哪个部位滚动，则是通过液压圆盘的前后移动来实现，类似于抽取出来。</p>

<p>CVT变速箱就是用了两个锥轮，两个锥轮一个是主动轮，接发动机的输出；另一个是接轮胎传动一头的，由主动轮带动，称为从动轮。主动轮和从动轮的液压盘向一个方向运动，从而使得皮带的长度不会被牵拉或缩短。而锥头到锥底之间的各种圆，就提供了连续的转圈比例。相对AT是跳跃式的，CVT就这样实现连续了。</p>

<p>这个截图很好的说明了他们之间的关系。</p>

<h3>液压传动</h3>

<p>液压传动则是很多AT包括CVT使用的技术。其特点是化手动的硬结合为软结合。通过液体的流动实现涡轮和导轮之间的动力传递。从而可以实现从静止到低速的平稳起步，因为这本身就是一个软的过程，不像手动的离合器就是直接接上了。在加速过程中，也可以相对平稳地增加输出。</p>

<h3>行星齿轮和AT</h3>

<p>其实对于AT来讲，核心的东西是行星齿轮，这个东西确实挺酷的，但也是第一次了解有这种神器存在。行星齿轮有点用多项式来模拟锥轮这种连续曲线的转速比的意思，4AT模拟4个点，6AT 8AT一路可以模拟的更多，再多一些就也能实现基本连续的变速了。连续的好处是动力损失小，而AT本身的优势是档位切换快速、技术也成熟。相对而言，锥轮最大的问题就是皮带打滑，不如4AT这样那么成熟了。</p>

<p>AT的技术较CVT成熟，6AT以上的效率损失就不高了。但是，档位越多的AT体积越大、重量也越重、制造成本也高，所以比起8AT，CVT反而是廉价的技术了。另外就是CVT无法适应大功率的发动机。所以3.0以上排量的用的就比较少了。大排量上还用CVT的主要就是日产公司了，CVT也可以说是日产的一张王牌。不过日产现在高级的CVT变速箱里面，也加了行星齿轮，严格的说是行星齿轮和锥轮结合的产物。大众奥迪在A4和A6上使用CVT也挺常见，但高功率版本的就是双离合和手自一体的天下了。</p>

<h3>变速箱的意义</h3>

<p>说一千道一万，变速箱提供了转速比的灵活，使得油耗、传动能适应多种情况。现实中，起步、低速、高速、倒车时确实需要不同的发动机工作效率和传动比例。如果是定一个转速比的话，额外的开销就有点大了。</p>

<p>从作用上来说，汽车的变速箱就是高级自行车上的飞。其实一般的平车都是不带飞的，链条链接的圈圈的尺寸是固定的。这一来是自行车这么开开也确实够了，而且自行车本身就不需要支持倒档。高档的比赛自行车为了获取最佳的性能，也才增加了变速系统。但汽车的质量和时速都和自行车差别太大，所以变速系统基本是标配的了。</p>

<h3>为什么超车需要降档</h3>

<p>主观感觉上，要提速应该放在高档。但实际上因为高档的传动比是低的，输出到轮胎上的力矩并不大。而加速主要需要增加加速度，即需要输出更高的力矩。而高速降档后，发动机的转速会迅速提高，比如从1500转提高到3000转，此时输出的力矩增加。而一般情况下要求的降档降速是为了让发动机慢下来。但如果此时反而加大油门，则发动机转速会进一步上升，输出力矩会进一步加大，也就可以获得更高的输出力矩从而获得加速度。</p>

<p>所以，降档有利于增加加速度，缺点是油耗会比高档位提速来的高。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下的虚拟化技术]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2013/08/17/linuxxia-de-xu-ni-hua-ji-zhu/"/>
    <updated>2013-08-17T20:59:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2013/08/17/linuxxia-de-xu-ni-hua-ji-zhu</id>
    <content type="html"><![CDATA[<p>因为要在一台Linux系统中虚拟化一个系统，于是这周接触了一下Linux下虚拟机的内容。<br/>
公司以前一直用的redhat的linux，我所知的虚拟技术仅限于xen和kvm，而且根据一些反馈用的并不是很好。主要体现在资源占用过大，硬盘和内存的消耗都很大，当然公司的服务器硬件配置也有点不够平衡。</p>

<p>然而，在接触了ubuntu的虚拟化后，一下子有茅塞顿开的感觉。首先，windows下我常用的virtualbox就可以在ubuntu下使用。xen和kvm当然ubuntu也是支持的。同时这几种虚拟化技术都可以按命令行的方式使用。其次，ubuntu在安装虚拟化套件方面是十分方便的。主要原因在于它的包要比redhat的时新的多。还有一点，ubuntu比起redhat还是很小巧的。这点在虚拟化的时候显得比较重要。毕竟一台主机的时候，只会安装一个os，如果大2GB那也就只是2GB。一旦云化后，一台主机往往就要4+1个操作系统，在磁盘不富裕的情况下，os的臃肿会成比例的放大。这时候小巧的os就显示出了优势。<br/>
所以我倾向于采用ubuntu server作为云化的主力os。至少应该是虚机的主体。</p>

<p>接下来就是选择何种东西虚拟化了。主要下面3种：</p>

<ul>
<li>xen: 国内用的最多，因为历史最长，也有商业化的支持</li>
<li>kvm：半虚拟化技术，做在kernel里面，redhat和ubuntu大力支持</li>
<li>virtualbox: 是的，其实这可能是最好用的linux虚机软件</li>
</ul>


<p>性能方面，根据<a href="http://www.liangsuilong.info/?p=675">kvm vs Virtualbox</a> 和 <a href="http://server.zol.com.cn/257/2575328.html">Ubuntu11.10 Xen Kvm Virtualbox比拼</a>，总体而言kvm的性能最佳，大文件比virtualbox有所不如。而且从未来规划来看，redhat和ubuntu普遍倾向于支持kvm。但是，virtualbox有两大优势：1.使用是图形化的界面，很简单； 2.与kvm和xen都专注于cpu性能不同，virtualbox的图形化性能要比另外两个都强许多。不过vbox实际上是基于qemu改进的，kvm-qemu也是一个组合。所以，普通用用的情况下可以直接上virtualbox。</p>

<p>顺手又了解了一些vnc的内容。vnc其实只是一个传送图形界面的协议，经典的client和server端模型，但具体的GUI还需要由其他东西实现。可选的有<code>xfce4</code>和<code>ubuntu-desktop</code>，前者小巧不少大约200MB，后者如果是server上安装则要1GB以上了。总体而言不如ssh方便，占用资源也多不少，不过在必须使用图形化界面的时候，都还是不错的选择。</p>
]]></content>
  </entry>
  
</feed>
