<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: 神器 | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/神器/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2013-01-08T17:07:57+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Kindle]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/12/09/kindle/"/>
    <updated>2012-12-09T20:53:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/12/09/kindle</id>
    <content type="html"><![CDATA[<p>周五终于忍不住买了一台Kindle，把玩不久之后就喜欢上了。到手没多久已经用她看完了《我的西域，你的东土》后半部分。
比起在手机上，即便是4寸的手机，看书的感觉棒多了。甚至比在电脑上看还要好，比抱着实体书看的感觉更棒。为什么这么说？</p>

<p>最简单的道理就是分量轻、字体可以很大。从体积和重量上来讲，kindle的分量只相当于一本普通的100页不到的产品说明书，手握着相当舒服。和纸质书相比，
要轻了许多，尤其是和那些大部头的书比较的话，计算机的书籍很多都是很厚的，显然轻便很多。手握着很轻松，单手也能操作，口袋里可以随便塞。在日光
下的显示效果也要好于纸质书。</p>

<p>而在字体方面更是可以做到很大。从这点上来说是对纸质书实现了全面的突破和超越。看大字不费眼不容易近视是普遍认同的，但囿于纸质书的体积和重量，
篇幅必须加以控制，而篇幅的控制除了内容本身的长短就是和字体排版大小相关了。传统书籍为了还能让人携带，或者处于印刷成本的考虑，字体都是不得不损失的，
而小字体其实阅读体验并不好，也容易伤眼。从阅读本身角度来说，字体越大眼睛越不累（当然自己感觉不到累可能眼睛会用的更多，呵呵）。Kindle就可以把
字体放置的很大，看起来就舒服多啦。</p>

<p>此外，如今的年代抱着一本书在外面看是不太好意思和别人打招呼的。Kindle就没这个问题了。带着和带pad、带手机看东西的感觉是一样的，同外部环境很协调。</p>

<p>在我看来，这绝对是阅读方面划时代的产品。对纸质书的冲击以后再写文章评论吧。大体上认为是赢家通吃&amp;长尾理论挤掉了中坚力量的存活空间。</p>

<p>最后，必须得承认<a href="" title="http://home.duokan.com/index.html">多看</a>的功能比原厂的软件做的好很多，至少在适应中国人的习惯以及中文阅读方面要强出许多。
对于我最喜欢的PDF格式支持也很好，关键一点在于支持智能重排，效果那是相当的棒。此外，多看设计的Wifi传输，其实就是ftp服务，也相当的实用。一开始
还担心安全问题，后来确认它默认是关闭ftp的。Kindle的硬件+多看软件，这个组合相当厉害。现在就等我的疯马纹皮套和SOLIS灯了。</p>

<p>I love it!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Heroku's Buildpacks and Redeploy for jekyll and octopress]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/07/21/herokus-buildpacks-and-redeploy-for-jekyll-and-octopress/"/>
    <updated>2012-07-21T09:46:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/07/21/herokus-buildpacks-and-redeploy-for-jekyll-and-octopress</id>
    <content type="html"><![CDATA[<p>Heroku是永远能给人带来惊喜的厂商，<a href="http://blog.heroku.com/archives/2012/7/17/buildpacks/?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+heroku+%28Heroku+News%29">Builpacks</a>
只得好好研究一下。从模式上来说，其实就是利用了adapter+template的方式，把变化的部分提取出来变成<strong>buildpack</strong>。
难能可贵的是，heroku是允许定制化对这部分内容进行操作和配置的。</p>

<p>试了一下，jekyll的是完全可以产生的。但是对octopress并非完全适用。
首先，对heroku而言，默认有一个<code>.slugignore</code>文件中会把source等3个文件排除在外，而没有这3个文件无法generate。但有了这3个文件，slug的体积就变大。</p>

<p>其次，有个gem需要使用python的库，无法在heroku上直接运行。</p>

<p>而作为苦逼的中国用户，还会碰到编码问题。</p>

<p>合在一起，其实原因可归结为一个，即如果generate牵涉的东西太多则不适合在heroku这样的平台按照 build/run的方式使用，毕竟环境不是完全能模拟本机的，
也不是自己的服务器环境可以自己装。</p>

<p>所以，在浪费了无数的时间之后，决定还是先用略显不舒服的办法继续运行。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript: The Good Parts]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/06/23/javascript-the-good-parts/"/>
    <updated>2012-06-23T00:08:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/06/23/javascript-the-good-parts</id>
    <content type="html"><![CDATA[<p>大约去年的这个时候,在复旦图书馆看见了&lt;JavaScript精粹>的中文版,就借来看了一下.会看这本书应该是我读了墨菲博客的推荐.
中文版花了不长的时间就看完了,因为这本书确实短小精悍,或者说相当的<strong>concise</strong> . 读完之后很是喜欢, 于是买了英文版.
再后来, 也就淡淡忘了. 尽管读过一遍, 内容却忘的差不多了, 当时只是明白了不少js的强大的能力, 解除了我对这门语言的一点迷思.
但是缺乏练习的后果必然是无法掌握的.</p>

<p>最近在看CoffeeScript 和 NodeJS, 进一步领略了JS的威力, 有些地方也不甚明白, 于是又翻出这本书看了一下.这次出奇的顺利, 从翻开
到看完也就2天的功夫, 而且2天时间内看的比例并不高.下面是看完后对这本书的书评.</p>

<p>这本书确实是一本需要反复阅读的书.作者的话语极其精炼, 招招都是要害, 所以必须要仔细看才能看的明白.而且从书中可以看出作者的造诣
确实很深, 对js的认识以及语言的评价都是高度与深度相结合, 而且很多反应了使用者的感受, 不是大家是写不出这么有深度的文章的.</p>

<p>书中最有价值的是 3.Objects, 4.Functions, 5.Inheritance 这3章. 如果是用coffeeScript的话, 3和4的价值就更加突出.通过学习,可以掌握
js的object array的文法, 也可以明白js function的4种调用方式(obj.method, func.func, Obj.construtor(new), func.apply(this, argv)),
Closure(outer inner函数之间的scope关系). 我甚至还第一次明白了汉诺塔.</p>

<p>Js的另一部分即prototype继承的特性目前还不甚了了, 可能还需呀补充一点其他读物. 做点练习才能领会.</p>

<p>JavaScript确实是门很强悍的语言, 尤其是那句它只关系对象能做什么,而不关心对象的出生是什么.
一个设计的很有问题的语言,最终统治了web浏览器,是不是有点命中注定的意思?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[月影 Foxmail cracker]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/06/13/yueyin-foxmail-cracker/"/>
    <updated>2012-06-13T10:28:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/06/13/yueyin-foxmail-cracker</id>
    <content type="html"><![CDATA[<p>我的邮箱帐号密码还是挺成体系的。但是还是有一个的帐号比较特殊，使得我也忘了。
于是找了一个月影foxmail密码的cracker工具。使用下来，效果很不错。也足够简练。</p>

<p>个人觉得如何破解foxmail的密码都可以写一篇不错的论文。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NodeJS]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/06/04/nodejs/"/>
    <updated>2012-06-04T17:12:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/06/04/nodejs</id>
    <content type="html"><![CDATA[<p>最近迷上了NodeJS和CoffeeScript.毫不夸张的说,这是我比较了解的语言中,C/CPP/Java/Ruby(可能还有Python),到目前为止最吸引我的.
特别是搭配CS的语法后, 相当的让人感觉良好.</p>

<p>而越看NodeJS越有UNIX系统编程和网络编程的味道, 仿佛Stevens的C的Lib库再生一般.这种感觉很难描述清楚,基本模式就是原来使用现在变得那么简单了.
而且NodeJS依我看来够精简,功能又够强大,但从语言和基本的平台来讲,搭配上CoffeeScript后,已经是主流语言中最强悍的一种了吧.</p>

<p>http://howtonode.org/understanding-process-next-tick</p>

<p>tick其实就是计算机系统的时隙.</p>

<h2>util</h2>

<p>util.format() 等于printf, 但是末尾跟随的参数如果过少或过多都会做处理, 过多则inspect,过少则打placeholder.
两点是多了<code>%j</code>支持json格式的输出.</p>

<p>util.debug() 用于调试的,输出到<code>stderr</code><br/>
util.log() <code>stdout</code><br/>
util.inspect(object) 展开对象信息<br/>
util.isArray, isRegExp, isDate</p>

<h2>Events</h2>

<p>All objects which emit events are instances of <code>require('events').EventEmitter</code><br/>
All EventEmitters emit the event <code>newListener</code> when new listeners are added</p>

<p>```js</p>

<h1>前一个参数是camel-cased string, 后一个是是函数,也就做listener</h1>

<p>server.on('connection', function (stream) {
  console.log('someone connected!');
});</p>

<h1>一次性事件,发生后自动消失</h1>

<p>server.once('connection', function (stream) {
  console.log('Ah, we have our first user!');
});</p>

<p>server.removeListener('connection', callback);
emitter.removeAllListeners([event])
emitter.setMaxListeners(n)</p>

<h1>返回一系列函数</h1>

<p>emitter.listeners(event)</p>

<h1>触发事件</h1>

<p>emitter.emit(event, [arg1], [arg2], [...])
```</p>

<h2>Buffer</h2>

<p>这个东西和C里面的 <code>bytes c[8192];</code> 很类似. 是在V8 heap之外对基础memory的分配,因而效率很高.但是也不能
自动增长. 是一个全局变量, 通常不需要require. 纯js对二进制支持的效率不好.对Unicode支持尚可.</p>

<ul>
<li>encodings:

<ul>
<li>ascii</li>
<li>utf8</li>
<li>ucs2</li>
<li>base64</li>
<li>binary 通常不用,而是直接用Buffer</li>
<li>hex 十六进制</li>
</ul>
</li>
</ul>


<p>```js
new Buffer(size)
new Buffer(array)
new Buffer(str, [encoding])</p>

<p>buf.write(string, [offset], [length], [encoding]) # 把string的内容写到buffer里,和c很像,但是offset默认是0,length默认是buffer的长度 - offset
buf.toString([encoding], [start], [end])
buf[index]
buf.slice([start], [end])
Buffer.byteLength(str, 'utf8')
buf.length 返回的是整个buffer的size</p>

<p>buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])
buf.fill(value, [offset], [end])
此外还有一堆读写各种类型的函数
```</p>

<h2>Stream</h2>

<p>stream是一个抽象接口, HTTP stdout都是对stream的实现.<br/>
所有的stream, 都是<code>EventEmitter</code>的实现.</p>

<h3>Readable Stream</h3>

<ul>
<li><p>Event</p>

<ul>
<li>data</li>
<li>end 可能可以继续写</li>
<li>error</li>
<li>close 不是所有的流都有关闭,比如进来的http request</li>
</ul>
</li>
<li><p>method</p>

<ul>
<li>readable</li>
<li>setEncoding(encoding) , 设置后,data返回的就不是buffer而是string</li>
<li>pause 停止<code>data</code>事件</li>
<li>resume 恢复<code>data</code>事件</li>
<li>destroy</li>
<li><p>pipe
```js
process.stdin.resume();</p>

<p>process.stdin.pipe(process.stdout, { end: false }); #截断source 的 end事件发给destination</p>

<p>process.stdin.on("end", function() {
  process.stdout.write("Goodbye\n");
});
```</p></li>
</ul>
</li>
</ul>


<h3>Writable Stream</h3>

<ul>
<li><p>Event</p>

<ul>
<li>drain 表明可以再写了</li>
<li>error</li>
<li>close</li>
<li>pipe</li>
</ul>
</li>
<li><p>method</p>

<ul>
<li>writable</li>
<li>write(string, [encoding], [fd])</li>
<li>write(buffer)</li>
<li>end()</li>
<li>end(string, encoding)</li>
<li>end(buffer)</li>
<li>destroy()</li>
</ul>
</li>
</ul>


<h2>Crypto</h2>

<p>加密解密的系类</p>

<p>```js
var filename = process.argv[2];
var crypto = require('crypto');
var fs = require('fs');</p>

<p>var shasum = crypto.createHash('sha1');</p>

<p>var s = fs.ReadStream(filename);
s.on('data', function(d) {
  shasum.update(d);
});</p>

<p>s.on('end', function() {
  var d = shasum.digest('hex');
  console.log(d + '  ' + filename);
});
```</p>

<h2>File System</h2>

<p>异步同步并举，异步时不保证执行顺序，高压环境下使用异步接口可提高效率。因为异步的本质是non-block</p>

<ul>
<li>fs.watch

<ul>
<li>Linux下用 <code>inotify</code>实现</li>
<li>返回'rename' or 'change' 事件
```js
fs.watch('somedir', function (event, filename) {
  console.log('event is: ' + event);
  if (filename) {

<pre><code>console.log('filename provided: ' + filename);
</code></pre>

  } else {

<pre><code>console.log('filename not provided');
</code></pre>

<p>  }
});
```</p></li>
</ul>
</li>
<li>fs.ReadStream</li>
<li>fs.WriteStream</li>
<li>fs.open(path, flags, [mode], [callback])
<code>(err, fd)</code></li>
</ul>


<h2>Path</h2>

<h2>Net</h2>

<ul>
<li><p>net.createServer([options], [connectionListener])<br/>
<code>js
var net = require('net');
var server = net.createServer(function(c) { //'connection' listener
console.log('server connected');
c.on('end', function() {
  console.log('server disconnected');
});
c.write('hello\r\n');
c.pipe(c);
});
server.listen(8124, function() { //'listening' listener
console.log('server bound');
});
</code></p></li>
<li><p>net.connect,net.createConnection</p>

<ul>
<li>也是一样触发<code>connect</code>事件</li>
<li>net.connect(port, [host], [connectListener])</li>
<li>net.connect(path, [connectListener])</li>
</ul>
</li>
</ul>


<h3>net.Server</h3>

<ul>
<li>server.listen(port, [host], [listeningListener])

<ul>
<li><code>listening</code> event</li>
</ul>
</li>
<li>server.close()

<ul>
<li>也是异步关闭，最终 emit <code>close</code>事件</li>
</ul>
</li>
<li>server.address() <code>{"port":43239,"family":2,"address":"0.0.0.0"}</code></li>
<li>server.maxConnections</li>
<li><p>server.connections</p></li>
<li><p>Event</p>

<ul>
<li>listening</li>
<li>connection</li>
<li>close</li>
<li>error</li>
</ul>
</li>
</ul>


<h3>net.Socket</h3>

<ul>
<li>new net.Socket([options])

<ul>
<li>fd, type, allowHalfOpen</li>
</ul>
</li>
<li>socket.connect 一般用net.connect来新建</li>
<li>bufferSize() 当前准备发的缓存长度</li>
<li>setEncoding() 指定接收data的编码</li>
<li>write(data, [encoding], [callback])</li>
<li>end([data]) half-close</li>
<li>destroy() 仅在处理error是需要使用</li>
<li>pause(), resume() 和<code>data</code>事件相关</li>
<li>setTimeout(timeout, [callback])

<ul>
<li>超时，通常没有超时</li>
<li>0则表示同步操作，而且要求即刻发掉</li>
</ul>
</li>
<li>setNoDelay() 默认就是true</li>
<li>keepAlive()</li>
<li>address(), remoteAddress(), remotePort()</li>
<li><p>bytesRead() 已收到的bytes数量， bytesWritten()</p></li>
<li><p>Event</p>

<ul>
<li>connect</li>
<li>data</li>
<li>end</li>
<li>timeout</li>
<li>drain</li>
<li>error</li>
<li>close</li>
</ul>
</li>
</ul>


<h2>UDP / Datagram Sockets</h2>

<p>  <code>require 'dgram'</code></p>

<h2>DNS</h2>

<ul>
<li>lookup()</li>
<li>resolve()</li>
</ul>


<h2>HTTP</h2>

<p>核心思想： The user is able to <strong>stream data</strong>.</p>

<h3>http</h3>

<ul>
<li>http.createServer([requestListener])</li>
</ul>


<h4>Event</h4>

<ul>
<li>'request'

<ul>
<li>(request, response) -></li>
<li>一个connection可能有多个request</li>
</ul>
</li>
<li>'connection'

<ul>
<li>(socket) -></li>
<li>一般不会直接处理，也可以通过<code>request.connection</code>获得<code>socket</code></li>
</ul>
</li>
<li>'close'</li>
<li>'checkContinue'

<ul>
<li>(request, response) -></li>
<li><a href="http://benramsey.com/blog/2009/02/http-status-100-continue-corrections/">关于100-continue</a>  ,用处就是试探，在发起实际的body前把条件等发给server预审</li>
<li><code>request</code> event will <strong>not</strong> be emitted.</li>
</ul>
</li>
<li>'upgrade'

<ul>
<li>不知何意</li>
<li>(request, socket, head) -></li>
</ul>
</li>
<li>'clientError'

<ul>
<li>(exception) -></li>
</ul>
</li>
</ul>


<h4>method</h4>

<ul>
<li>listen(port, [hostname], [callback])</li>
<li>close() = net.Server.close()</li>
</ul>


<h3>http.ServerRequest</h3>

<h4>Event</h4>

<ul>
<li>data</li>
<li>(chunk) -></li>
<li>end</li>
<li>close</li>
</ul>


<h4>method</h4>

<ul>
<li>method 'GET', 'DELETE'</li>
<li>url

<ul>
<li><code>require('url').parse(request.url, true)</code></li>
<li><code>require('querystring').parse</code></li>
</ul>
</li>
<li>request.headers</li>
<li>request.trailers

<ul>
<li>Only populated after the 'end' event.</li>
</ul>
</li>
<li>request.setEncoding([encoding])</li>
<li>pause()</li>
<li>resume()</li>
<li>connection</li>
</ul>


<h3>http.ServerResponse</h3>

<p>实现了<code>Writable Stream</code></p>

<h4>Event</h4>

<ul>
<li>'close'</li>
</ul>


<h4>Method</h4>

<ul>
<li>writeContinue()</li>
<li>writeHead(statusCode, [reasonPhrase], [headers])

<ul>
<li>必须在<code>response.end()</code>被调用之前</li>
<li><code>response.writeHead(200, {Content-Type: 'text/plain'})</code></li>
</ul>
</li>
<li>statusCode</li>
<li>setHeader(name, value)

<ul>
<li><code>response.setHeader("Content-Type", "text/html")</code></li>
</ul>
</li>
<li>getHeader(name)</li>
<li>removeHeader(name)</li>
<li>write(chunk, [encoding])

<ul>
<li>stream式的写法</li>
<li>raw</li>
<li>implicit header mode</li>
</ul>
</li>
<li>addTrailers(headers)
```js
response.writeHead(200, { 'Content-Type': 'text/plain',

<pre><code>                    'Trailer': 'Content-MD5' });
</code></pre>

<p>response.write(fileData);
response.addTrailers({'Content-MD5': "7895bf4b8828b55ceaf47747b4bca667"});
response.end();
```</p></li>
<li>end([data], [encoding])</li>
</ul>


<h3>http.request</h3>

<p>Node保持有几个可以发起http请求的连接</p>

<ul>
<li>http.request(options, callback)
```js
var options = {
host: 'www.google.com',
port: 80,
path: '/upload',
method: 'POST'
};</li>
</ul>


<p>var req = http.request(options, function(res) {
  console.log('STATUS: ' + res.statusCode);
  console.log('HEADERS: ' + JSON.stringify(res.headers));
  res.setEncoding('utf8');
  res.on('data', function (chunk) {</p>

<pre><code>console.log('BODY: ' + chunk);
</code></pre>

<p>  });
});</p>

<p>req.on('error', function(e) {
  console.log('problem with request: ' + e.message);
});</p>

<p>// write data to request body
req.write('data\n');
req.write('data\n');
req.end();
```</p>

<ul>
<li>http.get(options, callback)</li>
</ul>


<h4>http.Agent</h4>

<p>node里面客户端的socket是存放在一个pool里面的，这个pool就叫做Agent</p>

<h3>http.ClientRequest</h3>

<p>```js
request.on('response', function (response) {
  response.on('data', function (chunk) {</p>

<pre><code>console.log('BODY: ' + chunk);
</code></pre>

<p>  });
});
```</p>

<h4>Event</h4>

<ul>
<li>response

<ul>
<li>(response) -></li>
</ul>
</li>
<li>socket

<ul>
<li>(socket) -></li>
<li>给该request分配socket后触发</li>
</ul>
</li>
<li>upgrade

<ul>
<li>(response, socket, head) -></li>
<li>似乎是用来升级到websocket的</li>
</ul>
</li>
<li>continue</li>
</ul>


<h4>Method</h4>

<ul>
<li>write(chunk, [encoding])</li>
<li>end()</li>
<li>abort()</li>
<li>setTimeout(timeout, [callback])</li>
<li>setNoDelay(true/false)</li>
<li>setSocketKeepAlive([enable], [initialDelay])</li>
</ul>


<h3>http.ClientResponse</h3>

<p>a <code>Readable Stream</code></p>

<ul>
<li>data</li>
<li>end</li>
<li><p>close</p></li>
<li><p>statusCode</p></li>
<li>headers</li>
<li>trailers</li>
<li>setEncoding([encoding])</li>
<li>pause()</li>
<li>resume()</li>
</ul>


<h2>HTTPS</h2>

<h2>URL</h2>

<ul>
<li>href - <code>http://user:pass@host.com:8080/p/a/t/h?query=string#hash</code></li>
<li>protocol</li>
<li>host</li>
<li>auth</li>
<li>hostname</li>
<li>port</li>
<li>pathname</li>
<li>search</li>
<li>path</li>
<li>query</li>
<li><p>hash</p></li>
<li><p>url.parse(urlStr)</p></li>
</ul>


<p><code>js
coffee&gt; url.parse("http://192.168.2.2/?q=1&amp;q=2#sss", true)
{ protocol: 'http:',
  slashes: true,
  host: '192.168.2.2',
  hostname: '192.168.2.2',
  href: 'http://192.168.2.2/?q=1&amp;q=2#sss',
  hash: '#sss',
  search: '?q=1&amp;q=2',
  query: { q: [ '1', '2' ] },
  pathname: '/',
  path: '/?q=1&amp;q=2' }
</code></p>

<h2>Readline</h2>

<p>加入这个模块后，创建interface之后（书上仅仅说调用这个模块，没说创建）程序不会退出直至你关闭这个interface。</p>
]]></content>
  </entry>
  
</feed>
