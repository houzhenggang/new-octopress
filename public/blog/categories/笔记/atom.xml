<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: 笔记 | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/笔记/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2012-09-07T17:18:40+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ship It]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/08/03/ship-it/"/>
    <updated>2012-08-03T09:38:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/08/03/ship-it</id>
    <content type="html"><![CDATA[<p>这是此次6本其中3本项目管理书籍中读起来最快速的一本。如果说《用户故事》是告诉你需求怎么收集，《Manage It！》是
告诉大家如何给项目选择模型、设置生命周期，那么这本书则是开发中关于项目构建的干货，同时也牵涉到了一点项目团队组织的问题。</p>

<p>全篇最精彩的部分在于<strong>基础设施</strong>章节。提出了基础设施的存在是为了解决让人头疼的问题，而且是用轻松的方式予以解决。
<strong>版本库</strong>、<strong>特性跟踪软件</strong>、<strong>项目待办事宜软件</strong>、<strong>构件机</strong>、<strong>自动构建系统</strong>均属于此类。它们确实是工具和方法
但又不仅仅只是方法。实际上基础设施通过提供便利的方式轻松地解决了在PM中提到的那些需要处理的问题。对于节约成本、方便沟通、
加速进度、确定工作范围、提高质量都有巨大的促进作用，而不仅仅只是解决某一领域的问题。真正的进步只能在于人和基础设施，
这些才是可持续可重复的。</p>

<p>里面的实践大部分应该说我已经在平时的工作、项目管理中实践起来。当然有些东西是没有的，比如构件机，比如自动测试。直到现在
我依然认为写自动测试带来的工作量的增加很可能是得不偿失的。而且Web UI的测试难点依然没有真正好的办法解决。但其他几条应用已久
而且确实效果还是很不错的。另外自动构建至今也没流行开来。对于Rails等基于脚本语言的开发方法来说，自动构建还算简单，但对于Java来说可能CruiseControl
还是过于复杂了。</p>

<p>这本书的原版成版于2005年，很多思路和37signals的类似，确实是中小型团队合作项目的典范。</p>

<p>前面已经提到，此书关注的是内部项目怎么开发，所以无论需求怎么搜集（用户故事、用户案例、用户场景）最终都需要把产品分解
为<strong>特性</strong>，特性分解为<strong>任务清单</strong>。所有的任务清单都需要记录，<strong>如果没有记录就像从来没有发生过一样</strong>。合作过程中，
基础设施提供保障，<strong>任务清单则是主要沟通交流的对象</strong>，也是控制彼此节奏和提交物质量的重要根据。<strong>每日例会</strong>的内容
和清单相关，<strong>代码审查</strong>也和清单相关。可以说，<code>基础设施+任务清单+沟通+动手=软件的优良构建</code>。</p>

<p><strong>曳光弹</strong>的开发其实就是概要设计、分模块开发的意思。强调能独立的组件就独立，彼此通过接口来交互。只要接口稳定，内部
实现可以随意变化。这样替换模块也就比较方便。而且各个模块也比较容易水平扩展，哪里有瓶颈只要增加相应的处理资源即可。
所谓曳光弹，就是先把各组成部分串联起来，让系统可以动起来，类似于提供出一个原型，可以让用户触摸、点击、反馈，这几块
当然是软件开发尤其是应用软件开发应该的样子。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mange It! Your Guide to Progmatic Project Management]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/07/31/mange-it-your-guide-to-progmatic-project-management/"/>
    <updated>2012-07-31T09:04:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/07/31/mange-it-your-guide-to-progmatic-project-management</id>
    <content type="html"><![CDATA[<p>忙着写投稿的论文，这两个礼拜都没怎么打理自己的博客。买的6本书倒是看完了3本。</p>

<p>数学之美给打开了思路，用户故事则和我平时做的事情很接近。而现在这本《项目管理修炼之道》则给我的收获相对少一些。
如果只是一个死记硬背各种开发模型的人，看到这本书可能会有恍然大悟的感觉。但于我而言，一直坚持独立思考，所以很早
以前就看明白了所谓迭代、敏捷、增量和瀑布模型都是有关的，核心的一点都是把顺序模型的大瀑布打破变成小瀑布，只是
打破的方法各有差异耳。但是，能把话说得这么明确的项目管理书籍可能也就只有这一本。这只能说作者的诚实和自信造就
了这本书，也对不自己动脑子的pm们提供了参考。从这点上说，其意义还是很明确的。</p>

<p>作者的另外一个特色就是她确实<strong>是</strong>一个项目经理。因为她其他事情基本不参与，比如开发比如测试。所以她偏重管理以及
软技能谈的更多些，如何与老板交涉也谈的很多，其实和客户交谈反而不如用户故事里讲的多。</p>

<p>项目仪表盘那张，同燃尽图累计故事图很类似，其实还是七武士里面那种画圈的方式最简单明了。书中还提到了多用贴纸，不过
我对即时贴总有种混乱不堪的感觉。试试看吧，反正即时贴的成本确实很低。总之，本书适合给不怎么爱思考的背书派项目
经理使用，其精华部分在于对各种开发模型的比较与剖析。是我读过的关于开发生命周期模型介绍中最诚实、最坦露本质内容
的一本书。</p>

<p>ps. heroku把默认的域名改成herokuapp,明显域名变难看了许多。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[User Stories Applied: For Agile Software Development]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/07/11/user-stories-applied-for-agile-software-development/"/>
    <updated>2012-07-11T09:43:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/07/11/user-stories-applied-for-agile-software-development</id>
    <content type="html"><![CDATA[<p>惊讶地发现我原来一直是按<em>scrum</em>在做项目啊。除了自动化的测试案例写的不是很多，其他的特点倒是相当符合。
比如需求是条目化的随后通过交谈细化的，最终的交付物代码和软件才是最重要的。团队里面的角色很平行化，
一个team Leader+程序员，每个团队成员都要完成设计、数据库管理和测试工作，这样可以提高开发效率。
功能也是随着开发的进展而逐步加入。
Backlog就是一张功能list，只是没有引入Sprint Backlog进行分阶段的todo处理。
最大的缺失是没有客户驻场，另外就是Sprint的周期不够明确。但总体来说，从团队组织到任务完成的方式上，都是很接近Scrum的。
而且依据我的经验来说，对于3-8人的团队，中等规模，需求又易变化的项目来说，这么做是相当有效的。
至于测试，根据新的实践总结，有些东西值得写测试有些就不值得，衡量性价比永远是王道。</p>

<p>下面是一些笔记。个人认为本书最地道的地方就是将用故事与需求规格、用例、用户场景进行了比较。从实际开发中看，
我们日常使用最多的其实确实是用户故事。以后可以明确自己到底在用啥方法，而不必总是愧疚开发方式不够正规。<br/>
写故事的技巧可以进一步加强，比如尽量写封闭的，让人感觉完成某个任务的故事，而不是永远做不完的故事。<br/>
估算的数字可以跨度大一些，预估不到的东西不如估的多一些。<br/>
燃尽图和累计故事图是很好的进度跟踪与计划工具。</p>

<ul>
<li>用户故事：

<ul>
<li>用来讨论的主题汇总   card</li>
<li>交谈重于一切        conversation</li>
<li>确认，写在背面的测试 confirmation</li>
</ul>
</li>
</ul>


<p>拖网式的捕捞，从粗到细，从大到小；深度遍历用户故事</p>

<ul>
<li>识别用户<strong>角色</strong>，其实就是对用户进行分类。

<ul>
<li>对角色的合并归类剔除，以及实例化特殊角色的用户</li>
</ul>
</li>
</ul>


<p>把用户故事分成一个一个周期进行迭代开发；对不确定的事情在故事上拆成两个，分到两个阶段中去完成</p>

<p>最好是与用户直接联系，有些是有只能通过<strong>用户代理</strong>来沟通，<strong>开发经理</strong>不是好的用户代理，因为最终不是他来使用；销售人员、市场团队、领域专家、客户都是还算不错的用户代理。</p>

<p>让客户编写测试案例</p>

<p>用切蛋糕的方式来切用户故事，而不要用切奶油、切面粉的分层次的方式来切，对应用编程来说，这点并不占便宜。</p>

<p>编写封闭的故事。就是编写可以完成的故事，构成一个闭合故事的集合。
使用户有成就感。随着一个有意义的目标的实现而结束的故事，能让用户感觉使用后完成了某个任务。所以，登录并不是闭合性的故事。</p>

<p>故事点的估算：预定值可以拉得很开，比如<br/>
1/2, 1, 2, 3, 5, 8, 13, 20, 40, 80<br/>
这个类似于wbs的估算，实质是一回事情。所谓的点数是团队内部相对的度量单位</p>

<p>迭代指每次选择一组用户故事，安排好每一轮实现的故事。1-4周是一个迭代周期，5-10次的迭代都是很正常的。<br/>
迭代计划中需要对故事继续分解。如可以查看酒店的相关信息可以分解成：</p>

<ul>
<li>设计展示html</li>
<li>酒店的图片显示和介绍</li>
<li>酒店的地图位置编写</li>
<li>酒店设施和服务清单编写</li>
<li>后台数据库建表与查询</li>
<li>研究显示地图</li>
<li>帮助手册</li>
</ul>


<p>测量就是记录。<br/>
<strong>燃尽图</strong>横轴是时间纵轴是剩余任务故事点。<br/>
<strong>累计故事点图</strong>， 用于比较计划与实际完成的曲线图。<br/>
 #故事 #故事点 #状态   -- 在迭代中完成的故事表格
 迭代开始的故事点，在迭代中完成的， 改变的估算， 新加故事的故事点， 迭代结束时故事点， 然后就是迭代1，迭代2的进行记录</p>

<p>用户故事与用例的区别在于前者更类似于后者的成功场景和扩展，但是前者只是一个开始，用例则是文章写完就完毕了。
故事只是用来提示进一步和用户商谈的。很可能过一阵子就被撕掉了。用例极其容易过早陷入界面的细节中。</p>

<p>卡片也可以用软件记录，也可以用wiki记录。<br/>
用户界面以减少用户学习成本为本。<br/>
故事可以保留也可以销毁。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数学之美]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/07/02/shu-xue-zhi-mei/"/>
    <updated>2012-07-02T23:47:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/07/02/shu-xue-zhi-mei</id>
    <content type="html"><![CDATA[<p>在京东买的六本书都到了.这次的书普遍不是很厚.当然,3本项目管理的书加起来还是很厚的.也要有600多页.</p>

<p>分了2本给同事,自己抱起&lt;数学之美>先看了起来. 花了一周的时间, 这本书基本看完了. 先说说篇幅.</p>

<p>正文是256页,但是排版是很松的, 有点像经管类书籍的排版, 所以这本书的篇幅并不大.主要是27个章节, 实际就是27片文章, 大部分的来源是google黑板报.
吴军博士深入浅出的能力很强,所以大部分时候不需要大家去推算数学公式, 他会把公式的含义和影响解释的很清楚. 这是他的本事. 通篇来看, 文章大致可以
分成下面几类:</p>

<ul>
<li>信息论的基础知识<br/>
这部分主要包括第一章的信息, 文字和数字,  有些细节很有趣, 比如罗马数字原来里面含有加减法的含义</li>
<li>数学原理的应用<br/>
这个主要是以google在语言分析 语音分析 拼音输入法 是集中体现了马尔科夫链和统计学; 余弦定理与新闻分类/文章分类/自动分类</li>
<li>google的技术<br/>
数学知识只是用于帮助解决计算复杂度, 而不是作为解题的思路和理论基础.集中体现在PageRank, TF-IDF中</li>
<li>密码学的知识<br/>
当然,密码学本身也用到了数学尤其是数论的内容.包括用指纹减少信息量,提高存储和比对的效率,</li>
<li>一些知名的算法<br/>
主要有维特比</li>
<li>名人传记<br/>
这部分总有自抬身价的意思.特别是开复开复的出现很多, 也算是sns互吹了.有特色的就是这些专家大都还处于这个时代,相当有新鲜感,
当然,维特比这个算法也被当做经典算法我只能说很多东西其实运气更加重要.第一个发现的人得到特别的奖赏也是应该的.</li>
</ul>


<p>整本书有些部分是让我第一次了解了语音/文章识别用到的其实都概率推测的东西, 以及google的页面排序和TF-IDF这些指标产生. 而有些内容则触发为进一步
了解其他知识.比如昨天刚刚搞懂的频分/时分/码分复用, 这东西第一次在网络课上听到已经是十二三年前了, 即便考研的时候也未弄懂, 而这次在介绍维特比
和cdma的时候有看见了,然后再看看谢希仁的教材,竟然就懂了. 那个向量正交真的是很精巧的设计, 这样才使得接收端收到叠加信息后还能还原出来.</p>

<p>除了介绍一些新颖的做法和能引发看其他内容的兴趣, 文章也提到了一些google的文化甚至美国工程师的文化.实际上无论美国还是中国,第一流的工程师还是
向往在大公司工作, 只是美国有那么一部分喜欢创业的工程师, 中国这个比例少一些而已.否则google也不会起先山寨遍地后来又系统化地解决问题.其实两边
一流的工程师或者某个领域的权威专家都是愿意给大公司打工,也只有大公司才养得起这些高手吧.</p>

<p>整本书让人<strong>眼界打开了不少</strong>, 也能<strong>引起自己学习其他内容的兴趣</strong>, 这当然就是一本<strong>好书</strong>了. 不过,这本书的内容毕竟讲的都比较浅显, 并不是一本很耐看的书.
属于速食图书里面的营养品.提取一下主题,感兴趣的还是要自己继续找材料摸索练习才行.但是无论如何,这都是一本好书,而且很值得一看,投入产出比相当高
的一本书.否则也不值得为了它写一篇书评.</p>

<p>此外, 就是第一次了解了吴军博士. 他的履历确实相当漂亮, 文字写的也很棒, 这样的人才应该是<strong>中国IT业界的领军</strong>
人物.才是中国一流大学工程师的代表.</p>

<p>最后是分类做的一些<strong>笔记</strong>.</p>

<ul>
<li>科普</li>
</ul>


<p>文字按照意思有<strong>聚类</strong>, 类似机器学习的聚类, 副作用是有歧义性.</p>

<p>罗塞塔石碑上3种文字提供了冗余和翻译的基础.</p>

<p>数字从文字中被单独抽象出来表达.大部分是十进制的, 不过 也有玛雅人用的20进制,所以他们的一个世纪是400年.<br/>
中国数字的编解码规则是乘法.</p>

<p>托勒密的60个圆的点球模型,实现了365天+4年一润的模型.格里格拉教皇对日历闰年的调整,世纪末最后一年的闰年取消,每400年加一个闰年.
哥白尼的日心说用来更少的圆8-10个,但误差极大,直到开普勒改成这几个椭圆才最终令人信服.牛顿最后又加上了万有引力.</p>

<ul>
<li>马尔科夫与动态路径</li>
</ul>


<p>自然语言的处理从<strong>设立规则</strong>发展到了<strong>统计</strong>算概率, 就是对最终结果进行对比, 这个过程走的很漫长.<br/>
语音搜索和自动翻译用的技术是一样的,全部用的统计语言模型.最后落实到出现的次数比 P(wi|wi-1) = #(wi-1, wi)/#(wi-1)
分词也是一样的,目的就是计算出每种分词后概率最大的那个.</p>

<p>马尔科夫是用于概率简化,把前面n个条件简化成一个或者稍多一点的.</p>

<p>动态规划其实就是一种维特比算法, 然后再加入按group分成队列的话, 就能应付大部分请求了.<br/>
拼音输入法的原理也是概率统计推断, 从起点到终点找出最短路径.<br/>
条件随机场与句法分析,让被分析的内容成为句子的概率最大.<br/>
维特比和维特比优化路径微观算法.</p>

<ul>
<li>PageRank<br/>
信息熵: log32=5, 其实就是需要几位bit才能表示状态, 这也决定了搜索所需要的次数.
<code>H=-(p1.logp1 + p2.logp2 + ... + p32.logp32)</code></li>
</ul>


<p>信息的作用是<strong>消除一部分不确定性</strong>, 通过寻找<strong>相关的</strong>信息来消除.自然语言的处理就是寻找相关信息的过程.</p>

<p>搜索引擎的基本原理是对关键字做索引,然后用布尔代数计算结果.</p>

<p><strong>网页质量</strong>信息 &amp; <strong>网络相关性</strong>信息<br/>
质量是根据被引用的链接数量来做排序因子的, 可以看出他们是有学术背景的. Page眼中,页面就是一个节点, 链接就像一个弧, 把互联网用矩阵来进行描述.
排名公式:
<code>Bi = AxBi-1</code><br/>
其中Bi是N维列向量, A是一个N维方矩阵, 将上公式反复迭代10次,可得到收敛的结果,起初和假定B的每个数字都是1/N. A的值则是各元素(各网页)之间的链接
数字列表.<br/>
单文本词频(Term Frequency), 是在文章中出现的次数/总词汇数. 简称<strong>TF</strong><br/>
实际应用时又有加权处理.权重大小根据该词在所有页面中出现的次数来确定,出现多的权重就小,出现少的权重就大. 简称<strong>IDF</strong>, 公式为log(D/Dw).<br/>
<code>Tf-IDF = TF1xIDF1 + ... + TFNxIDFN</code><br/>
IDF之所以使用Log,其实就是采用每个词的信息量作为权重,而根据香农的熵公式,I(w) = -P(w)logP(w)</p>

<ul>
<li>向量相关</li>
</ul>


<p><strong>余弦定理与新闻分类</strong>,实质就是计算两个向量的夹角, 以明确相关度.计算公式就是两个向量内积然后除以向量模的乘积.</p>

<p>反SEO的一些内容,本质就是要把噪音去除, 比如把出站链接相似的网站屏蔽</p>

<p>CDMA技术. 海蒂拉马尔发明的实际上是频率跳变的码流, 然后才被用来当做复用. 这里面正交向量当做code的设计思路使得多种信号在叠加后也能按各个code分别进行还原, 这个整个设计最
重要的地方.也在此,进一步明白了频分/时分/码分的区别和特点.吴军至少写书的时候还不懂cdma背后的数学原理,否则他肯定会谈的.</p>

<p>文本自收敛分类.其实就是不停迭代计算向量.使得各类内部的距离d最短,而类间距离D最长.</p>

<ul>
<li>随机数的映射</li>
</ul>


<p>信息指纹的核心思想是通过随机数函数把内容转换为较短的随机数,这样可以用来做判定集合相同/反盗版/判定集合基本相同.即提取对应的信息保持足够简短,
这样的好处是存放和检索的成本大大下降.MD5的重复概率只有一千八百亿亿次,2的六十四次方.</p>

<p>布隆过滤器.其实就是把原始信息投射到一个几亿字节的几位中去.然后通过判断这几位是否为1,来明确后来的信息是否在要过滤的集合中.本质上就是一种随机数的算法.弱点是有一定的假阳性.</p>

<ul>
<li>其他</li>
</ul>


<p>爬虫其实就是按图论进行遍历.欧拉七桥的图论定理.每一个顶点的度必须是偶数.具体有广度优先还是深度有限?页面分析和URL提取?URL如何存放的瓶颈?</p>

<p>密码学基础,公钥私钥</p>

<h4>人物</h4>

<p>贾里尼克,捷克犹太人,吴军美国大学语言语音处理中心的创始人<br/>
马库斯,自然语言转向统计方式处理的另一个教父级别的人物, 还建立了语料库,让大家有一个平等的环境进行算法比较测试<br/>
辛格博士, AK47, 简单有效</p>

<h3>推荐书单</h3>

<p><a href="http://202.120.227.11/F/DN9IEV1ANU9DYR3D8YYF2FX84MGGMV6U9B37KVBLASBNGDQPNB-55367?func=item-global-exp&amp;doc_number=000573910&amp;item_sequence=000010&amp;sub_library=LJCXK">信息论基础</a> Cover<br/>
<a href="http://infolab.stanford.edu/~backrub/google.html">google.html</a><br/>
地址分析的有限状态机编写,还有基于概率的有限状态机<br/>
相似hash的算法(Simhash)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NodeJS]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2012/06/04/nodejs/"/>
    <updated>2012-06-04T17:12:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2012/06/04/nodejs</id>
    <content type="html"><![CDATA[<p>最近迷上了NodeJS和CoffeeScript.毫不夸张的说,这是我比较了解的语言中,C/CPP/Java/Ruby(可能还有Python),到目前为止最吸引我的.
特别是搭配CS的语法后, 相当的让人感觉良好.</p>

<p>而越看NodeJS越有UNIX系统编程和网络编程的味道, 仿佛Stevens的C的Lib库再生一般.这种感觉很难描述清楚,基本模式就是原来使用现在变得那么简单了.
而且NodeJS依我看来够精简,功能又够强大,但从语言和基本的平台来讲,搭配上CoffeeScript后,已经是主流语言中最强悍的一种了吧.</p>

<p>http://howtonode.org/understanding-process-next-tick</p>

<p>tick其实就是计算机系统的时隙.</p>

<h2>util</h2>

<p>util.format() 等于printf, 但是末尾跟随的参数如果过少或过多都会做处理, 过多则inspect,过少则打placeholder.
两点是多了<code>%j</code>支持json格式的输出.</p>

<p>util.debug() 用于调试的,输出到<code>stderr</code><br/>
util.log() <code>stdout</code><br/>
util.inspect(object) 展开对象信息<br/>
util.isArray, isRegExp, isDate</p>

<h2>Events</h2>

<p>All objects which emit events are instances of <code>require('events').EventEmitter</code><br/>
All EventEmitters emit the event <code>newListener</code> when new listeners are added</p>

<p>```js</p>

<h1>前一个参数是camel-cased string, 后一个是是函数,也就做listener</h1>

<p>server.on('connection', function (stream) {
  console.log('someone connected!');
});</p>

<h1>一次性事件,发生后自动消失</h1>

<p>server.once('connection', function (stream) {
  console.log('Ah, we have our first user!');
});</p>

<p>server.removeListener('connection', callback);
emitter.removeAllListeners([event])
emitter.setMaxListeners(n)</p>

<h1>返回一系列函数</h1>

<p>emitter.listeners(event)</p>

<h1>触发事件</h1>

<p>emitter.emit(event, [arg1], [arg2], [...])
```</p>

<h2>Buffer</h2>

<p>这个东西和C里面的 <code>bytes c[8192];</code> 很类似. 是在V8 heap之外对基础memory的分配,因而效率很高.但是也不能
自动增长. 是一个全局变量, 通常不需要require. 纯js对二进制支持的效率不好.对Unicode支持尚可.</p>

<ul>
<li>encodings:

<ul>
<li>ascii</li>
<li>utf8</li>
<li>ucs2</li>
<li>base64</li>
<li>binary 通常不用,而是直接用Buffer</li>
<li>hex 十六进制</li>
</ul>
</li>
</ul>


<p>```js
new Buffer(size)
new Buffer(array)
new Buffer(str, [encoding])</p>

<p>buf.write(string, [offset], [length], [encoding]) # 把string的内容写到buffer里,和c很像,但是offset默认是0,length默认是buffer的长度 - offset
buf.toString([encoding], [start], [end])
buf[index]
buf.slice([start], [end])
Buffer.byteLength(str, 'utf8')
buf.length 返回的是整个buffer的size</p>

<p>buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])
buf.fill(value, [offset], [end])
此外还有一堆读写各种类型的函数
```</p>

<h2>Stream</h2>

<p>stream是一个抽象接口, HTTP stdout都是对stream的实现.<br/>
所有的stream, 都是<code>EventEmitter</code>的实现.</p>

<h3>Readable Stream</h3>

<ul>
<li><p>Event</p>

<ul>
<li>data</li>
<li>end 可能可以继续写</li>
<li>error</li>
<li>close 不是所有的流都有关闭,比如进来的http request</li>
</ul>
</li>
<li><p>method</p>

<ul>
<li>readable</li>
<li>setEncoding(encoding) , 设置后,data返回的就不是buffer而是string</li>
<li>pause 停止<code>data</code>事件</li>
<li>resume 恢复<code>data</code>事件</li>
<li>destroy</li>
<li><p>pipe
```js
process.stdin.resume();</p>

<p>process.stdin.pipe(process.stdout, { end: false }); #截断source 的 end事件发给destination</p>

<p>process.stdin.on("end", function() {
  process.stdout.write("Goodbye\n");
});
```</p></li>
</ul>
</li>
</ul>


<h3>Writable Stream</h3>

<ul>
<li><p>Event</p>

<ul>
<li>drain 表明可以再写了</li>
<li>error</li>
<li>close</li>
<li>pipe</li>
</ul>
</li>
<li><p>method</p>

<ul>
<li>writable</li>
<li>write(string, [encoding], [fd])</li>
<li>write(buffer)</li>
<li>end()</li>
<li>end(string, encoding)</li>
<li>end(buffer)</li>
<li>destroy()</li>
</ul>
</li>
</ul>


<h2>Crypto</h2>

<p>加密解密的系类</p>

<p>```js
var filename = process.argv[2];
var crypto = require('crypto');
var fs = require('fs');</p>

<p>var shasum = crypto.createHash('sha1');</p>

<p>var s = fs.ReadStream(filename);
s.on('data', function(d) {
  shasum.update(d);
});</p>

<p>s.on('end', function() {
  var d = shasum.digest('hex');
  console.log(d + '  ' + filename);
});
```</p>

<h2>File System</h2>

<p>异步同步并举，异步时不保证执行顺序，高压环境下使用异步接口可提高效率。因为异步的本质是non-block</p>

<ul>
<li>fs.watch

<ul>
<li>Linux下用 <code>inotify</code>实现</li>
<li>返回'rename' or 'change' 事件
```js
fs.watch('somedir', function (event, filename) {
  console.log('event is: ' + event);
  if (filename) {

<pre><code>console.log('filename provided: ' + filename);
</code></pre>

  } else {

<pre><code>console.log('filename not provided');
</code></pre>

<p>  }
});
```</p></li>
</ul>
</li>
<li>fs.ReadStream</li>
<li>fs.WriteStream</li>
<li>fs.open(path, flags, [mode], [callback])
<code>(err, fd)</code></li>
</ul>


<h2>Path</h2>

<h2>Net</h2>

<ul>
<li><p>net.createServer([options], [connectionListener])<br/>
<code>js
var net = require('net');
var server = net.createServer(function(c) { //'connection' listener
console.log('server connected');
c.on('end', function() {
  console.log('server disconnected');
});
c.write('hello\r\n');
c.pipe(c);
});
server.listen(8124, function() { //'listening' listener
console.log('server bound');
});
</code></p></li>
<li><p>net.connect,net.createConnection</p>

<ul>
<li>也是一样触发<code>connect</code>事件</li>
<li>net.connect(port, [host], [connectListener])</li>
<li>net.connect(path, [connectListener])</li>
</ul>
</li>
</ul>


<h3>net.Server</h3>

<ul>
<li>server.listen(port, [host], [listeningListener])

<ul>
<li><code>listening</code> event</li>
</ul>
</li>
<li>server.close()

<ul>
<li>也是异步关闭，最终 emit <code>close</code>事件</li>
</ul>
</li>
<li>server.address() <code>{"port":43239,"family":2,"address":"0.0.0.0"}</code></li>
<li>server.maxConnections</li>
<li><p>server.connections</p></li>
<li><p>Event</p>

<ul>
<li>listening</li>
<li>connection</li>
<li>close</li>
<li>error</li>
</ul>
</li>
</ul>


<h3>net.Socket</h3>

<ul>
<li>new net.Socket([options])

<ul>
<li>fd, type, allowHalfOpen</li>
</ul>
</li>
<li>socket.connect 一般用net.connect来新建</li>
<li>bufferSize() 当前准备发的缓存长度</li>
<li>setEncoding() 指定接收data的编码</li>
<li>write(data, [encoding], [callback])</li>
<li>end([data]) half-close</li>
<li>destroy() 仅在处理error是需要使用</li>
<li>pause(), resume() 和<code>data</code>事件相关</li>
<li>setTimeout(timeout, [callback])

<ul>
<li>超时，通常没有超时</li>
<li>0则表示同步操作，而且要求即刻发掉</li>
</ul>
</li>
<li>setNoDelay() 默认就是true</li>
<li>keepAlive()</li>
<li>address(), remoteAddress(), remotePort()</li>
<li><p>bytesRead() 已收到的bytes数量， bytesWritten()</p></li>
<li><p>Event</p>

<ul>
<li>connect</li>
<li>data</li>
<li>end</li>
<li>timeout</li>
<li>drain</li>
<li>error</li>
<li>close</li>
</ul>
</li>
</ul>


<h2>UDP / Datagram Sockets</h2>

<p>  <code>require 'dgram'</code></p>

<h2>DNS</h2>

<ul>
<li>lookup()</li>
<li>resolve()</li>
</ul>


<h2>HTTP</h2>

<p>核心思想： The user is able to <strong>stream data</strong>.</p>

<h3>http</h3>

<ul>
<li>http.createServer([requestListener])</li>
</ul>


<h4>Event</h4>

<ul>
<li>'request'

<ul>
<li>(request, response) -></li>
<li>一个connection可能有多个request</li>
</ul>
</li>
<li>'connection'

<ul>
<li>(socket) -></li>
<li>一般不会直接处理，也可以通过<code>request.connection</code>获得<code>socket</code></li>
</ul>
</li>
<li>'close'</li>
<li>'checkContinue'

<ul>
<li>(request, response) -></li>
<li><a href="http://benramsey.com/blog/2009/02/http-status-100-continue-corrections/">关于100-continue</a>  ,用处就是试探，在发起实际的body前把条件等发给server预审</li>
<li><code>request</code> event will <strong>not</strong> be emitted.</li>
</ul>
</li>
<li>'upgrade'

<ul>
<li>不知何意</li>
<li>(request, socket, head) -></li>
</ul>
</li>
<li>'clientError'

<ul>
<li>(exception) -></li>
</ul>
</li>
</ul>


<h4>method</h4>

<ul>
<li>listen(port, [hostname], [callback])</li>
<li>close() = net.Server.close()</li>
</ul>


<h3>http.ServerRequest</h3>

<h4>Event</h4>

<ul>
<li>data</li>
<li>(chunk) -></li>
<li>end</li>
<li>close</li>
</ul>


<h4>method</h4>

<ul>
<li>method 'GET', 'DELETE'</li>
<li>url

<ul>
<li><code>require('url').parse(request.url, true)</code></li>
<li><code>require('querystring').parse</code></li>
</ul>
</li>
<li>request.headers</li>
<li>request.trailers

<ul>
<li>Only populated after the 'end' event.</li>
</ul>
</li>
<li>request.setEncoding([encoding])</li>
<li>pause()</li>
<li>resume()</li>
<li>connection</li>
</ul>


<h3>http.ServerResponse</h3>

<p>实现了<code>Writable Stream</code></p>

<h4>Event</h4>

<ul>
<li>'close'</li>
</ul>


<h4>Method</h4>

<ul>
<li>writeContinue()</li>
<li>writeHead(statusCode, [reasonPhrase], [headers])

<ul>
<li>必须在<code>response.end()</code>被调用之前</li>
<li><code>response.writeHead(200, {Content-Type: 'text/plain'})</code></li>
</ul>
</li>
<li>statusCode</li>
<li>setHeader(name, value)

<ul>
<li><code>response.setHeader("Content-Type", "text/html")</code></li>
</ul>
</li>
<li>getHeader(name)</li>
<li>removeHeader(name)</li>
<li>write(chunk, [encoding])

<ul>
<li>stream式的写法</li>
<li>raw</li>
<li>implicit header mode</li>
</ul>
</li>
<li>addTrailers(headers)
```js
response.writeHead(200, { 'Content-Type': 'text/plain',

<pre><code>                    'Trailer': 'Content-MD5' });
</code></pre>

<p>response.write(fileData);
response.addTrailers({'Content-MD5': "7895bf4b8828b55ceaf47747b4bca667"});
response.end();
```</p></li>
<li>end([data], [encoding])</li>
</ul>


<h3>http.request</h3>

<p>Node保持有几个可以发起http请求的连接</p>

<ul>
<li>http.request(options, callback)
```js
var options = {
host: 'www.google.com',
port: 80,
path: '/upload',
method: 'POST'
};</li>
</ul>


<p>var req = http.request(options, function(res) {
  console.log('STATUS: ' + res.statusCode);
  console.log('HEADERS: ' + JSON.stringify(res.headers));
  res.setEncoding('utf8');
  res.on('data', function (chunk) {</p>

<pre><code>console.log('BODY: ' + chunk);
</code></pre>

<p>  });
});</p>

<p>req.on('error', function(e) {
  console.log('problem with request: ' + e.message);
});</p>

<p>// write data to request body
req.write('data\n');
req.write('data\n');
req.end();
```</p>

<ul>
<li>http.get(options, callback)</li>
</ul>


<h4>http.Agent</h4>

<p>node里面客户端的socket是存放在一个pool里面的，这个pool就叫做Agent</p>

<h3>http.ClientRequest</h3>

<p>```js
request.on('response', function (response) {
  response.on('data', function (chunk) {</p>

<pre><code>console.log('BODY: ' + chunk);
</code></pre>

<p>  });
});
```</p>

<h4>Event</h4>

<ul>
<li>response

<ul>
<li>(response) -></li>
</ul>
</li>
<li>socket

<ul>
<li>(socket) -></li>
<li>给该request分配socket后触发</li>
</ul>
</li>
<li>upgrade

<ul>
<li>(response, socket, head) -></li>
<li>似乎是用来升级到websocket的</li>
</ul>
</li>
<li>continue</li>
</ul>


<h4>Method</h4>

<ul>
<li>write(chunk, [encoding])</li>
<li>end()</li>
<li>abort()</li>
<li>setTimeout(timeout, [callback])</li>
<li>setNoDelay(true/false)</li>
<li>setSocketKeepAlive([enable], [initialDelay])</li>
</ul>


<h3>http.ClientResponse</h3>

<p>a <code>Readable Stream</code></p>

<ul>
<li>data</li>
<li>end</li>
<li><p>close</p></li>
<li><p>statusCode</p></li>
<li>headers</li>
<li>trailers</li>
<li>setEncoding([encoding])</li>
<li>pause()</li>
<li>resume()</li>
</ul>


<h2>HTTPS</h2>

<h2>URL</h2>

<ul>
<li>href - <code>http://user:pass@host.com:8080/p/a/t/h?query=string#hash</code></li>
<li>protocol</li>
<li>host</li>
<li>auth</li>
<li>hostname</li>
<li>port</li>
<li>pathname</li>
<li>search</li>
<li>path</li>
<li>query</li>
<li><p>hash</p></li>
<li><p>url.parse(urlStr)</p></li>
</ul>


<p><code>js
coffee&gt; url.parse("http://192.168.2.2/?q=1&amp;q=2#sss", true)
{ protocol: 'http:',
  slashes: true,
  host: '192.168.2.2',
  hostname: '192.168.2.2',
  href: 'http://192.168.2.2/?q=1&amp;q=2#sss',
  hash: '#sss',
  search: '?q=1&amp;q=2',
  query: { q: [ '1', '2' ] },
  pathname: '/',
  path: '/?q=1&amp;q=2' }
</code></p>

<h2>Readline</h2>

<p>加入这个模块后，创建interface之后（书上仅仅说调用这个模块，没说创建）程序不会退出直至你关闭这个interface。</p>
]]></content>
  </entry>
  
</feed>
