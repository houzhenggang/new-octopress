<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: 项目管理 | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.heroku.com/blog/categories/项目管理/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.heroku.com/"/>
  <updated>2012-08-02T09:36:26+08:00</updated>
  <id>http://octopresszhangyu.heroku.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mange It! Your Guide to Progmatic Project Management]]></title>
    <link href="http://octopresszhangyu.heroku.com/blog/2012/07/31/mange-it-your-guide-to-progmatic-project-management/"/>
    <updated>2012-07-31T09:04:00+08:00</updated>
    <id>http://octopresszhangyu.heroku.com/blog/2012/07/31/mange-it-your-guide-to-progmatic-project-management</id>
    <content type="html"><![CDATA[<p>忙着写投稿的论文，这两个礼拜都没怎么打理自己的博客。买的6本书倒是看完了3本。</p>

<p>数学之美给打开了思路，用户故事则和我平时做的事情很接近。而现在这本《项目管理修炼之道》则给我的收获相对少一些。
如果只是一个死记硬背各种开发模型的人，看到这本书可能会有恍然大悟的感觉。但于我而言，一直坚持独立思考，所以很早
以前就看明白了所谓迭代、敏捷、增量和瀑布模型都是有关的，核心的一点都是把顺序模型的大瀑布打破变成小瀑布，只是
打破的方法各有差异耳。但是，能把话说得这么明确的项目管理书籍可能也就只有这一本。这只能说作者的诚实和自信造就
了这本书，也对不自己动脑子的pm们提供了参考。从这点上说，其意义还是很明确的。</p>

<p>作者的另外一个特色就是她确实<strong>是</strong>一个项目经理。因为她其他事情基本不参与，比如开发比如测试。所以她偏重管理以及
软技能谈的更多些，如何与老板交涉也谈的很多，其实和客户交谈反而不如用户故事里讲的多。</p>

<p>项目仪表盘那张，同燃尽图累计故事图很类似，其实还是七武士里面那种画圈的方式最简单明了。书中还提到了多用贴纸，不过
我对即时贴总有种混乱不堪的感觉。试试看吧，反正即时贴的成本确实很低。总之，本书适合给不怎么爱思考的背书派项目
经理使用，其精华部分在于对各种开发模型的比较与剖析。是我读过的关于开发生命周期模型介绍中最诚实、最坦露本质内容
的一本书。</p>

<p>ps. heroku把默认的域名改成herokuapp,明显域名变难看了许多。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[levels]]></title>
    <link href="http://octopresszhangyu.heroku.com/blog/2012/07/13/levels/"/>
    <updated>2012-07-13T10:18:00+08:00</updated>
    <id>http://octopresszhangyu.heroku.com/blog/2012/07/13/levels</id>
    <content type="html"><![CDATA[<p><img src="/images/screen_print/952-technical-hierarchy.png" alt="levels of computer engineering" /></p>

<p>来自37sigals的<a href="http://37signals.com/svn/posts/3200-levels-of-aspiration">转载</a></p>

<p>个人觉得应当以‘Really works’为最低目标， 大部分组件的使用都应该达到'Well engineered'，
至于Beautiful和Moving industry forward则要看运气了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[User Stories Applied: For Agile Software Development]]></title>
    <link href="http://octopresszhangyu.heroku.com/blog/2012/07/11/user-stories-applied-for-agile-software-development/"/>
    <updated>2012-07-11T09:43:00+08:00</updated>
    <id>http://octopresszhangyu.heroku.com/blog/2012/07/11/user-stories-applied-for-agile-software-development</id>
    <content type="html"><![CDATA[<p>惊讶地发现我原来一直是按<em>scrum</em>在做项目啊。除了自动化的测试案例写的不是很多，其他的特点倒是相当符合。
比如需求是条目化的随后通过交谈细化的，最终的交付物代码和软件才是最重要的。团队里面的角色很平行化，
一个team Leader+程序员，每个团队成员都要完成设计、数据库管理和测试工作，这样可以提高开发效率。
功能也是随着开发的进展而逐步加入。
Backlog就是一张功能list，只是没有引入Sprint Backlog进行分阶段的todo处理。
最大的缺失是没有客户驻场，另外就是Sprint的周期不够明确。但总体来说，从团队组织到任务完成的方式上，都是很接近Scrum的。
而且依据我的经验来说，对于3-8人的团队，中等规模，需求又易变化的项目来说，这么做是相当有效的。
至于测试，根据新的实践总结，有些东西值得写测试有些就不值得，衡量性价比永远是王道。</p>

<p>下面是一些笔记。个人认为本书最地道的地方就是将用故事与需求规格、用例、用户场景进行了比较。从实际开发中看，
我们日常使用最多的其实确实是用户故事。以后可以明确自己到底在用啥方法，而不必总是愧疚开发方式不够正规。<br/>
写故事的技巧可以进一步加强，比如尽量写封闭的，让人感觉完成某个任务的故事，而不是永远做不完的故事。<br/>
估算的数字可以跨度大一些，预估不到的东西不如估的多一些。<br/>
燃尽图和累计故事图是很好的进度跟踪与计划工具。</p>

<ul>
<li>用户故事：

<ul>
<li>用来讨论的主题汇总   card</li>
<li>交谈重于一切        conversation</li>
<li>确认，写在背面的测试 confirmation</li>
</ul>
</li>
</ul>


<p>拖网式的捕捞，从粗到细，从大到小；深度遍历用户故事</p>

<ul>
<li>识别用户<strong>角色</strong>，其实就是对用户进行分类。

<ul>
<li>对角色的合并归类剔除，以及实例化特殊角色的用户</li>
</ul>
</li>
</ul>


<p>把用户故事分成一个一个周期进行迭代开发；对不确定的事情在故事上拆成两个，分到两个阶段中去完成</p>

<p>最好是与用户直接联系，有些是有只能通过<strong>用户代理</strong>来沟通，<strong>开发经理</strong>不是好的用户代理，因为最终不是他来使用；销售人员、市场团队、领域专家、客户都是还算不错的用户代理。</p>

<p>让客户编写测试案例</p>

<p>用切蛋糕的方式来切用户故事，而不要用切奶油、切面粉的分层次的方式来切，对应用编程来说，这点并不占便宜。</p>

<p>编写封闭的故事。就是编写可以完成的故事，构成一个闭合故事的集合。
使用户有成就感。随着一个有意义的目标的实现而结束的故事，能让用户感觉使用后完成了某个任务。所以，登录并不是闭合性的故事。</p>

<p>故事点的估算：预定值可以拉得很开，比如<br/>
1/2, 1, 2, 3, 5, 8, 13, 20, 40, 80<br/>
这个类似于wbs的估算，实质是一回事情。所谓的点数是团队内部相对的度量单位</p>

<p>迭代指每次选择一组用户故事，安排好每一轮实现的故事。1-4周是一个迭代周期，5-10次的迭代都是很正常的。<br/>
迭代计划中需要对故事继续分解。如可以查看酒店的相关信息可以分解成：</p>

<ul>
<li>设计展示html</li>
<li>酒店的图片显示和介绍</li>
<li>酒店的地图位置编写</li>
<li>酒店设施和服务清单编写</li>
<li>后台数据库建表与查询</li>
<li>研究显示地图</li>
<li>帮助手册</li>
</ul>


<p>测量就是记录。<br/>
<strong>燃尽图</strong>横轴是时间纵轴是剩余任务故事点。<br/>
<strong>累计故事点图</strong>， 用于比较计划与实际完成的曲线图。<br/>
 #故事 #故事点 #状态   -- 在迭代中完成的故事表格
 迭代开始的故事点，在迭代中完成的， 改变的估算， 新加故事的故事点， 迭代结束时故事点， 然后就是迭代1，迭代2的进行记录</p>

<p>用户故事与用例的区别在于前者更类似于后者的成功场景和扩展，但是前者只是一个开始，用例则是文章写完就完毕了。
故事只是用来提示进一步和用户商谈的。很可能过一阵子就被撕掉了。用例极其容易过早陷入界面的细节中。</p>

<p>卡片也可以用软件记录，也可以用wiki记录。<br/>
用户界面以减少用户学习成本为本。<br/>
故事可以保留也可以销毁。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PM培训课程小结]]></title>
    <link href="http://octopresszhangyu.heroku.com/blog/2012/04/15/lessons-from-a-training-on-pm/"/>
    <updated>2012-04-15T13:42:00+08:00</updated>
    <id>http://octopresszhangyu.heroku.com/blog/2012/04/15/lessons-from-a-training-on-pm</id>
    <content type="html"><![CDATA[<p>趁着这个集成项目经理培训的五天培训，把辅导材料基本过了一遍。结合一些自己的经验，以及看<a href="http://xdite-smalltalk.tumblr.com/post/18034694291">别人</a>的一些文章，谈谈
自己的想法。</p>

<p>整本培训洋洋洒洒地讲了很多东西，客观的说能全面解析出这样一套体系的人相当的不简单。但是，这套体系应该说还是基于瀑布模型的，只不过
把大瀑布分拆成了n个小瀑布。实际上对软件开发并不太适用。不过因为整套体系认为<strong>光有集成</strong>是没有自己的竞争力的，要求有<strong>30%</strong>的软件开发内容，
于是又把软件开发放在里面。这也让我终于明白了工作的第一个部门成立的<strong>指导思想来源</strong>。因为我曾经相当一段时间纳闷为什么非要把系统集成
和研发凑合成一个部门。而且整个软件组还受集成一侧领导。这样能做出什么好东西来。但现在终于了解了这样组织的来源，而且以集成为主导也是因为这里面
要求软件比例不低于30%。</p>

<p>读了这本材料，终于明白公司是抄自国家认证考试的体系。也可能是其他人这么建议的，而也受了这个认证体系理论的影响。</p>

<p>软件开发有其自身的特点和重点。集成体系用其无所不包、范围够广的方式（9大范围）强行把软件包裹了进去。尽管看上去纳入了，但重点很不突出。
毕竟即使有软件工程也和系统工程是两码事情。所以，这次培训最大的结果是了解集成到底是什么思路，然后就通过这个考试，剩下的也只有自己继续摸索。</p>

<p>先说说集成这套体系。</p>

<p>首先，体系强调章程和计划。章程只有一个，而计划各个领域可以有很多。实际上，<strong>计划也是章程</strong>。只不过灵活度比章程强，可以按照需要进行
变更、更新，而章程定下了就不怎么更新了。计划或者章程规定了要做哪些事情，什么时候做，相关人员是什么，什么情况下需要变更。
随后就是一堆输入输出的交付物。</p>

<p>接下去的东西就好理解了，反正整个东西追求的结果都是文档。当然，文档确实有很多种，有些方法对保证系统也确实有帮助。
比如需求管理中的use case，每个case其实还是要用文字说明的，case图可以让需求方和系统分析师把东西交流清楚。但本质上就是
一个list，只是说明参与对象是什么。WBS分解，可以用于进一步细化和确认需求，分写出要做的工作。这些都是和软件开发业密切相关的，
但是在此之外，其他的东西实质上和软件的关联就不怎么大了。</p>

<p>最后，就是强调一切东西都要有确认，变更等都要走流程。这些东西如果乙方有能力实施，当然是很好的。</p>

<p>此外，还有一些东西就是骗来骗去的了。比如进度估计、成本估计，实际上即使传统的工程，能准确估算出来的都是很少的。</p>

<p>经典的启动、计划、执行、监控和收尾，又叫做PDCA（Plan Doing Check Action), 典型的普遍模型，自上而下。只是又可以分解成n个小瀑布。
但是，这个真的是软件开发里面最重要的事情嘛？</p>

<p>恐怕不是。</p>

<p>就我看来，软件或者互联网应用更多的强调对自身功能和模块的拆分，启动时往往很难明确细化东西。即使建筑工程本身，也就是这套体系产生的原型，
也有众多管理失败的案例，巴拿马运河等，那么软件对这套系统的适应性恐怕更难。而且这套体系显然没考虑很多项目管理工具的使用，如redmine、如版本控制系统，
而不同的工具或进步的工具是可以颠覆整个开发行为的。条条框框和优秀的软件结合起来会完全改变制造方式。与此相比，管理体系本身就显得僵化。当然，值得吸取的部分还是有的。
比如我们需要一个章程，需要需求的确认。</p>

<p>最最重要的，就是list要做的事情，给出最终时间。WBS后，确认细节，排好顺序，随后和用户确认。</p>

<p>而在这中间，系统的调整能力和团队和用户沟通的软实力才是起决定作用的东西。</p>

<p>Update(2012-05-15): 读了<a href="http://blog.xdite.net/posts/2012/05/13/the-startup-owners-manual-02/?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+xxddite+%28Blog.XDite.net%29">New product Introduction Model的九宗罪</a>
进一步明确了PM这套东西不适合的原因。确实，这套东西适合的是“在有確定用戶，確定市場，確定 bussiness model 的情況下才能使用。也只有在這樣的情況下才有機會成功。”
“這很大程度了解釋了為什麼：個人、大公司要『新創』一個事業很容易失敗。而一些『大公司』要『山寨』一個服務也有機會取得成功。” <br/>
那么反过来，对于不够明确的、大家都还没谱的、都需要摸索的项目就不合适。<br/>
所谓<strong>执行</strong>是针对有成熟套路的东西，考察的是系统的熟练程度和配合程度。而创新、新业务是需要<strong>试错的</strong>，其中的核心能力是<strong>学习</strong>、<strong>摸索</strong>、<strong>观察</strong>和<strong>勇气</strong>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[思考出哪些不用测试更加重要]]></title>
    <link href="http://octopresszhangyu.heroku.com/blog/2012/04/12/knowing-what-not-to-test-is-the-harder-part/"/>
    <updated>2012-04-12T21:06:00+08:00</updated>
    <id>http://octopresszhangyu.heroku.com/blog/2012/04/12/knowing-what-not-to-test-is-the-harder-part</id>
    <content type="html"><![CDATA[<p>很多次，一直问自己测试代码到底值不值？毕竟我写过几次，但最后发现写测试代码的工作量其实很大。特别是碰到需求变更，本来只要改一处的代码，变得
必须改  <strong>2x</strong> 处。做了一段时间以后，我承认这是对保证质量有效的，但是往往确实不值得，因为得不偿失。另一个问题是先写
测试还是先写程序？</p>

<p>按TDD的要求，无疑测试代码在先，实际代码在后。但根据我写web程序的经验，尤其是那些controller的经验，坚持测试代码在先基本没什么意义。在web上和
数据库上直接看见结果显然更有感觉。</p>

<p>二者结合起来，最后我们就不怎么写测试代码了。尽管对违反TDD有一种罪恶感，但在教条和现实之间，我们还是选择了现实。其实想来比坚持教条要好。但实际上可以处理的更加聪明，也更有效果些。</p>

<p>直到今天读了DHH的 <a href="http://37signals.com/svn/posts/3159-testing-like-the-tsa">测试识别</a> ， 我对上面的问题有了更深一步的认识。</p>

<ol>
<li><strong>严格按照TDD</strong>还是<strong>不写</strong>是两个极端， 实际上中间有很多中间状态。比如，比较优良的测试覆盖率应该在20%，绝不应该超过33% . 道理很简单，就是一直讽刺thoughtworks的他们是在写测试程序而不是真正<strong>有用的软件</strong>。</li>
<li>写测试本来就是不是<strong>免费</strong>的，需要阅读、需要维护、需要动脑筋、需要花时间，而这个时间比例也最好控制起来，20%是不错的一个开销比例。</li>
<li>关键问题在于，也是最难的，是<strong>识别什么东西是需要测试的</strong>，真正值得动脑筋的是这些东西。</li>
<li>识别出要写的测试后，先写测试还是后写其实和在写什么内容关系重大。针对api的可以tdd，而应用类的实际上还是可以先写代码再写测试，毕竟tdd在web中更多的是一种保障作用。</li>
</ol>


<p>得到的教训：</p>

<p>人类最可贵的是 <strong>独立思考</strong> + <strong>灵活运用</strong>， 走极端不好。实际上很多事情都是一个度的问题， 把原则用在需要的地方。 在做其他事情方面也是一样的。
不用追求用了TDD就100%，未满似乎就不是TDD。或者写不到50%以上就索性一点都不写。即使做其他事情的时候，也要牢记这个道理。原则是有价值的，但必须要有灵活的运用。这才是运用技术手段时该抱有的开放的心态。</p>
]]></content>
  </entry>
  
</feed>
